var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T;
import { g as getFrames, i as isChatPaneVisible, t as toggleChatPane, c as close } from "./frames-rNTNIV4O.js";
function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$1 = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2) c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a && a.defaultProps) for (d2 in g2 = a.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$2, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a, b2) {
  return { $$typeof: l$2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$2;
}
function escape(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
}
function R$1(a, b2, e2, d2, c2) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2) a = null;
  var h2 = false;
  if (null === a) h2 = true;
  else switch (k2) {
    case "string":
    case "number":
      h2 = true;
      break;
    case "object":
      switch (a.$$typeof) {
        case l$2:
        case n$2:
          h2 = true;
      }
  }
  if (h2) return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
    return a2;
  })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a)) for (var g2 = 0; g2 < a.length; g2++) {
    k2 = a[g2];
    var f2 = d2 + Q$1(k2, g2);
    h2 += R$1(k2, b2, e2, f2, c2);
  }
  else if (f2 = A$2(a), "function" === typeof f2) for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2) throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b2, e2) {
  if (null == a) return a;
  var d2 = [], c2 = 0;
  R$1(a, d2, "", "", function(a2) {
    return b2.call(e2, a2, c2++);
  });
  return d2;
}
function T$1(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$2() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
  S$1(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$1(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a)) throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r$1;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$2;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$2;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a.type && a.type.defaultProps) var g2 = a.type.defaultProps;
    for (f2 in b2) J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$2, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$1, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b2 = M$1.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$2, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = X$2;
react_production_min.useCallback = function(a, b2) {
  return U$1.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$1.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$1.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$1.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$1.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$1.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$1.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$1.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a) m$2.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
  if (c2 && c2.defaultProps) for (b2 in a = c2.defaultProps, a) void 0 === d2[b2] && (d2[b2] = a[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b2) {
    var c2 = a.length;
    a.push(b2);
    a: for (; 0 < c2; ) {
      var d2 = c2 - 1 >>> 1, e2 = a[d2];
      if (0 < g2(e2, b2)) a[d2] = b2, a[c2] = e2, c2 = d2;
      else break a;
    }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length) return null;
    var b2 = a[0], c2 = a.pop();
    if (c2 !== b2) {
      a[0] = c2;
      a: for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
        var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
        if (0 > g2(C2, c2)) n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
        else if (n2 < e2 && 0 > g2(x2, c2)) a[d2] = x2, a[n2] = c2, d2 = n2;
        else break a;
      }
    }
    return b2;
  }
  function g2(a, b2) {
    var c2 = a.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback) k2(t2);
      else if (b2.startTime <= a) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else break;
      b2 = h2(t2);
    }
  }
  function H5(a) {
    B2 = false;
    G2(a);
    if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
    else {
      var b2 = h2(t2);
      null !== b2 && K2(H5, b2.startTime - a);
    }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H5, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H5, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$1(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++) da.add(b2[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a)) return true;
  if (ja.call(la, a)) return false;
  if (ka.test(a)) return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2) return false;
      if (null !== c2) return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2)) return true;
  if (d2) return false;
  if (null !== c2) switch (c2.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$1(a, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$1[a] = new v$1(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z$1[b2] = new v$1(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$1[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$1[a] = new v$1(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$1[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$1[a] = new v$1(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$1[a] = new v$1(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$1[a] = new v$1(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$1[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z$1[b2] = new v$1(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A$1 = Object.assign, La;
function Ma(a) {
  if (void 0 === La) try {
    throw Error();
  } catch (c2) {
    var b2 = c2.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b2) {
  if (!a || Na) return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l2) {
        var d2 = l2;
      }
      Reflect.construct(a, [], b2);
    } else {
      try {
        b2.call();
      } catch (l2) {
        d2 = l2;
      }
      a.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
        if (1 !== g2 || 1 !== h2) {
          do
            if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h2);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca:
      return (a.displayName || "Context") + ".Consumer";
    case Ba:
      return (a._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a.render;
      a = a.displayName;
      a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Ga:
      return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
    case Ha:
      b2 = a._payload;
      a = a._init;
      try {
        return Qa(a(b2));
      } catch (c2) {
      }
  }
  return null;
}
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a) return false;
  var b2 = a._valueTracker;
  if (!b2) return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
}
function Za(a, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
function bb(a, b2) {
  ab(a, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2) if ("number" === d2) {
    if (0 === c2 && "" === a.value || a.value != c2) a.value = "" + c2;
  } else a.value !== "" + c2 && (a.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function db(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  "" !== c2 && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c2 && (a.name = c2);
}
function cb(a, b2, c2) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a) null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++) e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$1(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2) throw Error(p$1(92));
      if (eb(c2)) {
        if (1 < c2.length) throw Error(p$1(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a._wrapperState = { initialValue: Sa(c2) };
}
function ib(a, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
  null != d2 && (a.defaultValue = "" + d2);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
    for (; b2.firstChild; ) a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
function sb(a, b2) {
  a = a.style;
  for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
    var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
    "float" === c2 && (c2 = "cssFloat");
    d2 ? a.setProperty(c2, e2) : a[c2] = e2;
  }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$1(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$1(62));
  }
}
function vb(a, b2) {
  if (-1 === a.indexOf("-")) return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(p$1(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2) for (a = 0; a < b2.length; a++) Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a, b2, c2) {
  if (Ib) return a(b2, c2);
  Ib = true;
  try {
    return Gb(a, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a, b2) {
  var c2 = a.stateNode;
  if (null === c2) return null;
  var d2 = Db(c2);
  if (null === d2) return null;
  c2 = d2[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d2;
      break a;
    default:
      a = false;
  }
  if (a) return null;
  if (c2 && "function" !== typeof c2) throw Error(p$1(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a) {
  Lb = false;
}
function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b2 = a, c2 = a;
  if (a.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a) throw Error(p$1(188));
}
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2) throw Error(p$1(188));
    return b2 !== a ? null : a;
  }
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2) break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2) return Xb(e2), a;
        if (f2 === d2) return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c2.return !== d2.return) c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) throw Error(p$1(189));
      }
    }
    if (c2.alternate !== d2) throw Error(p$1(190));
  }
  if (3 !== c2.tag) throw Error(p$1(188));
  return c2.stateNode.current === c2 ? a : b2;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag) return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2) return b2;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b2) {
  var c2 = a.pendingLanes;
  if (0 === c2) return 0;
  var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2) return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a.entangledLanes;
  if (0 !== b2) for (a = a.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
  return d2;
}
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b2) {
  for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
    } else k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a);
  return b2;
}
function Ac(a, b2, c2) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c2;
}
function Bc(a, b2) {
  var c2 = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d2 = a.eventTimes;
  for (a = a.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a, b2) {
  var c2 = a.entangledLanes |= b2;
  for (a = a.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a, b2, c2, d2, e2, f2) {
  if (null === a || a.nativeEvent !== f2) return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d2;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
function Uc(a, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn) return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c2) {
      c2 = a.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a, b2, c2) {
  Xc(a) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a, b2, c2, d2);
    if (null === e2) hd(a, b2, d2, id, c2), Sc(a, d2);
    else if (Uc(e2, a, b2, c2, d2)) d2.stopPropagation();
    else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c2, d2);
        null === f2 && hd(a, b2, d2, id, c2);
        if (f2 === e2) break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else hd(a, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a, b2, c2, d2) {
  id = null;
  a = xb(d2);
  a = Wc(a);
  if (null !== a) if (b2 = Vb(a), null === b2) a = null;
  else if (c2 = b2.tag, 13 === c2) {
    a = Wb(b2);
    if (null !== a) return a;
    a = null;
  } else if (3 === c2) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a = null;
  } else b2 !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++) ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a) a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a) return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b2) {
  switch (a) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b2.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b2) {
  if (ie) return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
}
function ne(a, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b2 = ue(a);
  if (Wa(b2)) return a;
}
function ve(a, b2) {
  if ("change" === a) return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a, xb(a));
    Jb(re, b2);
  }
}
function Ce(a, b2, c2) {
  "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}
function Ee(a, b2) {
  if ("click" === a) return te(b2);
}
function Fe(a, b2) {
  if ("input" === a || "change" === a) return te(b2);
}
function Ge(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b2) {
  if (He(a, b2)) return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2) return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length) return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a[e2], b2[e2])) return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; ) a = a.firstChild;
  return a;
}
function Ke(a, b2) {
  var c2 = Je(a);
  a = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2) return { node: c2, offset: b2 - a };
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2) a = b2.contentWindow;
    else break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Ne(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Oe(a) {
  var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
      else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c2; a = a.parentNode; ) 1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++) a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b2 = We[a], c2;
  for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a] = b2[c2];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c2;
  Ub(d2, b2, void 0, a);
  a.currentTarget = null;
}
function se(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a.length; c2++) {
    var d2 = a[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
        var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
      else for (g2 = 0; g2 < d2.length; g2++) {
        h2 = d2[g2];
        k2 = h2.instance;
        l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a + "__bubble";
  c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
}
function qf(a, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
}
function hd(a, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
    if (null === d2) return;
    var g2 = d2.tag;
    if (3 === g2 || 4 === g2) {
      var h2 = d2.stateNode.containerInfo;
      if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
      if (4 === g2) for (g2 = d2.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h2; ) {
        g2 = Wc(h2);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d2 = f2 = g2;
          continue a;
        }
        h2 = h2.parentNode;
      }
    }
    d2 = d2.return;
  }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c2)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x2 = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
        else if (me(h3)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a, h3, d3);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c2) : ke(a, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a, b2, c2) {
  return { instance: a, listener: b2, currentTarget: c2 };
}
function oe(a, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
function vf(a) {
  if (null === a) return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2) break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b2, c2) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c2) throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a.removeChild(c2);
    if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
      if (0 === d2) {
        a.removeChild(e2);
        bd(b2);
        return;
      }
      d2--;
    } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c2 = a.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2) return a;
        b2--;
      } else "/$" === c2 && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2) return b2;
  for (var c2 = a.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child) for (a = Mf(a); null !== a; ) {
        if (c2 = a[Of]) return c2;
        a = Mf(a);
      }
      return b2;
    }
    a = c2;
    c2 = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p$1(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2) return Vf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2) e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b2, c2) {
  if (H.current !== Vf) throw Error(p$1(168));
  G(H, b2);
  G(Wf, c2);
}
function bg(a, b2, c2) {
  var d2 = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext) return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2) if (!(e2 in b2)) throw Error(p$1(108, Ra(a) || "Unknown", e2));
  return A$1({}, c2, d2);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b2, c2) {
  var d2 = a.stateNode;
  if (!d2) throw Error(p$1(169));
  c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a < c2.length; a++) {
        var d2 = c2[a];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
function ug(a, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d2 = rg;
  a = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a;
  } else rg = 1 << f2 | c2 << e2 | d2, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
}
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a, b2)) {
        if (Dg(a)) throw Error(p$1(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p$1(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg) return false;
  if (!I) return Fg(a), I = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a)) throw Hg(), Error(p$1(418));
    for (; b2; ) Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p$1(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; ) a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b2, c2) {
  a = c2.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag) throw Error(p$1(309));
        var d2 = c2.stateNode;
      }
      if (!d2) throw Error(p$1(147, a));
      var e2 = d2, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
      b2 = function(a2) {
        var b3 = e2.refs;
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a) throw Error(p$1(284));
    if (!c2._owner) throw Error(p$1(290, a));
  }
  return a;
}
function Mg(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function Ng(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function Og(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a) return null;
    for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = Pg(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a) return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya) return m2(a2, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = Lg(a2, b3, c3), d3.return = a2, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = Lg(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  function l2(a2, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function q2(a2, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a2.mode, c3), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = Lg(a2, null, b3), c3.return = a2, c3;
        case wa:
          return b3 = Sg(b3, a2.mode, c3), b3.return = a2, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a2, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a2.mode, c3, null), b3.return = a2, b3;
      Mg(a2, b3);
    }
    return null;
  }
  function r2(a2, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a2,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a2, b3, c3, d3, null);
      Mg(a2, c3);
    }
    return null;
  }
  function y2(a2, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
        case wa:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a2, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3)) return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length) return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++) u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3) throw Error(p$1(150));
    h3 = l3.call(h3);
    if (null == h3) throw Error(p$1(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done) return c2(
      e3,
      m3
    ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a2, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a2, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a2, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a2, l3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                }
                c2(a2, l3);
                break;
              } else b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                c2(a2, d3.sibling);
                d3 = e2(d3, f3.children || []);
                d3.return = a2;
                a2 = d3;
                break a;
              } else {
                c2(a2, d3);
                break;
              }
              else b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
      }
      if (eb(f3)) return n2(a2, d3, f3, h3);
      if (Ka(f3)) return t2(a2, d3, f3, h3);
      Mg(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = Qg(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a) {
  var b2 = Wg.current;
  E(Wg);
  a._currentValue = b2;
}
function bh(a, b2, c2) {
  for (; null !== a; ) {
    var d2 = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a === c2) break;
    a = a.return;
  }
}
function ch(a, b2) {
  Xg = a;
  Zg = Yg = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (dh = true), a.firstContext = null);
}
function eh(a) {
  var b2 = a._currentValue;
  if (Zg !== a) if (a = { context: a, memoizedValue: b2, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$1(308));
    Yg = a;
    Xg.dependencies = { lanes: 0, firstContext: a };
  } else Yg = Yg.next = a;
  return b2;
}
var fh = null;
function gh(a) {
  null === fh ? fh = [a] : fh.push(a);
}
function hh(a, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a, d2);
}
function ih(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a;
  for (a = a.return; null !== a; ) a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function mh(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a, b2, c2) {
  var d2 = a.updateQueue;
  if (null === d2) return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a, c2);
}
function oh(a, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
function ph(a, b2) {
  var c2 = a.updateQueue, d2 = a.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a.updateQueue = c2;
    return;
  }
  a = c2.lastBaseUpdate;
  null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a, b2, c2, d2) {
  var e2 = a.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
      else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else null === f2 && (e2.shared.lanes = 0);
    rh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
function sh(a, b2, c2) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a) for (b2 = 0; b2 < a.length; b2++) {
    var d2 = a[b2], e2 = d2.callback;
    if (null !== e2) {
      d2.callback = null;
      d2 = c2;
      if ("function" !== typeof e2) throw Error(p$1(191, e2));
      e2.call(d2);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a) {
  if (a === th) throw Error(p$1(174));
  return a;
}
function yh(a, b2) {
  G(wh, b2);
  G(vh, a);
  G(uh, th);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E(uh);
  G(uh, b2);
}
function zh() {
  E(uh);
  E(vh);
  E(wh);
}
function Ah(a) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a.type);
  b2 !== c2 && (G(vh, a), G(uh, c2));
}
function Bh(a) {
  vh.current === a && (E(uh), E(vh));
}
var L = Uf(0);
function Ch(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P() {
  throw Error(p$1(321));
}
function Mh(a, b2) {
  if (null === b2) return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++) if (!He(a[c2], b2[c2])) return false;
  return true;
}
function Nh(a, b2, c2, d2, e2, f2) {
  Hh = f2;
  M = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
  a = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p$1(301));
      f2 += 1;
      O = N = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N && null !== N.next;
  Hh = 0;
  O = N = M = null;
  Ih = false;
  if (b2) throw Error(p$1(300));
  return a;
}
function Sh() {
  var a = 0 !== Kh;
  Kh = 0;
  return a;
}
function Th() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a : O = O.next = a;
  return O;
}
function Uh() {
  if (null === N) {
    var a = M.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = N.next;
  var b2 = null === O ? M.memoizedState : O.next;
  if (null !== b2) O = b2, N = a;
  else {
    if (null === a) throw Error(p$1(310));
    N = a;
    a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
  }
  return O;
}
function Vh(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function Wh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = N, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        M.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a = c2.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, M.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a, b2) {
  var c2 = M, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a), [a]);
  if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q) throw Error(p$1(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
function di(a, b2, c2) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c2 };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
}
function ci(a, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && fi(a);
}
function ai(a, b2, c2) {
  return c2(function() {
    ei(b2) && fi(a);
  });
}
function ei(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c2 = b2();
    return !He(a, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a) {
  var b2 = ih(a, 1);
  null !== b2 && gi(b2, a, 1, -1);
}
function hi(a) {
  var b2 = Th();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ii.bind(null, M, a);
  return [b2.memoizedState, a];
}
function bi(a, b2, c2, d2) {
  a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
  return a;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a, b2, c2, d2) {
  var e2 = Th();
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function li(a, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N) {
    var g2 = N.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
function mi(a, b2) {
  return ki(8390656, 8, a, b2);
}
function $h(a, b2) {
  return li(2048, 8, a, b2);
}
function ni(a, b2) {
  return li(4, 2, a, b2);
}
function oi(a, b2) {
  return li(4, 4, a, b2);
}
function pi(a, b2) {
  if ("function" === typeof b2) return a = a(), b2(a), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a = a(), b2.current = a, function() {
    b2.current = null;
  };
}
function qi(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return li(4, 4, pi.bind(null, b2, a), c2);
}
function ri() {
}
function si(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}
function ti(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}
function ui(a, b2, c2) {
  if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), M.lanes |= c2, rh |= c2, a.baseState = true);
  return b2;
}
function vi(a, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a(false), b2();
  } finally {
    C = c2, Gh.transition = d2;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a, b2, c2) {
  var d2 = yi(a);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b2, c2);
  else if (c2 = hh(a, b2, c2, d2), null !== c2) {
    var e2 = R();
    gi(c2, a, d2, e2);
    Bi(c2, b2, d2);
  }
}
function ii(a, b2, c2) {
  var d2 = yi(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
      var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
      e2.hasEagerState = true;
      e2.eagerState = h2;
      if (He(h2, g2)) {
        var k2 = b2.interleaved;
        null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
        b2.interleaved = e2;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c2 = hh(a, b2, e2, d2);
    null !== c2 && (e2 = R(), gi(c2, a, d2, e2), Bi(c2, b2, d2));
  }
}
function zi(a) {
  var b2 = a.alternate;
  return a === M || null !== b2 && b2 === M;
}
function Ai(a, b2) {
  Jh = Ih = true;
  var c2 = a.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a.pending = b2;
}
function Bi(a, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b2) {
  Th().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a),
    c2
  );
}, useLayoutEffect: function(a, b2) {
  return ki(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ki(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d2.queue = a;
  a = a.dispatch = xi.bind(null, M, a);
  return [d2.memoizedState, a];
}, useRef: function(a) {
  var b2 = Th();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
  return Th().memoizedState = a;
}, useTransition: function() {
  var a = hi(false), b2 = a[0];
  a = vi.bind(null, a[1]);
  Th().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c2) {
  var d2 = M, e2 = Th();
  if (I) {
    if (void 0 === c2) throw Error(p$1(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q) throw Error(p$1(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d2,
    f2,
    a
  ), [a]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a) {
    var b2 = Uh();
    return ui(b2, N.memoizedState, a);
  },
  useTransition: function() {
    var a = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a) {
  var b2 = Uh();
  return null === N ? b2.memoizedState = a : ui(b2, N.memoizedState, a);
}, useTransition: function() {
  var a = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a, b2) {
  if (a && a.defaultProps) {
    b2 = A$1({}, b2);
    a = a.defaultProps;
    for (var c2 in a) void 0 === b2[c2] && (b2[c2] = a[c2]);
    return b2;
  }
  return b2;
}
function Di(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a.memoizedState = c2;
  0 === a.lanes && (a.updateQueue.baseState = c2);
}
var Ei = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c2 = R(), d2 = yi(a), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a, e2, d2);
  null !== b2 && (gi(b2, a, d2, c2), oh(b2, a, d2));
} };
function Fi(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function Gi(a, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
  b2 = new b2(c2, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a.stateNode = b2;
  b2._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a, b2, c2, d2) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = {};
  kh(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a, b2, f2, c2), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a, c2, e2, d2), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function Ji(a, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
function Ki(a, b2, c2) {
  return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li(a, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi = d2);
    Li(a, b2);
  };
  return c2;
}
function Qi(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Si(a, b2, c2) {
  var d2 = a.pingCache;
  if (null === d2) {
    d2 = a.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a = Ti.bind(null, a, b2, c2), b2.then(a, a));
}
function Ui(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag) b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Vi(a, b2, c2, d2, e2) {
  if (0 === (a.mode & 1)) return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a, b2, c2, d2) {
  b2.child = null === a ? Vg(b2, null, c2, d2) : Ug(b2, a.child, c2, d2);
}
function Yi(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a && !dh) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, d2, e2);
  return b2.child;
}
function $i(a, b2, c2, d2, e2) {
  if (null === a) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a, b2, f2, d2, e2);
    a = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a.ref === b2.ref) return Zi(a, b2, e2);
  }
  b2.flags |= 1;
  a = Pg(f2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function bj(a, b2, c2, d2, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d2) && a.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2)) 0 !== (a.flags & 131072) && (dh = true);
    else return b2.lanes = a.lanes, Zi(a, b2, e2);
  }
  return cj(a, b2, c2, d2, e2);
}
function dj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
  else {
    if (0 === (c2 & 1073741824)) return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d2 = null !== f2 ? f2.baseLanes : c2;
    G(ej, fj);
    fj |= d2;
  }
  else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
  Xi(a, b2, e2, c2);
  return b2.child;
}
function gj(a, b2) {
  var c2 = b2.ref;
  if (null === a && null !== c2 || null !== a && a.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a && !dh) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, c2, e2);
  return b2.child;
}
function hj(a, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode) ij(a, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a, b2, c2, d2, f2, e2);
}
function jj(a, b2, c2, d2, e2, f2) {
  gj(a, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2) return e2 && dg(b2, c2, false), Zi(a, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a && g2 ? (b2.child = Ug(b2, a.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  yh(a, b2.containerInfo);
}
function lj(a, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a, b2, c2, d2);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function oj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2) f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState) e2 |= 1;
  G(L, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a = Tg(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a) : qj(b2, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a.child;
  a = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function qj(a, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function sj(a, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a.child, null, c2);
  a = qj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function rj(a, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p$1(422))), sj(a, b2, g2, d2);
    if (null !== b2.memoizedState) return b2.child = a.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1)) return sj(a, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2) var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$1(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (dh || h2) {
    d2 = Q;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a, e2), gi(d2, a, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$1(421)));
    return sj(a, b2, g2, d2);
  }
  if ("$?" === e2.data) return b2.flags |= 128, b2.child = a.child, b2 = uj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a, b2, c2) {
  a.lanes |= b2;
  var d2 = a.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a.return, b2, c2);
}
function wj(a, b2, c2, d2, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function xj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a, b2, d2.children, c2);
  d2 = L.current;
  if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b2.child; null !== a; ) {
      if (13 === a.tag) null !== a.memoizedState && vj(a, c2, b2);
      else if (19 === a.tag) vj(a, c2, b2);
      else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b2) break a;
      for (; null === a.sibling; ) {
        if (null === a.return || a.return === b2) break a;
        a = a.return;
      }
      a.sibling.return = a.return;
      a = a.sibling;
    }
    d2 &= 1;
  }
  G(L, d2);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c2 = b2.child;
      for (e2 = null; null !== c2; ) a = c2.alternate, null !== a && null === Ch(a) && (e2 = c2), c2 = c2.sibling;
      c2 = e2;
      null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
      wj(b2, false, e2, c2, f2);
      break;
    case "backwards":
      c2 = null;
      e2 = b2.child;
      for (b2.child = null; null !== e2; ) {
        a = e2.alternate;
        if (null !== a && null === Ch(a)) {
          b2.child = e2;
          break;
        }
        a = e2.sibling;
        e2.sibling = c2;
        c2 = e2;
        e2 = a;
      }
      wj(b2, true, c2, null, f2);
      break;
    case "together":
      wj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function ij(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a, b2, c2) {
  null !== a && (b2.dependencies = a.dependencies);
  rh |= b2.lanes;
  if (0 === (c2 & b2.childLanes)) return null;
  if (null !== a && b2.child !== a.child) throw Error(p$1(153));
  if (null !== b2.child) {
    a = b2.child;
    c2 = Pg(a, a.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a.sibling; ) a = a.sibling, c2 = c2.sibling = Pg(a, a.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated) return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes)) return oj(a, b2, c2);
        G(L, L.current & 1);
        a = Zi(a, b2, c2);
        return null !== a ? a.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d2) return xj(a, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L, L.current);
      if (d2) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a, b2, c2);
  }
  return Zi(a, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag) a.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2) break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2) return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a, b2, c2, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
      var h2 = e2[l2];
      for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
        for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
      } else c2 || (f2 || (f2 = []), f2.push(
        l2,
        c2
      )), c2 = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2) b2.flags |= 4;
  }
};
Cj = function(a, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Dj(a, b2) {
  if (!I) switch (a.tailMode) {
    case "hidden":
      b2 = a.tail;
      for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
      null === c2 ? a.tail = null : c2.sibling = null;
      break;
    case "collapsed":
      c2 = a.tail;
      for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
      null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
  }
}
function S(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
  if (b2) for (var e2 = a.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else for (e2 = a.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d2;
  a.childLanes = c2;
  return b2;
}
function Ej(a, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a || null === a.child) Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a, b2);
      S(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a && null != b2.stateNode) Bj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode) throw Error(p$1(166));
          S(b2);
          return null;
        }
        a = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h2 = f2[g2];
            "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
              d2.textContent,
              h2,
              a
            ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
          }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
          a[Of] = b2;
          a[Pf] = d2;
          zj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], a);
                e2 = d2;
                break;
              case "source":
                D("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e2 = d2;
                break;
              case "details":
                D("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za(a, d2);
                e2 = Ya(a, d2);
                D("invalid", a);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                D("invalid", a);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2) if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
            }
            switch (c2) {
              case "input":
                Va(a);
                db(a, d2, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode) Cj(a, b2, a.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$1(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a = xg, null !== a) switch (a.tag) {
              case 3:
                Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                break;
              case 5:
                true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
            }
          }
          f2 && (b2.flags |= 4);
        } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E(L);
      d2 = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a) {
            if (!f2) throw Error(p$1(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$1(317));
            f2[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return zh(), Aj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return ah(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(L);
      f2 = b2.memoizedState;
      if (null === f2) return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d2) Dj(f2, false);
      else {
        if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b2.child; null !== a; ) {
          g2 = Ch(a);
          if (null !== g2) {
            b2.flags |= 128;
            Dj(f2, false);
            d2 = g2.updateQueue;
            null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d2 = c2;
            for (c2 = b2.child; null !== c2; ) f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
            G(L, L.current & 1 | 2);
            return b2.child;
          }
          a = a.sibling;
        }
        null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
      }
      else {
        if (!d2) if (a = Ch(g2), null !== a) {
          if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S(b2), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Ij(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E(L);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate) throw Error(p$1(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a, b2) {
  var c2 = a.ref;
  if (null !== c2) if ("function" === typeof c2) try {
    c2(null);
  } catch (d2) {
    W(a, b2, d2);
  }
  else c2.current = null;
}
function Mj(a, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a, b2, d2);
  }
}
var Nj = false;
function Oj(a, b2) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a) var c2 = { start: a.selectionStart, end: a.selectionEnd };
    else a: {
      c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
      var d2 = c2.getSelection && c2.getSelection();
      if (d2 && 0 !== d2.rangeCount) {
        c2 = d2.anchorNode;
        var e2 = d2.anchorOffset, f2 = d2.focusNode;
        d2 = d2.focusOffset;
        try {
          c2.nodeType, f2.nodeType;
        } catch (F2) {
          c2 = null;
          break a;
        }
        var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
            q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
            3 === q2.nodeType && (g2 += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a) break b;
            r2 === c2 && ++l2 === e2 && (h2 = g2);
            r2 === f2 && ++m2 === d2 && (k2 = g2);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
      } else c2 = null;
    }
    c2 = c2 || { start: 0, end: 0 };
  } else c2 = null;
  Df = { focusedElem: a, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; ) if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a) a.return = b2, V = a;
  else for (; null !== V; ) {
    b2 = V;
    try {
      var n2 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b2.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$1(163));
      }
    } catch (F2) {
      W(b2, b2.return, F2);
    }
    a = b2.sibling;
    if (null !== a) {
      a.return = b2.return;
      V = a;
      break;
    }
    V = b2.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Qj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a) === a) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c2 = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c2;
        break;
      default:
        a = c2;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
function Sj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Sj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Tj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Uj(a) {
  a: for (; ; ) {
    for (; null === a.sibling; ) {
      if (null === a.return || Tj(a.return)) return null;
      a = a.return;
    }
    a.sibling.return = a.return;
    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;
      else a.child.return = a, a = a.child;
    }
    if (!(a.flags & 2)) return a.stateNode;
  }
}
function Vj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a = a.child, null !== a)) for (Vj(a, b2, c2), a = a.sibling; null !== a; ) Vj(a, b2, c2), a = a.sibling;
}
function Wj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
  else if (4 !== d2 && (a = a.child, null !== a)) for (Wj(a, b2, c2), a = a.sibling; null !== a; ) Wj(a, b2, c2), a = a.sibling;
}
var X$1 = null, Xj = false;
function Yj(a, b2, c2) {
  for (c2 = c2.child; null !== c2; ) Zj(a, b2, c2), c2 = c2.sibling;
}
function Zj(a, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c2);
  } catch (h2) {
  }
  switch (c2.tag) {
    case 5:
      U || Lj(c2, b2);
    case 6:
      var d2 = X$1, e2 = Xj;
      X$1 = null;
      Yj(a, b2, c2);
      X$1 = d2;
      Xj = e2;
      null !== X$1 && (Xj ? (a = X$1, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Xj ? (a = X$1, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e2 = Xj;
      X$1 = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a, b2, c2);
      X$1 = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a, b2, c2);
      break;
    case 1:
      if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
        d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
      } catch (h2) {
        W(c2, b2, h2);
      }
      Yj(a, b2, c2);
      break;
    case 21:
      Yj(a, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a, b2, c2), U = d2) : Yj(a, b2, c2);
      break;
    default:
      Yj(a, b2, c2);
  }
}
function ak(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c2 = a.stateNode;
    null === c2 && (c2 = a.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function ck(a, b2) {
  var c2 = b2.deletions;
  if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    try {
      var f2 = a, g2 = b2, h2 = g2;
      a: for (; null !== h2; ) {
        switch (h2.tag) {
          case 5:
            X$1 = h2.stateNode;
            Xj = false;
            break a;
          case 3:
            X$1 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X$1 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h2 = h2.return;
      }
      if (null === X$1) throw Error(p$1(160));
      Zj(f2, g2, e2);
      X$1 = null;
      Xj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l2) {
      W(e2, b2, l2);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a), b2 = b2.sibling;
}
function dk(a, b2) {
  var c2 = a.alternate, d2 = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        try {
          Pj(3, a, a.return), Qj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Pj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2) try {
          "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
          vb(h2, g2);
          var l2 = vb(h2, f2);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m2 = k2[g2], q2 = k2[g2 + 1];
            "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
          }
          switch (h2) {
            case "input":
              bb(e2, f2);
              break;
            case "textarea":
              ib(e2, f2);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e2,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e2[Pf] = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 6:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        if (null === a.stateNode) throw Error(p$1(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a);
      ek(a);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t2) {
        W(a, a.return, t2);
      }
      break;
    case 4:
      ck(b2, a);
      ek(a);
      break;
    case 13:
      ck(b2, a);
      ek(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d2 & 4 && ak(a);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a), U = l2) : ck(b2, a);
      ek(a);
      if (d2 & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
          for (q2 = V = m2; null !== V; ) {
            r2 = V;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d2 = r2;
                  c2 = r2.return;
                  try {
                    b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W(d2, c2, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
              } catch (t2) {
                W(a, a.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W(a, a.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b2, a);
      ek(a);
      d2 & 4 && ak(a);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a
      ), ek(a);
  }
}
function ek(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$1(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a);
          Wj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a);
          Vj(a, h2, g2);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function hk(a, b2, c2) {
  V = a;
  ik(a);
}
function ik(a, b2, c2) {
  for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Jj;
        var l2 = U;
        Jj = g2;
        if ((U = k2) && !l2) for (V = e2; null !== V; ) g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
        for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
        V = e2;
        Jj = h2;
        U = l2;
      }
      kk(a);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a);
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U || Qj(5, b2);
            break;
          case 1:
            var d2 = b2.stateNode;
            if (b2.flags & 4 && !U) if (null === c2) d2.componentDidMount();
            else {
              var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
              d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b2.updateQueue;
            null !== f2 && sh(b2, f2, d2);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c2 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c2 = b2.child.stateNode;
                  break;
                case 1:
                  c2 = b2.child.stateNode;
              }
              sh(b2, g2, c2);
            }
            break;
          case 5:
            var h2 = b2.stateNode;
            if (null === c2 && b2.flags & 4) {
              c2 = h2;
              var k2 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c2.focus();
                  break;
                case "img":
                  k2.src && (c2.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l2 = b2.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$1(163));
        }
        U || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function gk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function jk(a) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a = C;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function gi(a, b2, c2, d2) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$1(185));
  Ac(a, c2, d2);
  if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a, Z)), Dk(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a, b2) {
  var c2 = a.callbackNode;
  wc(a, b2);
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2) null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
      0 === (K & 6) && jg();
    }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c2;
  }
}
function Gk(a, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p$1(327));
  var c2 = a.callbackNode;
  if (Hk() && a.callbackNode !== c2) return null;
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2) return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2) b2 = Ik(a, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a || Z !== b2) uk = null, Gj = B() + 500, Kk(a, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Nk(a, e2)));
    if (1 === b2) throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
    if (6 === b2) Ck(a, d2);
    else {
      e2 = a.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Nk(a, f2))), 1 === b2)) throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
      a.finishedWork = e2;
      a.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Pk(a, tk, uk);
          break;
        case 3:
          Ck(a, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a, 0)) break;
            e2 = a.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 4:
          Ck(a, d2);
          if ((d2 & 4194240) === d2) break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 5:
          Pk(a, tk, uk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Dk(a, B());
  return a.callbackNode === c2 ? Gk.bind(null, a) : null;
}
function Nk(a, b2) {
  var c2 = sk;
  a.current.memoizedState.isDehydrated && (Kk(a, b2).flags |= 256);
  a = Ik(a, b2);
  2 !== a && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a;
}
function Fj(a) {
  null === tk ? tk = a : tk.push.apply(tk, a);
}
function Ok(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2], f2 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He(f2(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
    else {
      if (b2 === a) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a[c2] = -1;
    b2 &= ~d2;
  }
}
function Ek(a) {
  if (0 !== (K & 6)) throw Error(p$1(327));
  Hk();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1)) return Dk(a, B()), null;
  var c2 = Ik(a, b2);
  if (0 !== a.tag && 2 === c2) {
    var d2 = xc(a);
    0 !== d2 && (b2 = d2, c2 = Nk(a, d2));
  }
  if (1 === c2) throw c2 = pk, Kk(a, 0), Ck(a, b2), Dk(a, B()), c2;
  if (6 === c2) throw Error(p$1(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Pk(a, tk, uk);
  Dk(a, B());
  return null;
}
function Qk(a, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a(b2);
  } finally {
    K = c2, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c2 = ok.transition, d2 = C;
  try {
    if (ok.transition = null, C = 1, a) return a();
  } finally {
    C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c2 = a.timeoutHandle;
  -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
  if (null !== Y) for (c2 = Y.return; null !== c2; ) {
    var d2 = c2;
    wg(d2);
    switch (d2.tag) {
      case 1:
        d2 = d2.type.childContextTypes;
        null !== d2 && void 0 !== d2 && $f();
        break;
      case 3:
        zh();
        E(Wf);
        E(H);
        Eh();
        break;
      case 5:
        Bh(d2);
        break;
      case 4:
        zh();
        break;
      case 13:
        E(L);
        break;
      case 19:
        E(L);
        break;
      case 10:
        ah(d2.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c2 = c2.return;
  }
  Q = a;
  Y = a = Pg(a.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
      c2.interleaved = null;
      var e2 = d2.next, f2 = c2.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e2;
        d2.next = g2;
      }
      c2.pending = d2;
    }
    fh = null;
  }
  return a;
}
function Mk(a, b2) {
  do {
    var c2 = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N = M = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        pk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$1(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a = mk.current;
  mk.current = Rh;
  return null === a ? Rh : a;
}
function tj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Jk();
  if (Q !== a || Z !== b2) uk = null, Kk(a, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a, e2);
    }
  while (1);
  $g();
  K = c2;
  mk.current = d2;
  if (null !== Y) throw Error(p$1(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y; ) Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); ) Uk(Y);
}
function Uk(a) {
  var b2 = Vk(a.alternate, a, fj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Sk(a) : Y = b2;
  nk.current = null;
}
function Sk(a) {
  var b2 = a;
  do {
    var c2 = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Pk(a, b2, c2) {
  var d2 = C, e2 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a, b2, c2, d2);
  } finally {
    ok.transition = e2, C = d2;
  }
  return null;
}
function Wk(a, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p$1(327));
  c2 = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c2) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c2 === a.current) throw Error(p$1(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a, f2);
  a === Q && (Y = Q = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    nk.current = null;
    Oj(a, c2);
    dk(c2, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c2;
    hk(c2);
    dc();
    K = h2;
    C = g2;
    ok.transition = f2;
  } else a.current = c2;
  vk && (vk = false, wk = a, xk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a, B());
  if (null !== b2) for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi) throw Oi = false, a = Pi, Pi = null, a;
  0 !== (xk & 1) && 0 !== a.tag && Hk();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a = Dc(xk), b2 = ok.transition, c2 = C;
    try {
      ok.transition = null;
      C = 16 > a ? 16 : a;
      if (null === wk) var d2 = false;
      else {
        a = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p$1(331));
        var e2 = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V = q2;
                  else for (; null !== V; ) {
                    m2 = V;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V = r2;
                      break;
                    }
                    V = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
          else b: for (; null !== V; ) {
            f2 = V;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V = x2;
              break b;
            }
            V = f2.return;
          }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
          else b: for (g2 = w2; null !== V; ) {
            h2 = V;
            if (0 !== (h2.flags & 2048)) try {
              switch (h2.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h2);
              }
            } catch (na) {
              W(h2, h2.return, na);
            }
            if (h2 === g2) {
              V = null;
              break b;
            }
            var F2 = h2.sibling;
            if (null !== F2) {
              F2.return = h2.return;
              V = F2;
              break b;
            }
            V = h2.return;
          }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a);
        } catch (na) {
        }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a, b2, 1);
  a = nh(a, b2, 1);
  b2 = R();
  null !== a && (Ac(a, 1, b2), Dk(a, b2));
}
function W(a, b2, c2) {
  if (3 === a.tag) Xk(a, a, c2);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Xk(b2, a, c2);
      break;
    } else if (1 === b2.tag) {
      var d2 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
        a = Ji(c2, a);
        a = Qi(b2, a, 1);
        b2 = nh(b2, a, 1);
        a = R();
        null !== b2 && (Ac(b2, 1, a), Dk(b2, a));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ti(a, b2, c2) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R();
  a.pingedLanes |= a.suspendedLanes & c2;
  Q === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c2);
  Dk(a, b2);
}
function Yk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R();
  a = ih(a, b2);
  null !== a && (Ac(a, b2, c2), Dk(a, c2));
}
function uj(a) {
  var b2 = a.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a, c2);
}
function bk(a, b2) {
  var c2 = 0;
  switch (a.tag) {
    case 13:
      var d2 = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a, c2);
}
var Vk;
Vk = function(a, b2, c2) {
  if (null !== a) if (a.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a, b2, c2);
    dh = 0 !== (a.flags & 131072) ? true : false;
  }
  else dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a, b2);
        a = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a = Ci(d2, a);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a), c2);
            break a;
        }
        throw Error(p$1(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a) throw Error(p$1(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
          e2 = Ji(Error(p$1(423)), b2);
          b2 = lj(a, b2, d2, c2, e2);
          break a;
        } else if (d2 !== e2) {
          e2 = Ji(Error(p$1(424)), b2);
          b2 = lj(a, b2, d2, c2, e2);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a, b2, c2);
            break a;
          }
          Xi(a, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a, b2), Xi(a, b2, g2, c2), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return oj(a, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Ug(b2, null, d2, c2) : Xi(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a, b2, d2, e2, c2);
    case 7:
      return Xi(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e2.children && !Wf.current) {
            b2 = Zi(a, b2, c2);
            break a;
          }
        } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
          var h2 = f2.dependencies;
          if (null !== h2) {
            g2 = f2.child;
            for (var k2 = h2.firstContext; null !== k2; ) {
              if (k2.context === d2) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c2 & -c2);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c2;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c2);
                bh(
                  f2.return,
                  c2,
                  b2
                );
                h2.lanes |= c2;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$1(341));
            g2.lanes |= c2;
            h2 = g2.alternate;
            null !== h2 && (h2.lanes |= c2);
            bh(g2, c2, b2);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a, b2, d2, e2, c2);
    case 15:
      return bj(a, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a, c2);
    case 19:
      return xj(a, b2, c2);
    case 22:
      return dj(a, b2, c2);
  }
  throw Error(p$1(156, b2.tag));
};
function Fk(a, b2) {
  return ac(a, b2);
}
function $k(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b2, c2, d2) {
  return new $k(a, b2, c2, d2);
}
function aj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function Zk(a) {
  if ("function" === typeof a) return aj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da) return 11;
    if (a === Ga) return 14;
  }
  return 2;
}
function Pg(a, b2) {
  var c2 = a.alternate;
  null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a.flags & 14680064;
  c2.childLanes = a.childLanes;
  c2.lanes = a.lanes;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
function Rg(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if ("function" === typeof a) aj(a) && (g2 = 1);
  else if ("string" === typeof a) g2 = 5;
  else a: switch (a) {
    case ya:
      return Tg(c2.children, e2, f2, b2);
    case za:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa:
      return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
    case Ea:
      return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
    case Fa:
      return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
    case Ia:
      return pj(c2, e2, f2, b2);
    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d2 = null;
          break a;
      }
      throw Error(p$1(130, null == a ? a : typeof a, ""));
  }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Tg(a, b2, c2, d2) {
  a = Bg(7, a, d2, b2);
  a.lanes = c2;
  return a;
}
function pj(a, b2, c2, d2) {
  a = Bg(22, a, d2, b2);
  a.elementType = Ia;
  a.lanes = c2;
  a.stateNode = { isHidden: false };
  return a;
}
function Qg(a, b2, c2) {
  a = Bg(6, a, null, b2);
  a.lanes = c2;
  return a;
}
function Sg(a, b2, c2) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function al(a, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = new al(a, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a;
}
function cl(a, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
}
function dl(a) {
  if (!a) return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag) throw Error(p$1(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a.tag) {
    var c2 = a.type;
    if (Zf(c2)) return bg(a, c2, b2);
  }
  return b2;
}
function el(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = bl(c2, d2, true, a, e2, f2, g2, h2, k2);
  a.context = dl(null);
  c2 = a.current;
  d2 = R();
  e2 = yi(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d2);
  Dk(a, d2);
  return a;
}
function fl(a, b2, c2, d2) {
  var e2 = b2.current, f2 = R(), g2 = yi(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a = nh(e2, b2, g2);
  null !== a && (gi(a, e2, g2, f2), oh(a, e2, g2));
  return g2;
}
function gl(a) {
  a = a.current;
  if (!a.child) return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function hl(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c2 = a.retryLane;
    a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a, b2) {
  hl(a, b2);
  (a = a.alternate) && hl(a, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ll(a) {
  this._internalRoot = a;
}
ml.prototype.render = ll.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$1(409));
  fl(a, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Rk(function() {
      fl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a) {
  this._internalRoot = a;
}
ml.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
    Qc.splice(c2, 0, a);
    0 === c2 && Vc(a);
  }
};
function nl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function pl() {
}
function ql(a, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a2 = gl(g2);
        f2.call(a2);
      };
    }
    var g2 = el(b2, d2, a, 0, null, false, false, "", pl);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk();
    return g2;
  }
  for (; e2 = a.lastChild; ) a.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a2 = gl(k2);
      h2.call(a2);
    };
  }
  var k2 = bl(a, 0, false, null, null, false, false, "", pl);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Rk(function() {
    fl(b2, k2, c2, d2);
  });
  return k2;
}
function rl(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = gl(g2);
        h2.call(a2);
      };
    }
    fl(b2, g2, a, e2);
  } else g2 = ql(c2, b2, a, e2, d2);
  return gl(g2);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a, 1);
        if (null !== b3) {
          var c3 = R();
          gi(b3, a, 1, c3);
        }
      }), il(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b2 = ih(a, 134217728);
    if (null !== b2) {
      var c2 = R();
      gi(b2, a, 134217728, c2);
    }
    il(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b2 = yi(a), c2 = ih(a, b2);
    if (null !== c2) {
      var d2 = R();
      gi(c2, a, b2, d2);
    }
    il(a, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b2) {
  var c2 = C;
  try {
    return C = a, b2();
  } finally {
    C = c2;
  }
};
yb = function(a, b2, c2) {
  switch (b2) {
    case "input":
      bb(a, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a; c2.parentNode; ) c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2) throw Error(p$1(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2)) throw Error(p$1(200));
  return cl(a, b2, null, c2);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!nl(a)) throw Error(p$1(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a, 1, false, null, null, c2, false, d2, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render) throw Error(p$1(188));
    a = Object.keys(a).join(",");
    throw Error(p$1(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Rk(a);
};
reactDom_production_min.hydrate = function(a, b2, c2) {
  if (!ol(b2)) throw Error(p$1(200));
  return rl(null, a, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a, b2, c2) {
  if (!nl(a)) throw Error(p$1(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a[uf] = b2.current;
  sf(a);
  if (d2) for (a = 0; a < d2.length; a++) c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
    c2,
    e2
  );
  return new ml(b2);
};
reactDom_production_min.render = function(a, b2, c2) {
  if (!ol(b2)) throw Error(p$1(200));
  return rl(null, a, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!ol(a)) throw Error(p$1(40));
  return a._reactRootContainer ? (Rk(function() {
    rl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
  if (!ol(c2)) throw Error(p$1(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p$1(38));
  return rl(a, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var createRoot;
var m$1 = reactDomExports;
{
  createRoot = m$1.createRoot;
  m$1.hydrateRoot;
}
/**
 * @remix-run/router v1.20.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant$1(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$2({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#") pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation2, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends$2({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    href = href.replace(/ $/, "%20");
    invariant$1(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation2(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches2 = null;
  for (let i = 0; matches2 == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches2 = matchRouteBranch(branches[i], decoded, allowPartial);
  }
  return matches2;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$1(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$1(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first2, ...rest] = segments;
  let isOptional = first2.endsWith("?");
  let required = first2.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b2) => a.score !== b2.score ? b2.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b2) {
  let siblings = a.length === b2.length && a.slice(0, -1).every((n2, i) => n2 === b2[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches2 = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    let route = meta.route;
    if (!match2 && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match2 = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end: false
      }, remainingPathname);
    }
    if (!match2) {
      return null;
    }
    Object.assign(matchedParams, match2.params);
    matches2.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches2;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2) return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = compiledParams.reduce((memo2, _ref, index) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index];
    if (isOptional && !value) {
      memo2[paramName] = void 0;
    } else {
      memo2[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$1(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches2 = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches2 && matches2.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$1({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches2, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches2 == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches2 = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches2 = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches2;
  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant$1(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match2 = renderedMatches[i];
      if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match2.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match2.route.loader && loaderData[match2.route.id] === void 0 && (!errors2 || errors2[match2.route.id] === void 0);
        if (match2.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match2, index) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match2.route.id ? errors[match2.route.id] : void 0;
      errorElement = match2.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches22 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches22,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches22,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant$1(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant$1(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant$1(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function Route(_props) {
  invariant$1(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant$1(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$1({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant$1(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant$1(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e2) {
}
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future
  });
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
var dataAttr$1 = (guard) => guard ? "" : void 0;
var MAX_Z_INDEX = 2147483647;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isObject$4 = (v2) => typeof v2 === "object" && v2 !== null;
var isHTMLElement$1 = (el2) => isObject$4(el2) && el2.nodeType === ELEMENT_NODE && typeof el2.nodeName === "string";
var isDocument = (el2) => isObject$4(el2) && el2.nodeType === DOCUMENT_NODE;
var isWindow = (el2) => isObject$4(el2) && el2 === el2.window;
var getNodeName$1 = (node2) => {
  if (isHTMLElement$1(node2)) return node2.localName || "";
  return "#document";
};
function isRootElement(node2) {
  return ["html", "body", "#document"].includes(getNodeName$1(node2));
}
var isNode$1 = (el2) => isObject$4(el2) && el2.nodeType !== void 0;
var isShadowRoot$1 = (el2) => isNode$1(el2) && el2.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el2;
function contains(parent, child) {
  if (!parent || !child) return false;
  if (!isHTMLElement$1(parent) || !isHTMLElement$1(child)) return false;
  return parent === child || parent.contains(child);
}
function getDocument(el2) {
  if (isDocument(el2)) return el2;
  if (isWindow(el2)) return el2.document;
  return (el2 == null ? void 0 : el2.ownerDocument) ?? document;
}
function getDocumentElement$1(el2) {
  return getDocument(el2).documentElement;
}
function getWindow$2(el2) {
  var _a2;
  if (isShadowRoot$1(el2)) return getWindow$2(el2.host);
  if (isDocument(el2)) return el2.defaultView ?? window;
  if (isHTMLElement$1(el2)) return ((_a2 = el2.ownerDocument) == null ? void 0 : _a2.defaultView) ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement == null ? void 0 : activeElement.shadowRoot) {
    const el2 = activeElement.shadowRoot.activeElement;
    if (el2 === activeElement) break;
    else activeElement = el2;
  }
  return activeElement;
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt = (v2) => isDom() && v2.test(getPlatform());
var vn = (v2) => isDom() && v2.test(navigator.vendor);
var isMac = () => pt(/^Mac/);
var isSafari = () => isApple() && vn(/apple/i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => pt(/iP(hone|ad|od)|iOS/);
function getComposedPath(event) {
  var _a2, _b2, _c2;
  return ((_a2 = event.composedPath) == null ? void 0 : _a2.call(event)) ?? ((_c2 = (_b2 = event.nativeEvent) == null ? void 0 : _b2.composedPath) == null ? void 0 : _c2.call(_b2));
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return (composedPath == null ? void 0 : composedPath[0]) ?? event.target;
}
function isComposingEvent(event) {
  var _a2;
  return ((_a2 = event.nativeEvent) == null ? void 0 : _a2.isComposing) ?? event.isComposing;
}
var defaultItemToId = (v2) => v2.id;
function itemById(v2, id2, itemToId = defaultItemToId) {
  return v2.find((item2) => itemToId(item2) === id2);
}
function indexOfId(v2, id2, itemToId = defaultItemToId) {
  const item2 = itemById(v2, id2, itemToId);
  return item2 ? v2.indexOf(item2) : -1;
}
function nextById(v2, id2, loop = true) {
  let idx = indexOfId(v2, id2);
  idx = loop ? (idx + 1) % v2.length : Math.min(idx + 1, v2.length - 1);
  return v2[idx];
}
function prevById(v2, id2, loop = true) {
  let idx = indexOfId(v2, id2);
  if (idx === -1) return loop ? v2[v2.length - 1] : null;
  idx = loop ? (idx - 1 + v2.length) % v2.length : Math.max(0, idx - 1);
  return v2[idx];
}
var sanitize = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (item2) => {
  var _a2;
  return sanitize(((_a2 = item2.dataset) == null ? void 0 : _a2.valuetext) ?? item2.textContent ?? "");
};
var match$1 = (valueText, query2) => valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
var wrap$2 = (v2, idx) => {
  return v2.map((_, index) => v2[(Math.max(idx, 0) + index) % v2.length]);
};
function getByText(v2, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v2, currentId, itemToId) : -1;
  let items2 = currentId ? wrap$2(v2, index) : v2;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items2 = items2.filter((item2) => itemToId(item2) !== currentId);
  }
  return items2.find((item2) => match$1(getValueText(item2), text));
}
function getByTypeaheadImpl(_items, options) {
  const { state, activeId, key, timeout = 350, itemToId } = options;
  const search = state.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items2 = _items.slice();
  const next2 = getByText(items2, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state.timer);
    state.timer = -1;
  }
  function update(value) {
    state.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next2;
}
var getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle$2(el2) {
  if (!styleCache.has(el2)) {
    styleCache.set(el2, getWindow$2(el2).getComputedStyle(el2));
  }
  return styleCache.get(el2);
}
function getParentNode$1(node2) {
  if (getNodeName$1(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot$1(node2) && node2.host || // Fallback.
    getDocumentElement$1(node2)
  );
  return isShadowRoot$1(result) ? result.host : result;
}
var isHTMLElement2 = (element) => typeof element === "object" && element !== null && element.nodeType === 1;
var isFrame = (element) => isHTMLElement2(element) && element.tagName === "IFRAME";
function isVisible(el2) {
  if (!isHTMLElement2(el2)) return false;
  return el2.offsetWidth > 0 || el2.offsetHeight > 0 || el2.getClientRects().length > 0;
}
function hasNegativeTabIndex(element) {
  const tabIndex = parseInt(element.getAttribute("tabindex") || "0", 10);
  return tabIndex < 0;
}
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements2 = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements2.length === 0;
  if (include && isHTMLElement2(container) && isFocusable$1(container)) {
    elements2.unshift(container);
  }
  const focusableElements = elements2.filter(isFocusable$1);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable$1(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements2 = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements2.filter(isTabbable$1);
  if (includeContainer && isTabbable$1(container)) {
    tabbableElements.unshift(container);
  }
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) {
    return elements2;
  }
  return tabbableElements;
}
function isTabbable$1(el2) {
  if (el2 != null && el2.tabIndex > 0) return true;
  return isFocusable$1(el2) && !hasNegativeTabIndex(el2);
}
function getTabbableEdges(container, includeContainer) {
  const elements2 = getTabbables(container, includeContainer);
  const first2 = elements2[0] || null;
  const last2 = elements2[elements2.length - 1] || null;
  return [first2, last2];
}
function getNextTabbable(container, current) {
  const tabbables = getTabbables(container);
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const currentElement = current ?? doc.activeElement;
  if (!currentElement) return null;
  const index = tabbables.indexOf(currentElement);
  return tabbables[index + 1] || null;
}
function getInitialFocus(options) {
  const { root: root2, getInitialEl, filter, enabled = true } = options;
  if (!enabled) return;
  let node2 = null;
  node2 || (node2 = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node2 || (node2 = root2 == null ? void 0 : root2.querySelector("[data-autofocus],[autofocus]"));
  if (!node2) {
    const tabbables = getTabbables(root2);
    node2 = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node2 || root2 || void 0;
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement$1(el2) {
  const win = getWindow$2(el2);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el2);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function nextTick(fn) {
  const set2 = /* @__PURE__ */ new Set();
  function raf2(fn2) {
    const id2 = globalThis.requestAnimationFrame(fn2);
    set2.add(() => globalThis.cancelAnimationFrame(id2));
  }
  raf2(() => raf2(fn));
  return function cleanup() {
    set2.forEach((fn2) => fn2());
  };
}
function raf$1(fn) {
  const id2 = globalThis.requestAnimationFrame(fn);
  return () => {
    globalThis.cancelAnimationFrame(id2);
  };
}
function getNearestOverflowAncestor$1(el2) {
  const parentNode = getParentNode$1(el2);
  if (isRootElement(parentNode)) {
    return getDocument(parentNode).body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement$1(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor$1(parentNode);
}
function getOverflowAncestors$1(el2, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor$1(el2);
  const isBody = scrollableAncestor === el2.ownerDocument.body;
  const win = getWindow$2(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement$1(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors$1(scrollableAncestor, []));
}
function proxyTabFocusImpl(container, options = {}) {
  const { triggerElement, onFocus } = options;
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const body = doc.body;
  function onKeyDown(event) {
    if (event.key !== "Tab") return;
    let elementToFocus = null;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
    const noTabbableElements = !firstTabbable && !lastTabbable;
    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
      elementToFocus = triggerElement;
    } else if (!event.shiftKey && doc.activeElement === triggerElement) {
      elementToFocus = firstTabbable;
    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
      elementToFocus = getNextTabbable(body, triggerElement);
    }
    if (!elementToFocus) return;
    event.preventDefault();
    if (typeof onFocus === "function") {
      onFocus(elementToFocus);
    } else {
      elementToFocus.focus();
    }
  }
  doc == null ? void 0 : doc.addEventListener("keydown", onKeyDown, true);
  return () => {
    doc == null ? void 0 : doc.removeEventListener("keydown", onKeyDown, true);
  };
}
function proxyTabFocus(container, options) {
  const { defer, triggerElement, ...restOptions } = options;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof container === "function" ? container() : container;
      const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
      cleanups2.push(proxyTabFocusImpl(node2, { triggerElement: trigger, ...restOptions }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function queryAll(root2, selector) {
  return Array.from((root2 == null ? void 0 : root2.querySelectorAll(selector)) ?? []);
}
function query(root2, selector) {
  return (root2 == null ? void 0 : root2.querySelector(selector)) ?? null;
}
function createScope(methods) {
  const dom2 = {
    getRootNode: (ctx) => {
      var _a2;
      return ((_a2 = ctx.getRootNode) == null ? void 0 : _a2.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(dom2.getRootNode(ctx)),
    getWin: (ctx) => dom2.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => getActiveElement(dom2.getRootNode(ctx)),
    isActiveElement: (ctx, elem) => elem === dom2.getActiveElement(ctx),
    getById: (ctx, id2) => dom2.getRootNode(ctx).getElementById(id2),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString) return;
      elem.value = value.toString();
    }
  };
  return { ...dom2, ...methods };
}
var cleanups = /* @__PURE__ */ new WeakMap();
function set$1(element, key, setup) {
  if (!cleanups.has(element)) {
    cleanups.set(element, /* @__PURE__ */ new Map());
  }
  const elementCleanups = cleanups.get(element);
  const prevCleanup = elementCleanups.get(key);
  if (!prevCleanup) {
    elementCleanups.set(key, setup());
    return () => {
      var _a2;
      (_a2 = elementCleanups.get(key)) == null ? void 0 : _a2();
      elementCleanups.delete(key);
    };
  }
  const cleanup = setup();
  const nextCleanup = () => {
    cleanup();
    prevCleanup();
    elementCleanups.delete(key);
  };
  elementCleanups.set(key, nextCleanup);
  return () => {
    const isCurrent = elementCleanups.get(key) === nextCleanup;
    if (!isCurrent) return;
    cleanup();
    elementCleanups.set(key, prevCleanup);
  };
}
function setStyle(element, style) {
  if (!element) return () => {
  };
  const setup = () => {
    const prevStyle = element.style.cssText;
    Object.assign(element.style, style);
    return () => {
      element.style.cssText = prevStyle;
    };
  };
  return set$1(element, "style", setup);
}
var fps = 1e3 / 60;
function waitForElement(query2, cb2) {
  const el2 = query2();
  if (isHTMLElement$1(el2) && el2.isConnected) {
    cb2(el2);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el22 = query2();
      if (isHTMLElement$1(el22) && el22.isConnected) {
        cb2(el22);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb2) {
  const cleanups2 = [];
  queries == null ? void 0 : queries.forEach((query2) => {
    const clean = waitForElement(query2, cb2);
    cleanups2.push(clean);
  });
  return () => {
    cleanups2.forEach((fn) => fn());
  };
}
function getErrorMessage$1(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext$1(options = {}) {
  const {
    name,
    strict: strict2 = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = reactExports.createContext(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a2;
    const context = reactExports.useContext(Context);
    if (!context && strict2) {
      const error = new Error(errorMessage ?? getErrorMessage$1(hookName, providerName));
      error.name = "ContextError";
      (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}
const [LocaleContextProvider, useLocaleContext] = createContext$1({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});
const cx = (...classNames) => classNames.filter(Boolean).map((r2) => r2.trim()).join(" ");
function memoize(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid$1 = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var isDevelopment$1 = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment$1 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type, props, children, length2) {
  return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i = 0, j = 0, k2 = 0; i < index; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root2, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$2(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$2(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize$2(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize$2([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize$2([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize$2([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize$2(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A(a) {
  return z(a) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a) {
  return A(a) || z(a) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a) {
  return z(a) === k;
};
reactIs_production_min.isContextProvider = function(a) {
  return z(a) === h;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a) {
  return z(a) === n;
};
reactIs_production_min.isFragment = function(a) {
  return z(a) === e;
};
reactIs_production_min.isLazy = function(a) {
  return z(a) === t;
};
reactIs_production_min.isMemo = function(a) {
  return z(a) === r;
};
reactIs_production_min.isPortal = function(a) {
  return z(a) === d;
};
reactIs_production_min.isProfiler = function(a) {
  return z(a) === g;
};
reactIs_production_min.isStrictMode = function(a) {
  return z(a) === f;
};
reactIs_production_min.isSuspense = function(a) {
  return z(a) === p;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
reactIs_production_min.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var isDevelopment = false;
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor$1 = {
            name: p1,
            styles: p2,
            next: cursor$1
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor$1 = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor$1
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor$1 = {
              name: next2.name,
              styles: next2.styles,
              next: cursor$1
            };
            next2 = next2.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor$1;
        var result = interpolation(mergedProps);
        cursor$1 = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue(value[_i2])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor$1;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor$1 = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor$1
  };
}
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref2) {
    var cache2 = reactExports.useContext(EmotionCacheContext);
    return func(props, cache2, ref2);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles = props.styles;
  var serialized = serializeStyles([styles], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function callAll$1(...fns) {
  return function mergedFn(...args) {
    fns.forEach((fn) => fn == null ? void 0 : fn(...args));
  };
}
const clsx$1 = (...args) => args.map((str) => {
  var _a2;
  return (_a2 = str == null ? void 0 : str.trim) == null ? void 0 : _a2.call(str);
}).filter(Boolean).join(" ");
const eventRegex = /^on[A-Z]/;
function mergeProps$1(...args) {
  let result = {};
  for (let props of args) {
    for (let key in result) {
      if (eventRegex.test(key) && typeof result[key] === "function" && typeof props[key] === "function") {
        result[key] = callAll$1(result[key], props[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx$1(result[key], props[key]);
        continue;
      }
      if (key === "style") {
        result[key] = Object.assign({}, result[key] ?? {}, props[key] ?? {});
        continue;
      }
      result[key] = props[key] !== void 0 ? props[key] : result[key];
    }
    for (let key in props) {
      if (result[key] === void 0) {
        result[key] = props[key];
      }
    }
  }
  return result;
}
function assignRef(ref2, value) {
  if (ref2 == null) return;
  if (typeof ref2 === "function") {
    ref2(value);
    return;
  }
  try {
    ref2.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref2}'`);
  }
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref2) => {
      assignRef(ref2, node2);
    });
  };
}
function compact$2(object) {
  const clone = Object.assign({}, object);
  for (let key in clone) {
    if (clone[key] === void 0) delete clone[key];
  }
  return clone;
}
function interopDefault(mod2) {
  return mod2.default || mod2;
}
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict: strict2 = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = reactExports.createContext(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a2;
    const context = reactExports.useContext(Context);
    if (!context && strict2) {
      const error = new Error(
        errorMessage ?? getErrorMessage(hookName, providerName)
      );
      error.name = "ContextError";
      (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}
const [ChakraContextProvider, useChakraContext] = createContext({
  name: "ChakraContext",
  strict: true,
  providerName: "<ChakraProvider />"
});
function ChakraProvider(props) {
  const { value: sys, children } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChakraContextProvider, { value: sys, children: [
    !sys._config.disableLayers && /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: sys.layers.atRule }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Global,
      {
        styles: [sys.getPreflightCss(), sys.getGlobalCss(), sys.getTokenCss()]
      }
    ),
    children
  ] });
}
const splitProps = (props, keys) => {
  const descriptors = Object.getOwnPropertyDescriptors(props);
  const dKeys = Object.keys(descriptors);
  const split = (k2) => {
    const clone = {};
    for (let i = 0; i < k2.length; i++) {
      const key = k2[i];
      if (descriptors[key]) {
        Object.defineProperty(clone, key, descriptors[key]);
        delete descriptors[key];
      }
    }
    return clone;
  };
  const fn = (key) => split(Array.isArray(key) ? key : dKeys.filter(key));
  return [keys].map(fn).concat(split(dKeys));
};
function useResolvedProps(inProps, cvaRecipe, shouldForwardProps) {
  const { css: css2, isValidProperty } = useChakraContext();
  const { children, ...props } = inProps;
  const result = reactExports.useMemo(() => {
    const [htmlProps, restProps_A] = splitProps(props, [
      "htmlWidth",
      "htmlHeight",
      "htmlSize",
      "htmlTranslate"
    ]);
    const [forwardedProps, restProps_B] = splitProps(
      restProps_A,
      (key) => shouldForwardProps(key, cvaRecipe.variantKeys)
    );
    const [variantProps, restProps_C] = splitProps(
      restProps_B,
      cvaRecipe.variantKeys
    );
    const [styleProps, elementProps] = splitProps(restProps_C, isValidProperty);
    return {
      htmlProps: getHtmlProps(htmlProps),
      forwardedProps,
      variantProps,
      styleProps,
      elementProps
    };
  }, [cvaRecipe.variantKeys, shouldForwardProps, props, isValidProperty]);
  const { css: cssStyles, ...propStyles } = result.styleProps;
  const cvaStyles = reactExports.useMemo(
    () => cvaRecipe(result.variantProps),
    [cvaRecipe, result.variantProps]
  );
  const styles = reactExports.useMemo(() => {
    return css2(cvaStyles, ...toArray$1(cssStyles), propStyles);
  }, [css2, cvaStyles, cssStyles, propStyles]);
  return {
    styles,
    props: {
      ...result.forwardedProps,
      ...result.elementProps,
      ...result.htmlProps,
      children
    }
  };
}
const getHtmlProps = (props) => {
  const htmlProps = {};
  for (const key in props) {
    if (key.startsWith("html")) {
      htmlProps[key.replace("html", "").toLowerCase()] = props[key];
    }
  }
  return htmlProps;
};
const toArray$1 = (val) => {
  const res = Array.isArray(val) ? val : [val];
  return res.filter(Boolean).flat();
};
const isPropValid = interopDefault(isPropValid$1);
const testOmitPropsOnStringTag = isPropValid;
const testOmitPropsOnComponent = (key) => key !== "theme";
const composeShouldForwardProps = (tag, options, isReal) => {
  let shouldForwardProp;
  if (options) {
    const optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? (propName) => tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName) : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
let isBrowser = typeof document !== "undefined";
const Insertion = ({ cache: cache2, serialized, isStringTag }) => {
  registerStyles(cache2, serialized, isStringTag);
  const rules = useInsertionEffectAlwaysWithSyncFallback(
    () => insertStyles(cache2, serialized, isStringTag)
  );
  if (!isBrowser && rules !== void 0) {
    let serializedNames = serialized.name;
    let next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames = cx(serializedNames, next2.name);
      next2 = next2.next;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "style",
      {
        ...{
          [`data-emotion`]: cx(cache2.key, serializedNames),
          dangerouslySetInnerHTML: { __html: rules },
          nonce: cache2.sheet.nonce
        }
      }
    );
  }
  return null;
};
const createStyled = (tag, configOrCva = {}, options = {}) => {
  const isReal = tag.__emotion_real === tag;
  const baseTag = isReal && tag.__emotion_base || tag;
  let identifierName;
  let targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  let styles = [];
  const Styled = withEmotionCache((inProps, cache2, ref2) => {
    var _a2;
    const { cva, isValidProperty } = useChakraContext();
    const cvaFn = configOrCva.__cva__ ? configOrCva : cva(configOrCva);
    const cvaRecipe = mergeCva$1(tag.__emotion_cva, cvaFn);
    const createShouldForwardProps = (props2) => {
      return (prop, variantKeys) => {
        if (props2.includes(prop)) return true;
        return !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      };
    };
    if (!options.shouldForwardProp && options.forwardProps) {
      options.shouldForwardProp = createShouldForwardProps(options.forwardProps);
    }
    const fallbackShouldForwardProp = (prop, variantKeys) => {
      const emotionSfp = typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
      const chakraSfp = !(variantKeys == null ? void 0 : variantKeys.includes(prop)) && !isValidProperty(prop);
      return emotionSfp(prop) && chakraSfp;
    };
    const shouldForwardProp = composeShouldForwardProps(tag, options, isReal) || fallbackShouldForwardProp;
    const propsWithDefault = reactExports.useMemo(
      () => Object.assign({}, options.defaultProps, compact$2(inProps)),
      [inProps]
    );
    const { props, styles: styleProps } = useResolvedProps(
      propsWithDefault,
      cvaRecipe,
      shouldForwardProp
    );
    let className = "";
    let classInterpolations = [styleProps];
    let mergedProps = props;
    if (props.theme == null) {
      mergedProps = {};
      for (let key in props) {
        mergedProps[key] = props[key];
      }
      mergedProps.theme = reactExports.useContext(ThemeContext);
    }
    if (typeof props.className === "string") {
      className = getRegisteredStyles(
        cache2.registered,
        classInterpolations,
        props.className
      );
    } else if (props.className != null) {
      className = cx(className, props.className);
    }
    const serialized = serializeStyles(
      styles.concat(classInterpolations),
      cache2.registered,
      mergedProps
    );
    className = cx(className, `${cache2.key}-${serialized.name}`);
    if (targetClassName !== void 0) {
      className = cx(className, targetClassName);
    }
    const shouldUseAs = !shouldForwardProp("as");
    let FinalTag = shouldUseAs && props.as || baseTag;
    let newProps = {};
    for (let prop in props) {
      if (shouldUseAs && prop === "as") continue;
      if (shouldForwardProp(prop)) {
        newProps[prop] = props[prop];
      }
    }
    newProps.className = className.trim();
    newProps.ref = ref2;
    const forwardAsChild = options.forwardAsChild || ((_a2 = options.forwardProps) == null ? void 0 : _a2.includes("asChild"));
    if (props.asChild && !forwardAsChild) {
      const child = reactExports.Children.only(props.children);
      FinalTag = child.type;
      newProps.children = null;
      newProps = mergeProps$1(newProps, child.props);
      newProps.ref = mergeRefs(ref2, child.ref);
    }
    if (newProps.as && forwardAsChild) {
      newProps.as = void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Insertion,
          {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FinalTag, { asChild: true, ...newProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(props.as, { children: newProps.children }) })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Insertion,
        {
          cache: cache2,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FinalTag, { ...newProps })
    ] });
  });
  Styled.displayName = identifierName !== void 0 ? identifierName : `Styled(${typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component"})`;
  Styled.__emotion_real = Styled;
  Styled.__emotion_base = baseTag;
  Styled.__emotion_forwardProp = options.shouldForwardProp;
  Styled.__emotion_cva = configOrCva;
  Object.defineProperty(Styled, "toString", {
    value() {
      if (targetClassName === void 0 && false) {
        return "NO_COMPONENT_SELECTOR";
      }
      return `.${targetClassName}`;
    }
  });
  return Styled;
};
const styledFn = createStyled.bind();
const cache = /* @__PURE__ */ new Map();
const chakraImpl = new Proxy(styledFn, {
  apply(_, __, args) {
    return styledFn(...args);
  },
  get(_, el2) {
    if (!cache.has(el2)) {
      cache.set(el2, styledFn(el2));
    }
    return cache.get(el2);
  }
});
const chakra = chakraImpl;
const mergeCva$1 = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  return cvaA.merge(cvaB);
};
const colorMix = (value, token2) => {
  var _a2;
  if (!value || typeof value !== "string") {
    return { invalid: true, value };
  }
  const [rawColor, rawOpacity] = value.split("/");
  if (!rawColor || !rawOpacity || rawColor === "currentBg") {
    return { invalid: true, value: rawColor };
  }
  const colorToken = token2(`colors.${rawColor}`);
  const opacityToken = (_a2 = token2.raw(`opacity.${rawOpacity}`)) == null ? void 0 : _a2.value;
  if (!opacityToken && isNaN(Number(rawOpacity))) {
    return { invalid: true, value: rawColor };
  }
  const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
  const color = colorToken ?? rawColor;
  return {
    invalid: false,
    color,
    value: `color-mix(in srgb, ${color} ${percent}, transparent)`
  };
};
const createColorMixTransform = (prop) => (value, args) => {
  const mix = args.utils.colorMix(value);
  if (mix.invalid) return { [prop]: value };
  const cssVar2 = "--mix-" + prop;
  return {
    [cssVar2]: mix.value,
    [prop]: `var(${cssVar2}, ${mix.color})`
  };
};
function isObject$3(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function") && !Array.isArray(value);
}
function isString$1(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
function isFunction$1(value) {
  return typeof value === "function";
}
function merge(target, source) {
  if (source == null) return target;
  for (const key of Object.keys(source)) {
    if (source[key] === void 0 || key === "__proto__") continue;
    if (!isObject$3(target[key]) && isObject$3(source[key])) {
      Object.assign(target, { [key]: source[key] });
    } else if (target[key] && isObject$3(source[key])) {
      merge(target[key], source[key]);
    } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
      let i = 0;
      for (; i < source[key].length; i++) {
        if (isObject$3(target[key][i]) && isObject$3(source[key][i])) {
          merge(target[key][i], source[key][i]);
        } else {
          target[key][i] = source[key][i];
        }
      }
    } else {
      Object.assign(target, { [key]: source[key] });
    }
  }
  return target;
}
function mergeWith(target, ...sources) {
  for (const source of sources) {
    merge(target, source);
  }
  return target;
}
const defineConditions = (v2) => v2;
const defineRecipe = (v2) => v2;
const defineSlotRecipe = (v2) => v2;
const defineKeyframes = (v2) => v2;
const defineGlobalStyles = (v2) => v2;
const defineStyle = (v2) => v2;
const defineTextStyles = (v2) => v2;
const defineAnimationStyles = (v2) => v2;
const defineLayerStyles = (v2) => v2;
function createProxy$2() {
  const identity = (v2) => v2;
  return new Proxy(identity, {
    get() {
      return identity;
    }
  });
}
const defineTokens = /* @__PURE__ */ createProxy$2();
const defineSemanticTokens = /* @__PURE__ */ createProxy$2();
const defineConfig = (v2) => v2;
const mergeConfigs = (...configs) => {
  return mergeWith({}, ...configs);
};
const escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc$1(string) {
  return `${string}`.replace(escRegex, (s) => `\\${s}`);
}
const dashCaseRegex = /[A-Z]/g;
function dashCase(string) {
  return string.replace(dashCaseRegex, (match2) => `-${match2.toLowerCase()}`);
}
function cssVar(name, options = {}) {
  const { fallback: fallback2 = "", prefix: prefix2 = "" } = options;
  const variable = dashCase(["-", prefix2, esc$1(name)].filter(Boolean).join("-"));
  return {
    var: variable,
    ref: `var(${variable}${fallback2 ? `, ${fallback2}` : ""})`
  };
}
const isCssVar = (v2) => /^var\(--.+\)$/.test(v2);
const wrap$1 = (str, v2) => v2 != null ? `${str}(${v2})` : v2;
const deg = (v2) => {
  if (isCssVar(v2) || v2 == null) return v2;
  const unitless = typeof v2 === "string" && !v2.endsWith("deg");
  return typeof v2 === "number" || unitless ? `${v2}deg` : v2;
};
const createFocusRing = (selector) => {
  return {
    values: ["outside", "inside", "mixed", "none"],
    transform(value, { token: token2 }) {
      const focusRingColor = token2("colors.colorPalette.focusRing");
      const styles = {
        inside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineOffset: "0px",
            outlineWidth: "var(--focus-ring-width, 1px)",
            outlineColor: "var(--focus-ring-color)",
            outlineStyle: "var(--focus-ring-style, solid)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        outside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 2px)",
            outlineOffset: "2px",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "var(--focus-ring-color)"
          }
        },
        mixed: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 3px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        none: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outline: "none"
          }
        }
      };
      return styles[value] ?? {};
    }
  };
};
const divideColor = createColorMixTransform("borderColor");
const createTransition = (value) => {
  return {
    transition: value,
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "150ms"
  };
};
const defaultConditions = defineConditions({
  hover: [
    "@media (hover: hover)",
    "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
  ],
  active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
  focus: "&:is(:focus, [data-focus])",
  focusWithin: "&:is(:focus-within, [data-focus-within])",
  focusVisible: "&:is(:focus-visible, [data-focus-visible])",
  disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
  visited: "&:visited",
  target: "&:target",
  readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
  readWrite: "&:read-write",
  empty: "&:is(:empty, [data-empty])",
  checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
  enabled: "&:enabled",
  expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
  highlighted: "&[data-highlighted]",
  complete: "&[data-complete]",
  incomplete: "&[data-incomplete]",
  dragging: "&[data-dragging]",
  before: "&::before",
  after: "&::after",
  firstLetter: "&::first-letter",
  firstLine: "&::first-line",
  marker: "&::marker",
  selection: "&::selection",
  file: "&::file-selector-button",
  backdrop: "&::backdrop",
  first: "&:first-of-type",
  last: "&:last-of-type",
  notFirst: "&:not(:first-of-type)",
  notLast: "&:not(:last-of-type)",
  only: "&:only-child",
  even: "&:nth-of-type(even)",
  odd: "&:nth-of-type(odd)",
  peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
  peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
  peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
  peerFocusWithin: ".peer:focus-within ~ &",
  peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
  peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
  peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
  peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
  peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
  peerPlaceholderShown: ".peer:placeholder-shown ~ &",
  groupFocus: ".group:is(:focus, [data-focus]) &",
  groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
  groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
  groupFocusWithin: ".group:focus-within &",
  groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
  groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
  groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
  groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
  groupInvalid: ".group:invalid &",
  indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
  required: "&:is([data-required], [aria-required=true])",
  valid: "&:is([data-valid], [data-state=valid])",
  invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
  autofill: "&:autofill",
  inRange: "&:is(:in-range, [data-in-range])",
  outOfRange: "&:is(:out-of-range, [data-outside-range])",
  placeholder: "&::placeholder, &[data-placeholder]",
  placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
  pressed: "&:is([aria-pressed=true], [data-pressed])",
  selected: "&:is([aria-selected=true], [data-selected])",
  grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
  underValue: "&[data-state=under-value]",
  overValue: "&[data-state=over-value]",
  atValue: "&[data-state=at-value]",
  default: "&:default",
  optional: "&:optional",
  open: "&:is([open], [data-open], [data-state=open])",
  closed: "&:is([closed], [data-closed], [data-state=closed])",
  fullscreen: "&is(:fullscreen, [data-fullscreen])",
  loading: "&:is([data-loading], [aria-busy=true])",
  hidden: "&:is([hidden], [data-hidden])",
  current: "&[data-current]",
  currentPage: "&[aria-current=page]",
  currentStep: "&[aria-current=step]",
  today: "&[data-today]",
  unavailable: "&[data-unavailable]",
  rangeStart: "&[data-range-start]",
  rangeEnd: "&[data-range-end]",
  now: "&[data-now]",
  topmost: "&[data-topmost]",
  motionReduce: "@media (prefers-reduced-motion: reduce)",
  motionSafe: "@media (prefers-reduced-motion: no-preference)",
  print: "@media print",
  landscape: "@media (orientation: landscape)",
  portrait: "@media (orientation: portrait)",
  dark: ".dark &, .dark .chakra-theme:not(.light) &",
  light: ":root &, .light &",
  osDark: "@media (prefers-color-scheme: dark)",
  osLight: "@media (prefers-color-scheme: light)",
  highContrast: "@media (forced-colors: active)",
  lessContrast: "@media (prefers-contrast: less)",
  moreContrast: "@media (prefers-contrast: more)",
  ltr: "[dir=ltr] &",
  rtl: "[dir=rtl] &",
  scrollbar: "&::-webkit-scrollbar",
  scrollbarThumb: "&::-webkit-scrollbar-thumb",
  scrollbarTrack: "&::-webkit-scrollbar-track",
  horizontal: "&[data-orientation=horizontal]",
  vertical: "&[data-orientation=vertical]",
  icon: "& :where(svg)",
  starting: "@starting-style"
});
const currentBgVar = cssVar("bg-currentcolor");
const isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
const colorValues = (theme) => ({
  ...theme("colors"),
  currentBg: currentBgVar
});
const defaultBaseConfig = defineConfig({
  conditions: defaultConditions,
  utilities: {
    // background
    background: {
      values: colorValues,
      shorthand: ["bg"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
        const styleObj = createColorMixTransform("background")(value, args);
        return { ...styleObj, [currentBgVar.var]: styleObj == null ? void 0 : styleObj.background };
      }
    },
    backgroundColor: {
      values: colorValues,
      shorthand: ["bgColor"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw))
          return { backgroundColor: currentBgVar.ref };
        const styleObj = createColorMixTransform("backgroundColor")(value, args);
        return {
          ...styleObj,
          [currentBgVar.var]: styleObj == null ? void 0 : styleObj.backgroundColor
        };
      }
    },
    backgroundSize: { shorthand: ["bgSize"] },
    backgroundPosition: { shorthand: ["bgPos"] },
    backgroundRepeat: { shorthand: ["bgRepeat"] },
    backgroundAttachment: { shorthand: ["bgAttachment"] },
    backgroundClip: {
      shorthand: ["bgClip"],
      values: ["text"],
      transform(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      }
    },
    backgroundGradient: {
      shorthand: ["bgGradient"],
      values(theme) {
        return {
          ...theme("gradients"),
          "to-t": "linear-gradient(to top, var(--gradient))",
          "to-tr": "linear-gradient(to top right, var(--gradient))",
          "to-r": "linear-gradient(to right, var(--gradient))",
          "to-br": "linear-gradient(to bottom right, var(--gradient))",
          "to-b": "linear-gradient(to bottom, var(--gradient))",
          "to-bl": "linear-gradient(to bottom left, var(--gradient))",
          "to-l": "linear-gradient(to left, var(--gradient))",
          "to-tl": "linear-gradient(to top left, var(--gradient))"
        };
      },
      transform(value) {
        return {
          "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
          "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
          backgroundImage: value
        };
      }
    },
    gradientFrom: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-from")
    },
    gradientTo: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-to")
    },
    gradientVia: {
      values: colorValues,
      transform(value, args) {
        const styles = createColorMixTransform("--gradient-via")(value, args);
        return {
          ...styles,
          "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
        };
      }
    },
    backgroundImage: { values: "gradients", shorthand: ["bgImg", "bgImage"] },
    // border
    border: { values: "borders" },
    borderTop: { values: "borders" },
    borderLeft: { values: "borders" },
    borderBlockStart: { values: "borders" },
    borderRight: { values: "borders" },
    borderInlineEnd: { values: "borders" },
    borderBottom: { values: "borders" },
    borderBlockEnd: { values: "borders" },
    borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
    borderInline: { values: "borders", shorthand: ["borderX"] },
    borderBlock: { values: "borders", shorthand: ["borderY"] },
    // border colors
    borderColor: {
      values: colorValues,
      transform: createColorMixTransform("borderColor")
    },
    borderTopColor: {
      values: colorValues,
      transform: createColorMixTransform("borderTopColor")
    },
    borderBlockStartColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockStartColor")
    },
    borderBottomColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBottomColor")
    },
    borderBlockEndColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockEndColor")
    },
    borderLeftColor: {
      values: colorValues,
      transform: createColorMixTransform("borderLeftColor")
    },
    borderInlineStartColor: {
      values: colorValues,
      shorthand: ["borderStartColor"],
      transform: createColorMixTransform("borderInlineStartColor")
    },
    borderRightColor: {
      values: colorValues,
      transform: createColorMixTransform("borderRightColor")
    },
    borderInlineEndColor: {
      values: colorValues,
      shorthand: ["borderEndColor"],
      transform: createColorMixTransform("borderInlineEndColor")
    },
    // border styles
    borderStyle: { values: "borderStyles" },
    borderTopStyle: { values: "borderStyles" },
    borderBlockStartStyle: { values: "borderStyles" },
    borderBottomStyle: { values: "borderStyles" },
    borderBlockEndStyle: {
      values: "borderStyles"
    },
    borderInlineStartStyle: {
      values: "borderStyles",
      shorthand: ["borderStartStyle"]
    },
    borderInlineEndStyle: {
      values: "borderStyles",
      shorthand: ["borderEndStyle"]
    },
    borderLeftStyle: { values: "borderStyles" },
    borderRightStyle: { values: "borderStyles" },
    // border radius
    borderRadius: { values: "radii", shorthand: ["rounded"] },
    borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
    borderStartStartRadius: {
      values: "radii",
      shorthand: ["roundedStartStart", "borderTopStartRadius"]
    },
    borderEndStartRadius: {
      values: "radii",
      shorthand: ["roundedEndStart", "borderBottomStartRadius"]
    },
    borderTopRightRadius: {
      values: "radii",
      shorthand: ["roundedTopRight"]
    },
    borderStartEndRadius: {
      values: "radii",
      shorthand: ["roundedStartEnd", "borderTopEndRadius"]
    },
    borderEndEndRadius: {
      values: "radii",
      shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
    },
    borderBottomLeftRadius: {
      values: "radii",
      shorthand: ["roundedBottomLeft"]
    },
    borderBottomRightRadius: {
      values: "radii",
      shorthand: ["roundedBottomRight"]
    },
    borderInlineStartRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedStart", "borderStartRadius"],
      transform: (value) => ({
        borderStartStartRadius: value,
        borderEndStartRadius: value
      })
    },
    borderInlineEndRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedEnd", "borderEndRadius"],
      transform: (value) => ({
        borderStartEndRadius: value,
        borderEndEndRadius: value
      })
    },
    borderTopRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedTop"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderTopRightRadius: value
      })
    },
    borderBottomRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedBottom"],
      transform: (value) => ({
        borderBottomLeftRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderLeftRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedLeft"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderBottomLeftRadius: value
      })
    },
    borderRightRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedRight"],
      transform: (value) => ({
        borderTopRightRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderWidth: { values: "borderWidths" },
    borderBlockStartWidth: { values: "borderWidths" },
    borderTopWidth: { values: "borderWidths" },
    borderBottomWidth: { values: "borderWidths" },
    borderBlockEndWidth: { values: "borderWidths" },
    borderRightWidth: { values: "borderWidths" },
    borderInlineWidth: {
      values: "borderWidths",
      shorthand: ["borderXWidth"]
    },
    borderInlineStartWidth: {
      values: "borderWidths",
      shorthand: ["borderStartWidth"]
    },
    borderInlineEndWidth: {
      values: "borderWidths",
      shorthand: ["borderEndWidth"]
    },
    borderLeftWidth: { values: "borderWidths" },
    borderBlockWidth: {
      values: "borderWidths",
      shorthand: ["borderYWidth"]
    },
    // colors
    color: {
      values: colorValues,
      transform: createColorMixTransform("color")
    },
    fill: {
      values: colorValues,
      transform: createColorMixTransform("fill")
    },
    stroke: {
      values: colorValues,
      transform: createColorMixTransform("stroke")
    },
    accentColor: {
      values: colorValues,
      transform: createColorMixTransform("accentColor")
    },
    // divide
    divideX: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderInlineStartWidth: value,
            borderInlineEndWidth: "0px"
          }
        };
      }
    },
    divideY: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderTopWidth: value,
            borderBottomWidth: "0px"
          }
        };
      }
    },
    divideColor: {
      values: colorValues,
      transform(value, args) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
            value,
            args
          )
        };
      }
    },
    divideStyle: {
      property: "borderStyle",
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderStyle: value
          }
        };
      }
    },
    // effects
    boxShadow: { values: "shadows", shorthand: ["shadow"] },
    boxShadowColor: {
      values: colorValues,
      transform: createColorMixTransform("--shadow-color"),
      shorthand: ["shadowColor"]
    },
    mixBlendMode: { shorthand: ["blendMode"] },
    backgroundBlendMode: { shorthand: ["bgBlendMode"] },
    opacity: { values: "opacity" },
    // filters
    filter: {
      transform(v2) {
        if (v2 !== "auto") {
          return { filter: v2 };
        }
        return {
          filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
        };
      }
    },
    blur: {
      values: "blurs",
      transform: (v2) => ({ "--blur": wrap$1("blur", v2) })
    },
    brightness: {
      transform: (v2) => ({ "--brightness": wrap$1("brightness", v2) })
    },
    contrast: {
      transform: (v2) => ({ "--contrast": wrap$1("contrast", v2) })
    },
    grayscale: {
      transform: (v2) => ({ "--grayscale": wrap$1("grayscale", v2) })
    },
    hueRotate: {
      transform: (v2) => ({ "--hue-rotate": wrap$1("hue-rotate", deg(v2)) })
    },
    invert: { transform: (v2) => ({ "--invert": wrap$1("invert", v2) }) },
    saturate: {
      transform: (v2) => ({ "--saturate": wrap$1("saturate", v2) })
    },
    sepia: { transform: (v2) => ({ "--sepia": wrap$1("sepia", v2) }) },
    dropShadow: {
      transform: (v2) => ({ "--drop-shadow": wrap$1("drop-shadow", v2) })
    },
    // backdrop filters
    backdropFilter: {
      transform(v2) {
        if (v2 !== "auto") {
          return { backdropFilter: v2 };
        }
        return {
          backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
        };
      }
    },
    backdropBlur: {
      values: "blurs",
      transform: (v2) => ({ "--backdrop-blur": wrap$1("blur", v2) })
    },
    backdropBrightness: {
      transform: (v2) => ({
        "--backdrop-brightness": wrap$1("brightness", v2)
      })
    },
    backdropContrast: {
      transform: (v2) => ({ "--backdrop-contrast": wrap$1("contrast", v2) })
    },
    backdropGrayscale: {
      transform: (v2) => ({
        "--backdrop-grayscale": wrap$1("grayscale", v2)
      })
    },
    backdropHueRotate: {
      transform: (v2) => ({
        "--backdrop-hue-rotate": wrap$1("hue-rotate", deg(v2))
      })
    },
    backdropInvert: {
      transform: (v2) => ({ "--backdrop-invert": wrap$1("invert", v2) })
    },
    backdropOpacity: {
      transform: (v2) => ({ "--backdrop-opacity": wrap$1("opacity", v2) })
    },
    backdropSaturate: {
      transform: (v2) => ({ "--backdrop-saturate": wrap$1("saturate", v2) })
    },
    backdropSepia: {
      transform: (v2) => ({ "--backdrop-sepia": wrap$1("sepia", v2) })
    },
    // flexbox
    flexBasis: { values: "sizes" },
    gap: { values: "spacing" },
    rowGap: { values: "spacing", shorthand: ["gapY"] },
    columnGap: { values: "spacing", shorthand: ["gapX"] },
    flexDirection: { shorthand: ["flexDir"] },
    // grid
    gridGap: { values: "spacing" },
    gridColumnGap: { values: "spacing" },
    gridRowGap: { values: "spacing" },
    // interactivity
    outlineColor: {
      values: colorValues,
      transform: createColorMixTransform("outlineColor")
    },
    focusRing: createFocusRing("&:is(:focus, [data-focus])"),
    focusVisibleRing: createFocusRing(
      "&:is(:focus-visible, [data-focus-visible])"
    ),
    focusRingColor: {
      values: colorValues,
      transform: createColorMixTransform("--focus-ring-color")
    },
    focusRingWidth: {
      values: "borderWidths",
      property: "outlineWidth",
      transform: (v2) => ({ "--focus-ring-width": v2 })
    },
    focusRingStyle: {
      values: "borderStyles",
      property: "outlineStyle",
      transform: (v2) => ({ "--focus-ring-style": v2 })
    },
    // layout
    aspectRatio: { values: "aspectRatios" },
    width: { values: "sizes", shorthand: ["w"] },
    inlineSize: { values: "sizes" },
    height: { values: "sizes", shorthand: ["h"] },
    blockSize: { values: "sizes" },
    boxSize: {
      values: "sizes",
      property: "width",
      transform: (v2) => ({ width: v2, height: v2 })
    },
    minWidth: { values: "sizes", shorthand: ["minW"] },
    minInlineSize: { values: "sizes" },
    minHeight: { values: "sizes", shorthand: ["minH"] },
    minBlockSize: { values: "sizes" },
    maxWidth: { values: "sizes", shorthand: ["maxW"] },
    maxInlineSize: { values: "sizes" },
    maxHeight: { values: "sizes", shorthand: ["maxH"] },
    maxBlockSize: { values: "sizes" },
    hideFrom: {
      values: "breakpoints",
      //@ts-ignore
      transform: (value, { raw, token: token2 }) => {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
        return {
          [media]: { display: "none" }
        };
      }
    },
    hideBelow: {
      values: "breakpoints",
      //@ts-ignore
      transform(value, { raw, token: token2 }) {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
        return {
          [media]: {
            display: "none"
          }
        };
      }
    },
    // scroll
    overscrollBehavior: { shorthand: ["overscroll"] },
    overscrollBehaviorX: { shorthand: ["overscrollX"] },
    overscrollBehaviorY: { shorthand: ["overscrollY"] },
    scrollbar: {
      values: ["visible", "hidden"],
      transform(v2) {
        switch (v2) {
          case "visible":
            return {
              msOverflowStyle: "auto",
              scrollbarWidth: "auto",
              "&::-webkit-scrollbar": { display: "block" }
            };
          case "hidden":
            return {
              msOverflowStyle: "none",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" }
            };
          default:
            return {};
        }
      }
    },
    scrollbarColor: {
      values: colorValues,
      transform: createColorMixTransform("scrollbarColor")
    },
    scrollbarGutter: { values: "spacing" },
    scrollbarWidth: { values: "sizes" },
    // scroll margin
    scrollMargin: { values: "spacing" },
    scrollMarginTop: { values: "spacing" },
    scrollMarginBottom: { values: "spacing" },
    scrollMarginLeft: { values: "spacing" },
    scrollMarginRight: { values: "spacing" },
    scrollMarginX: {
      values: "spacing",
      transform: (v2) => ({ scrollMarginLeft: v2, scrollMarginRight: v2 })
    },
    scrollMarginY: {
      values: "spacing",
      transform: (v2) => ({ scrollMarginTop: v2, scrollMarginBottom: v2 })
    },
    // scroll padding
    scrollPadding: { values: "spacing" },
    scrollPaddingTop: { values: "spacing" },
    scrollPaddingBottom: { values: "spacing" },
    scrollPaddingLeft: { values: "spacing" },
    scrollPaddingRight: { values: "spacing" },
    scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
    scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
    // scroll snap
    scrollSnapType: {
      values: {
        none: "none",
        x: "x var(--scroll-snap-strictness)",
        y: "y var(--scroll-snap-strictness)",
        both: "both var(--scroll-snap-strictness)"
      }
    },
    scrollSnapStrictness: {
      values: ["mandatory", "proximity"],
      transform: (v2) => ({ "--scroll-snap-strictness": v2 })
    },
    scrollSnapMargin: { values: "spacing" },
    scrollSnapMarginTop: { values: "spacing" },
    scrollSnapMarginBottom: { values: "spacing" },
    scrollSnapMarginLeft: { values: "spacing" },
    scrollSnapMarginRight: { values: "spacing" },
    // list
    listStylePosition: { shorthand: ["listStylePos"] },
    listStyleImage: { shorthand: ["listStyleImg"] },
    // position
    position: { shorthand: ["pos"] },
    zIndex: { values: "zIndex" },
    inset: { values: "spacing" },
    insetInline: { values: "spacing", shorthand: ["insetX"] },
    insetBlock: { values: "spacing", shorthand: ["insetY"] },
    top: { values: "spacing" },
    insetBlockStart: { values: "spacing" },
    bottom: { values: "spacing" },
    insetBlockEnd: { values: "spacing" },
    left: { values: "spacing" },
    right: { values: "spacing" },
    insetInlineStart: {
      values: "spacing",
      shorthand: ["insetStart"]
    },
    insetInlineEnd: {
      values: "spacing",
      shorthand: ["insetEnd"]
    },
    // shadow / ring
    ring: {
      transform(value) {
        return {
          "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
          "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
          "--ring-width": value,
          boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
        };
      }
    },
    ringColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-color")
    },
    ringOffset: {
      transform: (value) => ({ "--ring-offset-width": value })
    },
    ringOffsetColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-offset-color")
    },
    ringInset: {
      transform: (v2) => ({ "--ring-inset": v2 })
    },
    // margin
    margin: { values: "spacing", shorthand: ["m"] },
    marginTop: { values: "spacing", shorthand: ["mt"] },
    marginBlockStart: { values: "spacing", shorthand: ["mt"] },
    marginRight: { values: "spacing", shorthand: ["mr"] },
    marginBottom: { values: "spacing", shorthand: ["mb"] },
    marginBlockEnd: { values: "spacing" },
    marginLeft: { values: "spacing", shorthand: ["ml"] },
    marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
    marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
    marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
    marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
    // padding
    padding: { values: "spacing", shorthand: ["p"] },
    paddingTop: { values: "spacing", shorthand: ["pt"] },
    paddingRight: { values: "spacing", shorthand: ["pr"] },
    paddingBottom: { values: "spacing", shorthand: ["pb"] },
    paddingBlockStart: { values: "spacing" },
    paddingBlockEnd: { values: "spacing" },
    paddingLeft: { values: "spacing", shorthand: ["pl"] },
    paddingInlineStart: {
      values: "spacing",
      shorthand: ["ps", "paddingStart"]
    },
    paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
    paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
    paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
    // text decoration
    textDecoration: { shorthand: ["textDecor"] },
    textDecorationColor: {
      values: colorValues,
      transform: createColorMixTransform("textDecorationColor")
    },
    textShadow: { values: "shadows" },
    // transform
    transform: {
      transform: (value) => {
        let v2 = value;
        if (value === "auto") {
          v2 = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        if (value === "auto-gpu") {
          v2 = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        return { transform: v2 };
      }
    },
    skewX: { transform: (v2) => ({ "--skew-x": deg(v2) }) },
    skewY: { transform: (v2) => ({ "--skew-y": deg(v2) }) },
    scaleX: { transform: (v2) => ({ "--scale-x": v2 }) },
    scaleY: { transform: (v2) => ({ "--scale-y": v2 }) },
    scale: {
      transform(value) {
        if (value !== "auto") return { scale: value };
        return {
          scale: `var(--scale-x, 1) var(--scale-y, 1)`
        };
      }
    },
    spaceXReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceX: {
      property: "marginInlineStart",
      values: "spacing",
      transform: (v2) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-x-reverse": "0",
          marginInlineStart: `calc(${v2} * calc(1 - var(--space-x-reverse)))`,
          marginInlineEnd: `calc(${v2} * var(--space-x-reverse))`
        }
      })
    },
    spaceYReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceY: {
      property: "marginTop",
      values: "spacing",
      transform: (v2) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-y-reverse": "0",
          marginTop: `calc(${v2} * calc(1 - var(--space-y-reverse)))`,
          marginBottom: `calc(${v2} * var(--space-y-reverse))`
        }
      })
    },
    rotate: {
      transform(value) {
        if (value !== "auto") return { rotate: deg(value) };
        return {
          rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
        };
      }
    },
    rotateX: {
      transform(value) {
        return { "--rotate-x": deg(value) };
      }
    },
    rotateY: {
      transform(value) {
        return { "--rotate-y": deg(value) };
      }
    },
    // transform / translate
    translate: {
      transform(value) {
        if (value !== "auto") return { translate: value };
        return {
          translate: `var(--translate-x) var(--translate-y)`
        };
      }
    },
    translateX: {
      values: "spacing",
      transform: (v2) => ({ "--translate-x": v2 })
    },
    translateY: {
      values: "spacing",
      transform: (v2) => ({ "--translate-y": v2 })
    },
    // transition
    transition: {
      values: [
        "all",
        "common",
        "colors",
        "opacity",
        "position",
        "backgrounds",
        "size",
        "shadow",
        "transform"
      ],
      transform(value) {
        switch (value) {
          case "all":
            return createTransition("all");
          case "position":
            return createTransition(
              "left, right, top, bottom, inset-inline, inset-block"
            );
          case "colors":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke"
            );
          case "opacity":
            return createTransition("opacity");
          case "shadow":
            return createTransition("box-shadow");
          case "transform":
            return createTransition("transform");
          case "size":
            return createTransition("width, height");
          case "backgrounds":
            return createTransition(
              "background, background-color, background-image, background-position"
            );
          case "common":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
            );
          default:
            return { transition: value };
        }
      }
    },
    transitionDuration: { values: "durations" },
    transitionProperty: {
      values: {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
        colors: "background-color, border-color, color, fill, stroke",
        size: "width, height",
        position: "left, right, top, bottom, inset-inline, inset-block",
        background: "background, background-color, background-image, background-position"
      }
    },
    transitionTimingFunction: { values: "easings" },
    // animation
    animation: { values: "animations" },
    animationDuration: { values: "durations" },
    animationDelay: { values: "durations" },
    animationTimingFunction: { values: "easings" },
    // typography
    fontFamily: { values: "fonts" },
    fontSize: { values: "fontSizes" },
    fontWeight: { values: "fontWeights" },
    lineHeight: { values: "lineHeights" },
    letterSpacing: { values: "letterSpacings" },
    textIndent: { values: "spacing" },
    truncate: {
      values: { type: "boolean" },
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
        return {};
      }
    },
    lineClamp: {
      transform(value) {
        if (value === "none") {
          return {
            WebkitLineClamp: "unset"
          };
        }
        return {
          overflow: "hidden",
          display: "-webkit-box",
          WebkitLineClamp: value,
          WebkitBoxOrient: "vertical",
          textWrap: "wrap"
        };
      }
    },
    // helpers
    srOnly: {
      values: { type: "boolean" },
      transform(value) {
        return srMapping[value] || {};
      }
    },
    debug: {
      values: { type: "boolean" },
      transform(value) {
        if (!value) return {};
        return {
          outline: "1px solid blue !important",
          "& > *": {
            outline: "1px solid red !important"
          }
        };
      }
    },
    caretColor: {
      values: colorValues,
      transform: createColorMixTransform("caretColor")
    },
    cursor: { values: "cursor" }
  }
});
const srMapping = {
  true: {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  },
  false: {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    clip: "auto",
    whiteSpace: "normal"
  }
};
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimingFunction,animationTimeline,appearance,aspectRatio,azimuth,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockStyle,borderBlockWidth,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineEnd,borderInlineColor,borderInlineStyle,borderInlineWidth,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,color,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicSize,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,direction,display,emptyCells,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontVariationSettings,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inputSecurity,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,printColorAdjust,quotes,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,scale,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginBottom,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,shapeImageThreshold,shapeMargin,shapeOutside,tabSize,tableLayout,textAlign,textAlignLast,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,zIndex,zoom,alignmentBaseline,baselineShift,clipRule,colorInterpolation,colorRendering,dominantBaseline,fill,fillOpacity,fillRule,floodColor,floodOpacity,glyphOrientationVertical,lightingColor,marker,markerEnd,markerMid,markerStart,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,textAnchor,vectorEffect";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties$1 = new Map(allCssProperties.map((prop) => [prop, true]));
function memo$1(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (arg) => {
    if (cache2[arg] === void 0)
      cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = /* @__PURE__ */ memo$1((prop) => {
  return properties$1.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});
const isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if (isObject$3(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = (getKey == null ? void 0 : getKey(prop, child)) ?? prop;
        const childPath = [...path, key];
        if (stop == null ? void 0 : stop(value, childPath)) {
          return predicate(value, path);
        }
        const next2 = inner(child, childPath);
        if (isNotNullish(next2)) {
          result[key] = next2;
        }
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj)) return obj.map((value) => fn(value));
  if (!isObject$3(obj)) {
    if (obj !== null && obj !== void 0) return fn(obj);
    else return obj;
  }
  return walkObject(obj, (value) => fn(value));
}
function flatten(values, stop) {
  const result = {};
  walkObject(
    values,
    (token2, paths) => {
      if (token2) {
        result[paths.join(".")] = token2.value;
      }
    },
    { stop }
  );
  return result;
}
const memo = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  function get2(...args) {
    const key = JSON.stringify(args);
    if (cache2[key] === void 0) cache2[key] = fn(...args);
    return cache2[key];
  }
  return get2;
};
const BASE_FONT_SIZE = 16;
const UNIT_PX = "px";
const UNIT_EM = "em";
const UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(
    new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
  );
  return unit == null ? void 0 : unit[1];
}
function toPx(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}
const capitalize$1 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createBreakpoints(breakpoints2) {
  const sorted = sort(breakpoints2);
  const values = Object.fromEntries(sorted);
  function get2(name) {
    return values[name];
  }
  function only(name) {
    return build(get2(name));
  }
  function getRanges() {
    const breakpoints22 = Object.keys(values);
    const permuations = getPermutations(breakpoints22);
    const results = breakpoints22.flatMap((name) => {
      const value = get2(name);
      const down2 = [
        `${name}Down`,
        build({ max: adjust(value.min) })
      ];
      const up2 = [name, build({ min: value.min })];
      const _only = [`${name}Only`, only(name)];
      return [up2, _only, down2];
    }).filter(([, value]) => value !== "").concat(
      permuations.map(([min2, max2]) => {
        const minValue = get2(min2);
        const maxValue2 = get2(max2);
        return [
          `${min2}To${capitalize$1(max2)}`,
          build({ min: minValue.min, max: adjust(maxValue2.min) })
        ];
      })
    );
    return Object.fromEntries(results);
  }
  function toConditions() {
    const ranges = getRanges();
    return Object.fromEntries(Object.entries(ranges));
  }
  const conditions = toConditions();
  const getCondition = (key) => {
    return conditions[key];
  };
  function keys() {
    return ["base", ...Object.keys(values)];
  }
  function up(name) {
    return build({ min: get2(name).min });
  }
  function down(name) {
    return build({ max: adjust(get2(name).min) });
  }
  return {
    values: Object.values(values),
    only,
    keys,
    conditions,
    getCondition,
    up,
    down
  };
}
function adjust(value) {
  const computedMax = parseFloat(toPx(value) ?? "") - 0.04;
  return toRem(`${computedMax}px`);
}
function sort(breakpoints2) {
  const entries = Object.entries(breakpoints2).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  });
  return entries.map(([name, min2], index, entries2) => {
    var _a2;
    let max2 = null;
    if (index <= entries2.length - 1) {
      max2 = (_a2 = entries2[index + 1]) == null ? void 0 : _a2[1];
    }
    if (max2 != null) {
      max2 = adjust(max2);
    }
    return [name, { name, min: toRem(min2), max: max2 }];
  });
}
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next2 = values[idx];
    while (next2) {
      result.push([current, next2]);
      idx++;
      next2 = values[idx];
    }
  });
  return result;
}
function build({ min: min2, max: max2 }) {
  if (min2 == null && max2 == null) return "";
  return [
    "@media screen",
    min2 && `(min-width: ${min2})`,
    max2 && `(max-width: ${max2})`
  ].filter(Boolean).join(" and ");
}
const mapEntries$1 = (obj, fn) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => fn(key, value))
  );
};
const createConditions = (options) => {
  const { breakpoints: breakpoints2, conditions: conds = {} } = options;
  const conditions = mapEntries$1(conds, (key, value) => [`_${key}`, value]);
  const values = Object.assign({}, conditions, breakpoints2.conditions);
  function keys() {
    return Object.keys(values);
  }
  function has(key) {
    return keys().includes(key) || /^@|&|&$/.test(key) || key.startsWith("_");
  }
  function sort2(paths) {
    return paths.filter((v2) => v2 !== "base").sort((a, b2) => {
      const aa2 = has(a);
      const bb2 = has(b2);
      if (aa2 && !bb2) return 1;
      if (!aa2 && bb2) return -1;
      return 0;
    });
  }
  function expandAtRule(key) {
    if (!key.startsWith("@breakpoint")) return key;
    return breakpoints2.getCondition(key.replace("@breakpoint ", ""));
  }
  function resolve(key) {
    return Reflect.get(values, key) || key;
  }
  return {
    keys,
    sort: sort2,
    has,
    resolve,
    breakpoints: breakpoints2.keys(),
    expandAtRule
  };
};
const createMediaQueryRegex = (dimension) => ({
  minMax: new RegExp(
    `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
    "i"
  ),
  min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
  maxMin: new RegExp(
    `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
    "i"
  ),
  max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
});
const widthRegex = createMediaQueryRegex("width");
const heightRegex = createMediaQueryRegex("height");
const createQueryTester = (regexSet) => ({
  isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
  isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
});
const { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
const { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
const isPrint = /print/i;
const isPrintOnly = /^print$/i;
const isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
const lengthExec = /(\d)/;
const maxValue = Number.MAX_VALUE;
const multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
function getQueryLength(query2) {
  const length2 = isLength.exec(query2) || (isMinWidth(query2) || isMinHeight(query2) ? lengthExec.exec(query2) : null);
  if (!length2) return maxValue;
  if (length2[0] === "0") return 0;
  const number = parseFloat(length2[1]);
  const unit = length2[2];
  return number * (multipliers[unit] || 1);
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return (query2) => doubleTestTrue.test(query2) || !doubleTestFalse.test(query2) && singleTest.test(query2);
}
function _testIsPrint(a, b2) {
  const isPrintA = isPrint.test(a), isPrintOnlyA = isPrintOnly.test(a);
  const isPrintB = isPrint.test(b2), isPrintOnlyB = isPrintOnly.test(b2);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) return 1;
    if (isPrintOnlyA && !isPrintOnlyB) return -1;
    return a.localeCompare(b2);
  }
  return isPrintA ? 1 : isPrintB ? -1 : null;
}
const sortAtParams = memo((a, b2) => {
  const testIsPrint = _testIsPrint(a, b2);
  if (testIsPrint !== null) return testIsPrint;
  const minA = isMinWidth(a) || isMinHeight(a), maxA = isMaxWidth(a) || isMaxHeight(a);
  const minB = isMinWidth(b2) || isMinHeight(b2), maxB = isMaxWidth(b2) || isMaxHeight(b2);
  if (minA && maxB) return -1;
  if (maxA && minB) return 1;
  const lengthA = getQueryLength(a), lengthB = getQueryLength(b2);
  if (lengthA === maxValue && lengthB === maxValue) return a.localeCompare(b2);
  if (lengthA === maxValue) return 1;
  if (lengthB === maxValue) return -1;
  if (lengthA !== lengthB) {
    return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
  }
  return a.localeCompare(b2);
});
function sortQueries(queries) {
  return queries.sort(([a], [b2]) => sortAtParams(a, b2));
}
function sortAtRules(obj) {
  const mediaQueries = [];
  const containerQueries = [];
  const rest = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("@media")) {
      mediaQueries.push([key, value]);
    } else if (key.startsWith("@container")) {
      containerQueries.push([key, value]);
    } else if (isObject$3(value)) {
      rest[key] = sortAtRules(value);
    } else {
      rest[key] = value;
    }
  }
  const sortedMediaQueries = sortQueries(mediaQueries);
  const sortedContainerQueries = sortQueries(containerQueries);
  return {
    ...rest,
    ...Object.fromEntries(sortedMediaQueries),
    ...Object.fromEntries(sortedContainerQueries)
  };
}
const importantRegex = /\s*!(important)?/i;
const isImportant = (v2) => isString$1(v2) ? importantRegex.test(v2) : false;
const withoutImportant = (v2) => isString$1(v2) ? v2.replace(importantRegex, "").trim() : v2;
function createCssFn(context) {
  const { transform: transform2, conditions, normalize: normalize2 } = context;
  const mergeFn = mergeCss(context);
  return memo((...styleArgs) => {
    const styles = mergeFn(...styleArgs);
    const normalized = normalize2(styles);
    const result = /* @__PURE__ */ Object.create(null);
    walkObject(normalized, (value, paths) => {
      const important = isImportant(value);
      if (value == null) return;
      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
      if (important) {
        value = withoutImportant(value);
      }
      let transformed = transform2(prop, value) ?? /* @__PURE__ */ Object.create(null);
      transformed = walkObject(
        transformed,
        (v2) => isString$1(v2) && important ? `${v2} !important` : v2,
        { getKey: (prop2) => conditions.expandAtRule(prop2) }
      );
      mergeByPath(result, selectors.flat(), transformed);
    });
    return sortAtRules(result);
  });
}
function mergeByPath(target, paths, value) {
  let acc = target;
  for (const path of paths) {
    if (!path) continue;
    if (!acc[path]) acc[path] = /* @__PURE__ */ Object.create(null);
    acc = acc[path];
  }
  mergeWith(acc, value);
}
function compactFn(...styles) {
  return styles.filter(
    (style) => isObject$3(style) && Object.keys(compact$2(style)).length > 0
  );
}
function mergeCss(ctx) {
  function resolve(styles) {
    const comp = compactFn(...styles);
    if (comp.length === 1) return comp;
    return comp.map((style) => ctx.normalize(style));
  }
  return memo((...styles) => {
    return mergeWith({}, ...resolve(styles));
  });
}
function omit(object, keysToOmit = []) {
  const clone = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone) {
      delete clone[key];
    }
  }
  return clone;
}
const uniq = (...items2) => {
  const _items = items2.filter(Boolean);
  return Array.from(new Set(_items));
};
const defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function createRecipeFn(options) {
  const { css: css2, conditions, normalize: normalize2, layers } = options;
  function cva(config2 = {}) {
    const { base, variants: variants2, defaultVariants: defaultVariants2, compoundVariants } = defaults(config2);
    const getVariantCss = createCssFn({
      conditions,
      normalize: normalize2,
      transform(prop, value) {
        var _a2;
        return (_a2 = variants2[prop]) == null ? void 0 : _a2[value];
      }
    });
    const resolve = (props = {}) => {
      const variantSelections = normalize2({
        ...defaultVariants2,
        ...compact$2(props)
      });
      let variantCss = { ...base };
      mergeWith(variantCss, getVariantCss(variantSelections));
      const compoundVariantCss = getCompoundVariantCss(
        compoundVariants,
        variantSelections
      );
      return layers.wrap("recipes", css2(variantCss, compoundVariantCss));
    };
    const variantKeys = Object.keys(variants2);
    const splitVariantProps = (props) => {
      const restProps = omit(props, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props.colorPalette || defaultVariants2.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props.orientation;
      }
      return [recipeProps, localProps];
    };
    const variantMap = Object.fromEntries(
      Object.entries(variants2).map(([key, value]) => [
        key,
        Object.keys(value)
      ])
    );
    const cvaFn = (props) => css2(resolve(props));
    return Object.assign(cvaFn, {
      className: config2.className,
      __cva__: true,
      variantMap,
      variantKeys,
      raw: resolve,
      config: config2,
      splitVariantProps,
      merge(other) {
        return cva(mergeCva(options)(this, other));
      }
    });
  }
  function getCompoundVariantCss(cvs, vm) {
    let result = {};
    cvs.forEach((cv) => {
      const isMatching = Object.entries(cv).every(([key, value]) => {
        if (key === "css") return true;
        const values = Array.isArray(value) ? value : [value];
        return values.some((value2) => vm[key] === value2);
      });
      if (isMatching) {
        result = css2(result, cv.css);
      }
    });
    return result;
  }
  return cva;
}
function mergeCva(opts) {
  const { css: css2 } = opts;
  return function mergeCva2(cvaA, cvaB) {
    const override = defaults(cvaB.config);
    const variantKeys = uniq(cvaA.variantKeys, Object.keys(cvaB.variants));
    const base = css2(cvaA.base, override.base);
    const variants2 = Object.fromEntries(
      variantKeys.map((key) => [
        key,
        css2(cvaA.config.variants[key], override.variants[key])
      ])
    );
    const defaultVariants2 = mergeWith(
      cvaA.config.defaultVariants,
      override.defaultVariants
    );
    const compoundVariants = [
      ...cvaA.compoundVariants,
      ...override.compoundVariants
    ];
    const className = cx(cvaA.className, cvaB.className);
    return {
      className,
      base,
      variants: variants2,
      defaultVariants: defaultVariants2,
      compoundVariants
    };
  };
}
const defaultLayers = {
  reset: "reset",
  base: "base",
  tokens: "tokens",
  recipes: "recipes"
};
const layerOrder = {
  reset: 0,
  base: 1,
  tokens: 2,
  recipes: 3
};
function createLayers(config2) {
  const layers = config2.layers ?? defaultLayers;
  const values = Object.values(layers);
  const names = values.sort((a, b2) => layerOrder[a] - layerOrder[b2]);
  return {
    names,
    atRule: `@layer ${names.join(", ")};`,
    wrap(layer, styles) {
      if (config2.disableLayers) return styles;
      const params = layers[layer];
      return { [`@layer ${params}`]: styles };
    }
  };
}
function createNormalizeFn(context) {
  const { utility, normalize: normalize2 } = context;
  const { hasShorthand, resolveShorthand } = utility;
  return function(styles) {
    return walkObject(styles, normalize2, {
      stop: (value) => Array.isArray(value),
      getKey: hasShorthand ? resolveShorthand : void 0
    });
  };
}
function createPreflight(options) {
  const { preflight } = options;
  if (!preflight) return {};
  const { scope = "", level = "parent" } = isObject$3(preflight) ? preflight : {};
  let selector = "";
  if (scope && level === "parent") {
    selector = `${scope} `;
  } else if (scope && level === "element") {
    selector = `&${scope}`;
  }
  const scoped = {
    "*": {
      margin: "0px",
      padding: "0px",
      font: "inherit",
      wordWrap: "break-word",
      WebkitTapHighlightColor: "transparent"
    },
    "*, *::before, *::after, *::backdrop": {
      boxSizing: "border-box",
      borderWidth: "0px",
      borderStyle: "solid",
      borderColor: "var(--global-color-border, currentColor)"
    },
    hr: {
      height: "0px",
      color: "inherit",
      borderTopWidth: "1px"
    },
    body: {
      minHeight: "100dvh",
      position: "relative"
    },
    img: {
      borderStyle: "none"
    },
    "img, svg, video, canvas, audio, iframe, embed, object": {
      display: "block",
      verticalAlign: "middle"
    },
    iframe: { border: "none" },
    "img, video": { maxWidth: "100%", height: "auto" },
    "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
    "ol, ul": { listStyle: "none" },
    "code, kbd, pre, samp": { fontSize: "1em" },
    "button, [type='button'], [type='reset'], [type='submit']": {
      WebkitAppearance: "button",
      backgroundColor: "transparent",
      backgroundImage: "none"
    },
    "button, input, optgroup, select, textarea": { color: "inherit" },
    "button, select": { textTransform: "none" },
    table: {
      textIndent: "0px",
      borderColor: "inherit",
      borderCollapse: "collapse"
    },
    "*::placeholder": {
      opacity: "unset",
      color: "#9ca3af",
      userSelect: "none"
    },
    textarea: {
      resize: "vertical"
    },
    summary: {
      display: "list-item"
    },
    small: {
      fontSize: "80%"
    },
    "sub, sup": {
      fontSize: "75%",
      lineHeight: 0,
      position: "relative",
      verticalAlign: "baseline"
    },
    sub: {
      bottom: "-0.25em"
    },
    sup: {
      top: "-0.5em"
    },
    dialog: {
      padding: "0px"
    },
    a: {
      color: "inherit",
      textDecoration: "inherit"
    },
    "abbr:where([title])": {
      textDecoration: "underline dotted"
    },
    "b, strong": {
      fontWeight: "bolder"
    },
    "code, kbd, samp, pre": {
      fontSize: "1em",
      "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
      fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
    },
    'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
      WebkitAppearance: "none",
      MozAppearance: "none"
    },
    "input[type='search']": {
      WebkitAppearance: "textfield",
      outlineOffset: "-2px"
    },
    "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
      WebkitAppearance: "none"
    },
    "::-webkit-file-upload-button": {
      WebkitAppearance: "button",
      font: "inherit"
    },
    'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
      height: "auto"
    },
    "input[type='number']": {
      MozAppearance: "textfield"
    },
    ":-moz-ui-invalid": {
      boxShadow: "none"
    },
    ":-moz-focusring": {
      outline: "auto"
    },
    "[hidden]:where(:not([hidden='until-found']))": {
      display: "none !important"
    }
  };
  const preflightCss = {
    [scope || "html"]: {
      lineHeight: 1.5,
      "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      WebkitTextSizeAdjust: "100%",
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      textRendering: "optimizeLegibility",
      touchAction: "manipulation",
      MozTabSize: "4",
      tabSize: "4",
      fontFamily: "var(--global-font-body, var(--font-fallback))"
    }
  };
  if (level === "element") {
    const modified = Object.entries(scoped).reduce((acc, [k2, v2]) => {
      acc[k2] = { [selector]: v2 };
      return acc;
    }, {});
    Object.assign(preflightCss, modified);
  } else if (selector) {
    preflightCss[selector] = scoped;
  } else {
    Object.assign(preflightCss, scoped);
  }
  return preflightCss;
}
function createSerializeFn(options) {
  const { conditions, isValidProperty } = options;
  return function serialize2(styles) {
    return walkObject(styles, (value) => value, {
      getKey: (prop, value) => {
        if (!isObject$3(value)) return prop;
        if (!conditions.has(prop) && !isValidProperty(prop)) {
          return parseSelectors(prop).map((s) => "&" + s).join(", ");
        }
        return prop;
      }
    });
  };
}
function parseSelectors(selector) {
  const result = [];
  let parenCount = 0;
  let currentSelector = "";
  let inEscape = false;
  for (let i = 0; i < selector.length; i++) {
    const char2 = selector[i];
    if (char2 === "\\" && !inEscape) {
      inEscape = true;
      currentSelector += char2;
      continue;
    }
    if (inEscape) {
      inEscape = false;
      currentSelector += char2;
      continue;
    }
    if (char2 === "(") {
      parenCount++;
    } else if (char2 === ")") {
      parenCount--;
    }
    if (char2 === "," && parenCount === 0) {
      result.push(currentSelector.trim());
      currentSelector = "";
    } else {
      currentSelector += char2;
    }
  }
  if (currentSelector) {
    result.push(currentSelector.trim());
  }
  return result;
}
const getSlotRecipes = (config2 = {}) => {
  const init = (slot) => {
    var _a2;
    return {
      base: ((_a2 = config2.base) == null ? void 0 : _a2[slot]) ?? {},
      variants: {},
      defaultVariants: config2.defaultVariants ?? {},
      compoundVariants: config2.compoundVariants ? getSlotCompoundVariant(config2.compoundVariants, slot) : []
    };
  };
  const slots = config2.slots ?? [];
  const entries = slots.map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(
    config2.variants ?? {}
  )) {
    for (const [variantKey, variantSpec] of Object.entries(
      variantsSpec
    )) {
      entries.forEach(([slot, slotRecipe]) => {
        var _a2;
        (_a2 = slotRecipe.variants)[variantsKey] ?? (_a2[variantsKey] = {});
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(entries);
};
const getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
  ...compoundVariant,
  css: compoundVariant.css[slotName]
}));
function createSlotRecipeFn(options) {
  const { cva } = options;
  return function sva(config2 = {}) {
    const slots = Object.entries(getSlotRecipes(config2)).map(
      ([slot, slotCva]) => [slot, cva(slotCva)]
    );
    function svaFn(props) {
      const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props)]);
      return Object.fromEntries(result);
    }
    const variants2 = config2.variants ?? {};
    const variantKeys = Object.keys(variants2);
    function splitVariantProps(props) {
      var _a2;
      const restProps = omit(props, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props.colorPalette || ((_a2 = config2.defaultVariants) == null ? void 0 : _a2.colorPalette);
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props.orientation;
      }
      return [recipeProps, localProps];
    }
    const variantMap = Object.fromEntries(
      Object.entries(variants2).map(([key, value]) => [key, Object.keys(value)])
    );
    let classNameMap = {};
    if (config2.className) {
      classNameMap = Object.fromEntries(
        config2.slots.map((slot) => [
          slot,
          `${config2.className}__${slot}`
        ])
      );
    }
    return Object.assign(svaFn, {
      variantMap,
      variantKeys,
      splitVariantProps,
      classNameMap
    });
  };
}
const createProps$1 = () => (props) => Array.from(new Set(props));
const rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
const fcssescape = function(ch2, asCodePoint) {
  if (!asCodePoint) return "\\" + ch2;
  if (ch2 === "\0") return "";
  if (ch2 === "-" && ch2.length === 1) return "\\-";
  return ch2.slice(0, -1) + "\\" + ch2.charCodeAt(ch2.length - 1).toString(16);
};
const esc = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};
const expandTokenReferences = (str, resolve) => {
  let expanded = "";
  let index = 0;
  let state = "char";
  let tokenPath = "";
  let fallback2 = "";
  const currentStates = [];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path = str.slice(index + 1, endIndex);
      const resolved = resolve(path);
      expanded += resolved ?? path;
      index = endIndex + 1;
      continue;
    }
    if (state === "token") {
      if (char2 === ",") {
        if (str[index] === "") {
          index++;
        }
        state = "fallback";
        currentStates.push(state);
        const resolved = resolve(tokenPath);
        if (resolved == null ? void 0 : resolved.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback2 = "";
        continue;
      }
    }
    if (state === "fallback") {
      const nextFallback = fallback2 + char2;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar2 = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar2 + ")";
        index = endIndex + 1;
        state = currentStates.pop() ?? state;
        fallback2 = "";
        continue;
      }
    }
    if (state === "token" || state === "fallback") {
      index++;
      if (char2 === ")") {
        state = currentStates.pop() ?? state ?? "char";
        fallback2 += char2;
        const resolved = tokenPath ? resolve(tokenPath) ?? esc(tokenPath) : tokenPath;
        if (fallback2) {
          fallback2 = fallback2.slice(1).trim();
          if (!fallback2.startsWith("token(") && fallback2.endsWith(")")) {
            fallback2 = fallback2.slice(0, -1);
          }
          if (fallback2.includes("token(")) {
            const parsed = expandTokenReferences(fallback2, resolve);
            if (parsed) {
              fallback2 = parsed.slice(0, -1);
            }
          } else if (fallback2) {
            const resolvedFallback = resolve(fallback2);
            if (resolvedFallback) {
              fallback2 = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback2) {
          if (lastChar == null ? void 0 : lastChar.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback2 + ")");
          } else {
            expanded += fallback2;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback2 = "";
        state = "char";
        continue;
      }
      if (state === "token") {
        tokenPath += char2;
      }
      if (state === "fallback") {
        fallback2 += char2;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state = "token";
      currentStates.push(state);
      continue;
    }
    expanded += char2;
    index++;
  }
  return expanded;
};
const cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "(") {
      openedParenthesises.push(char2);
    } else if (char2 === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};
function mapToJson(map) {
  const obj = {};
  map.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}
const REFERENCE_REGEX = /({([^}]*)})/g;
const CURLY_REGEX = /[{}]/g;
const TOKEN_PATH_REGEX = /\w+\.\w+/;
const getReferences = (value) => {
  if (!isString$1(value)) return [];
  const matches2 = value.match(REFERENCE_REGEX);
  if (!matches2) return [];
  return matches2.map((match2) => match2.replace(CURLY_REGEX, "")).map((value2) => value2.trim());
};
const hasReference = (value) => REFERENCE_REGEX.test(value);
function expandReferences(token2) {
  var _a2, _b2, _c2;
  if (!((_a2 = token2.extensions) == null ? void 0 : _a2.references)) {
    return ((_c2 = (_b2 = token2.extensions) == null ? void 0 : _b2.cssVar) == null ? void 0 : _c2.ref) ?? token2.value;
  }
  const references = token2.extensions.references ?? {};
  token2.value = Object.keys(references).reduce((valueStr, key) => {
    const referenceToken = references[key];
    if (referenceToken.extensions.conditions) {
      return valueStr;
    }
    const value = expandReferences(referenceToken);
    return valueStr.replace(`{${key}}`, value);
  }, token2.value);
  delete token2.extensions.references;
  return token2.value;
}
function resolveReference(operand) {
  if (isObject$3(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
const toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
const add = (...operands) => `calc(${toExpression("+", ...operands)})`;
const subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
const multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
const divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
const negate = (x2) => {
  const value = resolveReference(x2);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
const calc = Object.assign(
  (x2) => ({
    add: (...operands) => calc(add(x2, ...operands)),
    subtract: (...operands) => calc(subtract(x2, ...operands)),
    multiply: (...operands) => calc(multiply(x2, ...operands)),
    divide: (...operands) => calc(divide(x2, ...operands)),
    negate: () => calc(negate(x2)),
    toString: () => x2.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);
const addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix: prefix2, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "spacing"
    );
    tokens.forEach((token2) => {
      const originalPath = token2.path.slice();
      const originalVar = formatCssVar(originalPath, prefix2);
      if (isString$1(token2.value) && token2.value === "0rem") {
        return;
      }
      const nextToken = structuredClone(token2);
      Object.assign(nextToken.extensions, {
        negative: true,
        prop: `-${token2.extensions.prop}`,
        originalPath
      });
      nextToken.value = calc.negate(originalVar.ref);
      const lastPath = nextToken.path[nextToken.path.length - 1];
      if (lastPath != null) {
        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;
      }
      if (nextToken.path) {
        nextToken.name = formatTokenName(nextToken.path);
      }
      registerToken(nextToken);
    });
  }
};
const units = /* @__PURE__ */ new Set([
  "spacing",
  "sizes",
  "borderWidths",
  "fontSizes",
  "radii"
]);
const addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.allTokens.filter((token2) => {
      return units.has(token2.extensions.category) && !token2.extensions.negative;
    });
    tokens.forEach((token2) => {
      Object.assign(token2.extensions, {
        pixelValue: toPx(token2.value)
      });
    });
  }
};
const addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const { allTokens, registerToken, formatTokenName } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "colors"
    );
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token2) => {
      const { colorPalette } = token2.extensions;
      if (!colorPalette) return;
      colorPalette.keys.forEach((keyPath) => {
        keys.set(formatTokenName(keyPath), keyPath);
      });
      colorPalette.roots.forEach((colorPaletteRoot) => {
        var _a2;
        const name = formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(name) || [];
        colorPaletteList.push(token2);
        colorPalettes.set(name, colorPaletteList);
        if (token2.extensions.default && colorPaletteRoot.length === 1) {
          const keyPath = (_a2 = colorPalette.keys[0]) == null ? void 0 : _a2.filter(Boolean);
          if (!keyPath.length) return;
          const path = colorPaletteRoot.concat(keyPath);
          keys.set(formatTokenName(path), []);
        }
      });
    });
    keys.forEach((segments) => {
      const path = ["colors", "colorPalette", ...segments].filter(Boolean);
      const name = formatTokenName(path);
      const prop = formatTokenName(path.slice(1));
      const token2 = {
        name,
        value: name,
        originalValue: name,
        path,
        extensions: {
          condition: "base",
          originalPath: path,
          category: "colors",
          prop,
          virtual: true
        }
      };
      registerToken(token2, "pre");
    });
  }
};
const removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter(
      (token2) => token2.value !== ""
    );
  }
};
const tokenMiddlewares = [
  addNegativeTokens,
  addVirtualPalette,
  addPixelUnit,
  removeEmptyTokens
];
const addCssVariables = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/css-var",
  transform(token2, dictionary) {
    const { prefix: prefix2, formatCssVar } = dictionary;
    const { negative, originalPath } = token2.extensions;
    const path = negative ? originalPath : token2.path;
    return {
      cssVar: formatCssVar(path.filter(Boolean), prefix2)
    };
  }
};
const addConditionalCssVariables = {
  enforce: "post",
  type: "value",
  name: "tokens/conditionals",
  transform(token2, dictionary) {
    const { prefix: prefix2, formatCssVar } = dictionary;
    const refs = getReferences(token2.value);
    if (!refs.length) return token2.value;
    refs.forEach((ref2) => {
      const variable = formatCssVar(ref2.split("."), prefix2);
      token2.value = token2.value.replace(`{${variable.ref}}`, variable);
    });
    return token2.value;
  }
};
const addColorPalette = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/colors/colorPalette",
  match(token2) {
    return token2.extensions.category === "colors" && !token2.extensions.virtual;
  },
  transform(token2, dict) {
    let path = token2.path.slice();
    path.pop();
    path.shift();
    if (path.length === 0) {
      const newPath = [...token2.path];
      newPath.shift();
      path = newPath;
    }
    if (path.length === 0) {
      return {};
    }
    const roots = path.reduce((acc, _, i, arr) => {
      const next2 = arr.slice(0, i + 1);
      acc.push(next2);
      return acc;
    }, []);
    const root2 = path[0];
    const value = dict.formatTokenName(path);
    const keys = token2.path.slice(token2.path.indexOf(root2) + 1).reduce((acc, _, i, arr) => {
      acc.push(arr.slice(i));
      return acc;
    }, []);
    if (keys.length === 0) {
      keys.push([""]);
    }
    return {
      colorPalette: { value, roots, keys }
    };
  }
};
const tokenTransforms = [
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];
const isToken = (value) => {
  return isObject$3(value) && Object.prototype.hasOwnProperty.call(value, "value");
};
function expandBreakpoints(breakpoints2) {
  if (!breakpoints2) return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints2, (value) => ({ value })),
    sizes: Object.fromEntries(
      Object.entries(breakpoints2).map(([key, value]) => [
        `breakpoint-${key}`,
        { value }
      ])
    )
  };
}
function createTokenDictionary(options) {
  const {
    prefix: prefix2 = "",
    tokens = {},
    semanticTokens = {},
    breakpoints: breakpoints2 = {}
  } = options;
  const formatTokenName = (path) => path.join(".");
  const formatCssVar = (path, prefix22) => cssVar(path.join("-"), { prefix: prefix22 });
  const allTokens = [];
  const tokenNameMap = /* @__PURE__ */ new Map();
  const conditionMap = /* @__PURE__ */ new Map();
  const cssVarMap = /* @__PURE__ */ new Map();
  const colorPaletteMap = /* @__PURE__ */ new Map();
  const flatMap = /* @__PURE__ */ new Map();
  const byCategory = /* @__PURE__ */ new Map();
  const categoryMap = /* @__PURE__ */ new Map();
  const transforms = /* @__PURE__ */ new Map();
  const middlewares = [];
  function registerToken(token2, phase) {
    allTokens.push(token2);
    tokenNameMap.set(token2.name, token2);
    if (phase) {
      transforms.forEach((fn) => {
        if (fn.enforce === phase) transformToken(fn, token2);
      });
    }
  }
  const breakpointTokens = expandBreakpoints(breakpoints2);
  const computedTokens = compact$2({
    ...tokens,
    breakpoints: breakpointTokens.breakpoints,
    sizes: {
      ...tokens.sizes,
      ...breakpointTokens.sizes
    }
  });
  function registerTokens() {
    walkObject(
      computedTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterDefault(path);
        const category = path[0];
        const name = formatTokenName(path);
        const t2 = isString$1(entry) ? { value: entry } : entry;
        const token2 = {
          value: t2.value,
          originalValue: t2.value,
          name,
          path,
          extensions: {
            condition: "base",
            originalPath: path,
            category,
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
    walkObject(
      semanticTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterBaseCondition(filterDefault(path));
        const category = path[0];
        const name = formatTokenName(path);
        const t2 = isString$1(entry.value) ? { value: { base: entry.value } } : entry;
        const token2 = {
          value: t2.value.base || "",
          originalValue: t2.value.base || "",
          name,
          path,
          extensions: {
            originalPath: path,
            category,
            conditions: t2.value,
            condition: "base",
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
  }
  function getByName(name) {
    return tokenNameMap.get(name);
  }
  function buildConditionMap(token2) {
    const { condition } = token2.extensions;
    if (!condition) return;
    if (!conditionMap.has(condition)) {
      conditionMap.set(condition, /* @__PURE__ */ new Set());
    }
    conditionMap.get(condition).add(token2);
  }
  function buildCategoryMap(token2) {
    const { category, prop } = token2.extensions;
    if (!category) return;
    if (!categoryMap.has(category)) {
      categoryMap.set(category, /* @__PURE__ */ new Map());
    }
    categoryMap.get(category).set(prop, token2);
  }
  function buildCssVars(token2) {
    const { condition, negative, virtual, cssVar: cssVar2 } = token2.extensions;
    if (negative || virtual || !condition || !cssVar2) return;
    if (!cssVarMap.has(condition)) {
      cssVarMap.set(condition, /* @__PURE__ */ new Map());
    }
    cssVarMap.get(condition).set(cssVar2.var, token2.value);
  }
  function buildFlatMap(token2) {
    const { category, prop, cssVar: cssVar2, negative } = token2.extensions;
    if (!category) return;
    if (!byCategory.has(category)) {
      byCategory.set(category, /* @__PURE__ */ new Map());
    }
    const value = negative ? token2.extensions.conditions ? token2.originalValue : token2.value : cssVar2.ref;
    byCategory.get(category).set(prop, value);
    flatMap.set([category, prop].join("."), value);
  }
  function buildColorPalette(token2) {
    const { colorPalette, virtual, default: isDefault } = token2.extensions;
    if (!colorPalette || virtual) return;
    colorPalette.roots.forEach((root2) => {
      var _a2;
      const name = formatTokenName(root2);
      if (!colorPaletteMap.has(name)) {
        colorPaletteMap.set(name, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette(
        [...token2.path],
        [...root2]
      );
      const virtualName = formatTokenName(virtualPath);
      const virtualToken = getByName(virtualName);
      if (!virtualToken || !virtualToken.extensions.cssVar) return;
      const { var: virtualVar } = virtualToken.extensions.cssVar;
      colorPaletteMap.get(name).set(virtualVar, token2.extensions.cssVar.ref);
      if (isDefault && root2.length === 1) {
        const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = getByName(colorPaletteName);
        if (!colorPaletteToken) return;
        const name2 = formatTokenName(token2.path);
        const virtualToken2 = getByName(name2);
        if (!virtualToken2) return;
        const keyPath = (_a2 = colorPalette.keys[0]) == null ? void 0 : _a2.filter(Boolean);
        if (!keyPath.length) return;
        const computedName = formatTokenName(root2.concat(keyPath));
        if (!colorPaletteMap.has(computedName)) {
          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());
        }
        colorPaletteMap.get(computedName).set(
          colorPaletteToken.extensions.cssVar.var,
          virtualToken2.extensions.cssVar.ref
        );
      }
    });
  }
  let byCategoryJson = {};
  function setupViews() {
    allTokens.forEach((token2) => {
      buildConditionMap(token2);
      buildCategoryMap(token2);
      buildCssVars(token2);
      buildFlatMap(token2);
      buildColorPalette(token2);
    });
    byCategoryJson = mapToJson(byCategory);
  }
  const colorMix2 = (value, tokenFn) => {
    var _a2;
    if (!value || typeof value !== "string") return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = (_a2 = getByName(`opacity.${rawOpacity}`)) == null ? void 0 : _a2.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  const getVar = memo((value, fallback2) => {
    return flatMap.get(value) ?? fallback2;
  });
  const getCategoryValues = memo((category) => {
    return byCategoryJson[category] || null;
  });
  const expandReferenceInValue = memo((value) => {
    return expandTokenReferences(value, (path) => {
      if (!path) return;
      if (path.includes("/")) {
        const mix = colorMix2(path, (v2) => getVar(v2));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = getVar(path);
      if (resolved) return resolved;
      return TOKEN_PATH_REGEX.test(path) ? esc(path) : path;
    });
  });
  const dictionary = {
    prefix: prefix2,
    allTokens,
    tokenMap: tokenNameMap,
    registerToken,
    getByName,
    formatTokenName,
    formatCssVar,
    flatMap,
    cssVarMap,
    categoryMap,
    colorPaletteMap,
    getVar,
    getCategoryValues,
    expandReferenceInValue
  };
  function registerTransform(...fns) {
    fns.forEach((fn) => {
      transforms.set(fn.name, fn);
    });
  }
  function registerMiddleware(...fns) {
    middlewares.push(...fns);
  }
  function transformToken(transform2, token2) {
    if (token2.extensions.references) return;
    if (isFunction$1(transform2.match) && !transform2.match(token2)) return;
    const fn = (v2) => transform2.transform(v2, dictionary);
    const transformed = fn(token2);
    switch (true) {
      case transform2.type === "extensions":
        Object.assign(token2.extensions, transformed);
        break;
      case transform2.type === "value":
        token2.value = transformed;
        break;
      default:
        token2[transform2.type] = transformed;
        break;
    }
  }
  function applyMiddlewares(enforce) {
    middlewares.forEach((middleware2) => {
      if (middleware2.enforce === enforce) {
        middleware2.transform(dictionary);
      }
    });
  }
  function applyTransforms(enforce) {
    transforms.forEach((transform2) => {
      if (transform2.enforce === enforce) {
        allTokens.forEach((token2) => {
          transformToken(transform2, token2);
        });
      }
    });
  }
  function addConditionalTokens() {
    allTokens.forEach((token2) => {
      const tokens2 = getConditionalTokens(token2);
      if (!tokens2 || tokens2.length === 0) return;
      tokens2.forEach((token22) => {
        registerToken(token22);
      });
    });
  }
  function getTokenReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref2) => getByName(ref2)).filter(Boolean);
  }
  function addReferences() {
    allTokens.forEach((token2) => {
      if (!hasReference(token2.value)) return;
      const references = getTokenReferences(token2.value);
      token2.extensions.references = references.reduce((acc, ref2) => {
        acc[ref2.name] = ref2;
        return acc;
      }, {});
    });
  }
  function expandTokenReferences$1() {
    allTokens.forEach((token2) => {
      expandReferences(token2);
    });
  }
  function build2() {
    applyMiddlewares("pre");
    applyTransforms("pre");
    addConditionalTokens();
    addReferences();
    expandTokenReferences$1();
    applyMiddlewares("post");
    applyTransforms("post");
    setupViews();
  }
  registerTokens();
  registerTransform(...tokenTransforms);
  registerMiddleware(...tokenMiddlewares);
  build2();
  return dictionary;
}
function filterDefault(path) {
  if (path[0] === "DEFAULT") return path;
  return path.filter((item2) => item2 !== "DEFAULT");
}
function filterBaseCondition(path) {
  return path.filter((item2) => item2 !== "base");
}
function getConditionalTokens(token2) {
  if (!token2.extensions.conditions) return;
  const { conditions } = token2.extensions;
  const tokens = [];
  walkObject(conditions, (value, path) => {
    const nextPath = filterBaseCondition(path);
    if (!nextPath.length) return;
    const nextToken = structuredClone(token2);
    nextToken.value = value;
    nextToken.extensions.condition = nextPath.join(":");
    tokens.push(nextToken);
  });
  return tokens;
}
function replaceRootWithColorPalette(path, roots) {
  const startIndex = path.findIndex(
    (_, index) => roots.every(
      (rootElement, rootIndex) => path[index + rootIndex] === rootElement
    )
  );
  if (startIndex === -1) {
    return path;
  }
  path.splice(startIndex, roots.length);
  path.splice(startIndex, 0, "colorPalette");
  return path;
}
createProps$1()([
  "aspectRatios",
  "zIndex",
  "opacity",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "lineHeights",
  "letterSpacings",
  "sizes",
  "shadows",
  "spacing",
  "radii",
  "cursor",
  "borders",
  "borderWidths",
  "borderStyles",
  "durations",
  "easings",
  "animations",
  "blurs",
  "gradients",
  "breakpoints",
  "assets"
]);
function normalize(config2) {
  return config2;
}
function normalizeConfig(config2) {
  return Object.fromEntries(
    Object.entries(config2).map(([property, propertyConfig]) => {
      return [property, normalize(propertyConfig)];
    })
  );
}
function createUtility(options) {
  const configs = normalizeConfig(options.config);
  const tokens = options.tokens;
  const shorthands = /* @__PURE__ */ new Map();
  const propValues = /* @__PURE__ */ new Map();
  function register(property, config2) {
    configs[property] = normalize(config2);
    assignProperty(property, config2);
  }
  const assignProperty = (property, config2) => {
    const values = getPropertyValues(config2);
    if (!values) return;
    propValues.set(property, values);
    assignPropertyType(property, config2);
  };
  const assignProperties = () => {
    for (const [prop, config2] of Object.entries(configs)) {
      if (!config2) continue;
      assignProperty(prop, config2);
    }
  };
  const assignShorthands = () => {
    for (const [property, config2] of Object.entries(configs)) {
      const { shorthand } = config2 ?? {};
      if (!shorthand) continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((name) => shorthands.set(name, property));
    }
  };
  const assignColorPaletteProperty = () => {
    const values = mapToJson(tokens.colorPaletteMap);
    register("colorPalette", {
      values: Object.keys(values),
      transform: memo((value) => values[value])
    });
  };
  const propTypes = /* @__PURE__ */ new Map();
  const assignPropertyType = (property, config2) => {
    if (!config2) return;
    const values = getPropertyValues(config2, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      propTypes.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      propTypes.set(property, keys2);
    }
    const set2 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    if (config2.property) {
      propTypes.set(property, set2.add(`CssProperties["${config2.property}"]`));
    }
  };
  const assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(configs)) {
      if (!propertyConfig) continue;
      assignPropertyType(property, propertyConfig);
    }
  };
  const addPropertyType = (property, type) => {
    const set2 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    propTypes.set(property, /* @__PURE__ */ new Set([...set2, ...type]));
  };
  const getTypes = () => {
    const map = /* @__PURE__ */ new Map();
    for (const [prop, values] of propTypes.entries()) {
      if (values.size === 0) {
        map.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(values).map((key) => {
        if (key.startsWith("CssProperties")) return key;
        if (key.startsWith("type:")) return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map.set(prop, typeValues);
    }
    return map;
  };
  const getPropertyValues = (config2, resolveFn) => {
    const { values } = config2;
    const fn = (key) => {
      const value = resolveFn == null ? void 0 : resolveFn(key);
      return value ? { [value]: value } : void 0;
    };
    if (isString$1(values)) {
      return (fn == null ? void 0 : fn(values)) ?? tokens.getCategoryValues(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if (isFunction$1(values)) {
      return values(resolveFn ? fn : tokens.getCategoryValues);
    }
    return values;
  };
  const defaultTransform = memo((prop, value) => {
    return {
      [prop]: prop.startsWith("--") ? tokens.getVar(value, value) : value
    };
  });
  const tokenFn = Object.assign(tokens.getVar, {
    raw: (path) => tokens.getByName(path)
  });
  const transform2 = memo((prop, raw) => {
    var _a2;
    const key = resolveShorthand(prop);
    if (isString$1(raw) && !raw.includes("_EMO_")) {
      raw = tokens.expandReferenceInValue(raw);
    }
    const config2 = configs[key];
    if (!config2) {
      return defaultTransform(key, raw);
    }
    const value = (_a2 = propValues.get(key)) == null ? void 0 : _a2[raw];
    if (!config2.transform) {
      return defaultTransform(prop, value ?? raw);
    }
    const _colorMix = (value2) => colorMix(value2, tokenFn);
    return config2.transform(value ?? raw, {
      raw,
      token: tokenFn,
      utils: { colorMix: _colorMix }
    });
  });
  function build2() {
    assignShorthands();
    assignColorPaletteProperty();
    assignProperties();
    assignPropertyTypes();
  }
  build2();
  const hasShorthand = shorthands.size > 0;
  const resolveShorthand = memo((prop) => {
    return shorthands.get(prop) ?? prop;
  });
  const keys = () => {
    return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
  };
  const instance = {
    keys,
    hasShorthand,
    transform: transform2,
    shorthands,
    resolveShorthand,
    register,
    getTypes,
    addPropertyType
  };
  return instance;
}
function createSystem(...configs) {
  const config2 = mergeConfigs(...configs);
  const {
    theme = {},
    utilities = {},
    globalCss: globalCss2 = {},
    cssVarsRoot = ":where(:root, :host)",
    cssVarsPrefix = "chakra",
    preflight
  } = config2;
  const layers = createLayers(config2);
  const tokens = createTokenDictionary({
    breakpoints: theme.breakpoints,
    tokens: theme.tokens,
    semanticTokens: theme.semanticTokens,
    prefix: cssVarsPrefix
  });
  const breakpoints2 = createBreakpoints(theme.breakpoints ?? {});
  const conditions = createConditions({
    conditions: config2.conditions ?? {},
    breakpoints: breakpoints2
  });
  const utility = createUtility({
    config: utilities,
    tokens
  });
  function assignComposition() {
    const { textStyles: textStyles2, layerStyles: layerStyles2, animationStyles: animationStyles2 } = theme;
    const compositions = compact$2({
      textStyle: textStyles2,
      layerStyle: layerStyles2,
      animationStyle: animationStyles2
    });
    for (const [key, values] of Object.entries(compositions)) {
      const flatValues = flatten(
        values ?? {},
        (v2) => isObject$3(v2) && "value" in v2
      );
      utility.register(key, {
        values: Object.keys(flatValues),
        transform(value) {
          return css2(flatValues[value]);
        }
      });
    }
  }
  assignComposition();
  utility.addPropertyType("animationName", Object.keys(theme.keyframes ?? {}));
  const properties2 = /* @__PURE__ */ new Set(["css", ...utility.keys(), ...conditions.keys()]);
  const isValidProperty = memo(
    (prop) => properties2.has(prop) || isCssProperty(prop)
  );
  const normalizeValue = (value) => {
    if (Array.isArray(value)) {
      return value.reduce((acc, current, index) => {
        const key = conditions.breakpoints[index];
        if (current != null) acc[key] = current;
        return acc;
      }, {});
    }
    return value;
  };
  const normalizeFn = createNormalizeFn({
    utility,
    normalize: normalizeValue
  });
  const serialize2 = createSerializeFn({
    conditions,
    isValidProperty
  });
  const css2 = createCssFn({
    transform: utility.transform,
    conditions,
    normalize: normalizeFn
  });
  const cva = createRecipeFn({
    css: css2,
    conditions,
    normalize: normalizeFn,
    layers
  });
  const sva = createSlotRecipeFn({ cva });
  function getTokenCss() {
    const result = {};
    for (const [key, values] of tokens.cssVarMap.entries()) {
      const varsObj = Object.fromEntries(values);
      if (Object.keys(varsObj).length === 0) continue;
      if (key === "base") {
        const cssObj = css2(serialize2({ [cssVarsRoot]: varsObj }));
        mergeWith(result, cssObj);
      } else {
        const cssObject = css2(serialize2({ [key]: varsObj }));
        mergeWith(result, cssObject);
      }
    }
    return layers.wrap("tokens", result);
  }
  function getGlobalCss() {
    const keyframes2 = Object.fromEntries(
      Object.entries(theme.keyframes ?? {}).map(([key, value]) => [
        `@keyframes ${key}`,
        value
      ])
    );
    const result = Object.assign({}, keyframes2, css2(serialize2(globalCss2)));
    return layers.wrap("base", result);
  }
  function splitCssProps(props) {
    return splitProps(props, isValidProperty);
  }
  function getPreflightCss() {
    const result = createPreflight({ preflight });
    return layers.wrap("reset", result);
  }
  const tokenMap = getTokenMap(tokens);
  const tokenFn = (path, fallback2) => {
    var _a2;
    return ((_a2 = tokenMap.get(path)) == null ? void 0 : _a2.value) || fallback2;
  };
  tokenFn.var = (path, fallback2) => {
    var _a2;
    return ((_a2 = tokenMap.get(path)) == null ? void 0 : _a2.variable) || fallback2;
  };
  function getRecipe(key, fallback2) {
    var _a2;
    return ((_a2 = theme.recipes) == null ? void 0 : _a2[key]) ?? fallback2;
  }
  function getSlotRecipe(key, fallback2) {
    var _a2;
    return ((_a2 = theme.slotRecipes) == null ? void 0 : _a2[key]) ?? fallback2;
  }
  function isRecipe(key) {
    return Object.hasOwnProperty.call(theme.recipes ?? {}, key);
  }
  function isSlotRecipe(key) {
    return Object.hasOwnProperty.call(theme.slotRecipes ?? {}, key);
  }
  function hasRecipe(key) {
    return isRecipe(key) || isSlotRecipe(key);
  }
  return {
    $$chakra: true,
    _config: config2,
    breakpoints: breakpoints2,
    tokens,
    conditions,
    utility,
    token: tokenFn,
    properties: properties2,
    layers,
    isValidProperty,
    splitCssProps,
    normalizeValue,
    getTokenCss,
    getGlobalCss,
    getPreflightCss,
    css: css2,
    cva,
    sva,
    getRecipe,
    getSlotRecipe,
    hasRecipe,
    isRecipe,
    isSlotRecipe
  };
}
function getTokenMap(tokens) {
  const map = /* @__PURE__ */ new Map();
  tokens.allTokens.forEach((token2) => {
    const { cssVar: cssVar2, virtual, conditions } = token2.extensions;
    const value = !!conditions || virtual ? cssVar2.ref : token2.value;
    map.set(token2.name, { value, variable: cssVar2.ref });
  });
  return map;
}
const breakpoints = {
  sm: "480px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px"
};
const empty = "var(--chakra-empty,/*!*/ /*!*/)";
const globalCss = defineGlobalStyles({
  "*": {
    fontFeatureSettings: '"cv11"',
    "--ring-inset": empty,
    "--ring-offset-width": "0px",
    "--ring-offset-color": "#fff",
    "--ring-color": "rgba(66, 153, 225, 0.6)",
    "--ring-offset-shadow": "0 0 #0000",
    "--ring-shadow": "0 0 #0000",
    ...Object.fromEntries(
      [
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "saturate",
        "sepia",
        "drop-shadow"
      ].map((prop) => [`--${prop}`, empty])
    ),
    ...Object.fromEntries(
      [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "opacity",
        "saturate",
        "sepia"
      ].map((prop) => [`--backdrop-${prop}`, empty])
    ),
    "--global-font-mono": "fonts.mono",
    "--global-font-body": "fonts.body",
    "--global-color-border": "colors.border"
  },
  html: {
    color: "fg",
    bg: "bg",
    lineHeight: "1.5",
    colorPalette: "gray"
  },
  "*::placeholder": {
    color: "fg.muted/80"
  },
  "*::selection": {
    bg: "colorPalette.muted/80"
  }
});
const layerStyles = defineLayerStyles({
  // fill: some background color + color combination
  "fill.muted": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg"
    }
  },
  "fill.subtle": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  },
  "fill.surface": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg",
      boxShadow: "0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.muted"
    }
  },
  "fill.solid": {
    value: {
      background: "colorPalette.solid",
      color: "colorPalette.contrast"
    }
  },
  // outline: some border color + color combination
  "outline.subtle": {
    value: {
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "outline.solid": {
    value: {
      borderWidth: "1px",
      borderColor: "colorPalette.solid",
      color: "colorPalette.fg"
    }
  },
  // indicator: floating border color or left/bottom border
  "indicator.bottom": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        bottom: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.top": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        top: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.start": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineStart: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.end": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineEnd: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  disabled: {
    value: {
      opacity: "0.5",
      cursor: "not-allowed"
    }
  },
  none: {
    value: {}
  }
});
const animationStyles = defineAnimationStyles({
  "slide-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-from-bottom, fade-in"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-from-top, fade-in"
      },
      "&[data-placement^=left]": {
        animationName: "slide-from-right, fade-in"
      },
      "&[data-placement^=right]": {
        animationName: "slide-from-left, fade-in"
      }
    }
  },
  "slide-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-to-bottom, fade-out"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-to-top, fade-out"
      },
      "&[data-placement^=left]": {
        animationName: "slide-to-right, fade-out"
      },
      "&[data-placement^=right]": {
        animationName: "slide-to-left, fade-out"
      }
    }
  },
  "scale-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-in, fade-in"
    }
  },
  "scale-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-out, fade-out"
    }
  }
});
const badgeRecipe = defineRecipe({
  className: "chakra-badge",
  base: {
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "l2",
    gap: "1",
    fontWeight: "medium",
    fontVariantNumeric: "tabular-nums",
    whiteSpace: "nowrap",
    userSelect: "none"
  },
  variants: {
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg"
      },
      outline: {
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      xs: {
        textStyle: "2xs",
        px: "1",
        minH: "4"
      },
      sm: {
        textStyle: "xs",
        px: "1.5",
        minH: "5"
      },
      md: {
        textStyle: "sm",
        px: "2",
        minH: "6"
      },
      lg: {
        textStyle: "sm",
        px: "2.5",
        minH: "7"
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    size: "sm"
  }
});
const buttonRecipe$1 = defineRecipe({
  className: "chakra-button",
  base: {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    position: "relative",
    borderRadius: "l2",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    borderWidth: "1px",
    borderColor: "transparent",
    cursor: "button",
    flexShrink: "0",
    outline: "0",
    lineHeight: "1.2",
    isolation: "isolate",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "moderate",
    focusVisibleRing: "outside",
    _disabled: {
      layerStyle: "disabled"
    },
    _icon: {
      flexShrink: "0"
    }
  },
  variants: {
    size: {
      "2xs": {
        h: "6",
        minW: "6",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "3.5",
          height: "3.5"
        }
      },
      xs: {
        h: "8",
        minW: "8",
        textStyle: "xs",
        px: "2.5",
        gap: "1",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      sm: {
        h: "9",
        minW: "9",
        px: "3.5",
        textStyle: "sm",
        gap: "2",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      md: {
        h: "10",
        minW: "10",
        textStyle: "sm",
        px: "4",
        gap: "2",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      lg: {
        h: "11",
        minW: "11",
        textStyle: "md",
        px: "5",
        gap: "3",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      xl: {
        h: "12",
        minW: "12",
        textStyle: "md",
        px: "5",
        gap: "2.5",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      "2xl": {
        h: "16",
        minW: "16",
        textStyle: "lg",
        px: "7",
        gap: "3",
        _icon: {
          width: "6",
          height: "6"
        }
      }
    },
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast",
        _hover: {
          bg: "colorPalette.solid/90"
        },
        _expanded: {
          bg: "colorPalette.solid/90"
        }
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "colorPalette.muted",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      ghost: {
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      plain: {
        color: "colorPalette.fg"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});
const checkmarkRecipe = defineRecipe({
  className: "chakra-checkmark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "l1",
    focusVisibleRing: "outside",
    _icon: {
      boxSize: "full"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "border.error"
    },
    _disabled: {
      opacity: "0.5"
    }
  },
  variants: {
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5",
        p: "0.5"
      },
      lg: {
        boxSize: "6",
        p: "0.5"
      }
    },
    variant: {
      solid: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      outline: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      plain: {
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      inverted: {
        borderColor: "border",
        color: "colorPalette.fg",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          borderColor: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const { variants: variants$1, defaultVariants: defaultVariants$1 } = badgeRecipe;
const codeRecipe = defineRecipe({
  className: "chakra-code",
  base: {
    fontFamily: "mono",
    alignItems: "center",
    display: "inline-flex",
    borderRadius: "l2"
  },
  variants: variants$1,
  defaultVariants: defaultVariants$1
});
const containerRecipe = defineRecipe({
  className: "chakra-container",
  base: {
    position: "relative",
    maxWidth: "8xl",
    w: "100%",
    mx: "auto",
    px: { base: "4", md: "6", lg: "8" }
  },
  variants: {
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    },
    fluid: {
      true: {
        maxWidth: "full"
      }
    }
  }
});
const headingRecipe = defineRecipe({
  className: "chakra-heading",
  base: {
    fontFamily: "heading",
    fontWeight: "semibold"
  },
  variants: {
    size: {
      xs: { textStyle: "xs" },
      sm: { textStyle: "sm" },
      md: { textStyle: "md" },
      lg: { textStyle: "lg" },
      xl: { textStyle: "xl" },
      "2xl": { textStyle: "2xl" },
      "3xl": { textStyle: "3xl" },
      "4xl": { textStyle: "4xl" },
      "5xl": { textStyle: "5xl" },
      "6xl": { textStyle: "6xl" },
      "7xl": { textStyle: "7xl" }
    }
  },
  defaultVariants: {
    size: "xl"
  }
});
const iconRecipe = defineRecipe({
  className: "chakra-icon",
  base: {
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: "0",
    color: "currentcolor",
    verticalAlign: "middle",
    width: "var(--icon-size)",
    height: "var(--icon-size)"
  },
  variants: {
    size: {
      inherit: { "--icon-size": "1em" },
      xs: { "--icon-size": "sizes.3" },
      sm: { "--icon-size": "sizes.4" },
      md: { "--icon-size": "sizes.5" },
      lg: { "--icon-size": "sizes.6" },
      xl: { "--icon-size": "sizes.7" },
      "2xl": { "--icon-size": "sizes.8" }
    }
  },
  defaultVariants: {
    size: "inherit"
  }
});
const inputRecipe = defineRecipe({
  className: "chakra-input",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    height: "var(--input-height)",
    minW: "var(--input-height)",
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      "2xs": {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.7"
      },
      xs: {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.8"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        "--input-height": "sizes.9"
      },
      md: {
        textStyle: "sm",
        px: "3",
        "--input-height": "sizes.10"
      },
      lg: {
        textStyle: "md",
        px: "4",
        "--input-height": "sizes.11"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        "--input-height": "sizes.12"
      },
      "2xl": {
        textStyle: "lg",
        px: "5",
        "--input-height": "sizes.16"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const inputAddonRecipe = defineRecipe({
  className: "chakra-input-addon",
  base: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap",
    alignSelf: "stretch",
    borderRadius: "l2"
  },
  variants: {
    size: inputRecipe.variants.size,
    variant: {
      outline: {
        borderWidth: "1px",
        borderColor: "border",
        bg: "bg.muted"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.emphasized"
      },
      flushed: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const kbdRecipe = defineRecipe({
  className: "chakra-kbd",
  base: {
    display: "inline-flex",
    alignItems: "center",
    fontWeight: "medium",
    fontFamily: "mono",
    flexShrink: "0",
    whiteSpace: "nowrap",
    wordSpacing: "-0.5em",
    userSelect: "none",
    px: "1",
    borderRadius: "l2"
  },
  variants: {
    variant: {
      raised: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderWidth: "1px",
        borderBottomWidth: "2px",
        borderColor: "colorPalette.muted"
      },
      outline: {
        borderWidth: "1px",
        color: "colorPalette.fg"
      },
      subtle: {
        bg: "colorPalette.muted",
        color: "colorPalette.fg"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      sm: {
        textStyle: "xs",
        height: "4.5"
      },
      md: {
        textStyle: "sm",
        height: "5"
      },
      lg: {
        textStyle: "md",
        height: "6"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "raised"
  }
});
const linkRecipe$1 = defineRecipe({
  className: "chakra-link",
  base: {
    display: "inline-flex",
    alignItems: "center",
    outline: "none",
    gap: "1.5",
    cursor: "pointer",
    borderRadius: "l1",
    focusRing: "outside"
  },
  variants: {
    variant: {
      underline: {
        color: "colorPalette.fg",
        textDecoration: "underline",
        textUnderlineOffset: "3px",
        textDecorationColor: "currentColor/20"
      },
      plain: {
        color: "colorPalette.fg",
        _hover: {
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain"
  }
});
const markRecipe = defineRecipe({
  className: "chakra-mark",
  base: {
    bg: "transparent",
    color: "inherit",
    whiteSpace: "nowrap"
  },
  variants: {
    variant: {
      subtle: {
        bg: "colorPalette.subtle",
        color: "inherit"
      },
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      text: {
        fontWeight: "medium"
      },
      plain: {}
    }
  }
});
const radiomarkRecipe = defineRecipe({
  className: "chakra-radiomark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    verticalAlign: "top",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "full",
    cursor: "radio",
    _focusVisible: {
      outline: "2px solid",
      outlineColor: "colorPalette.focusRing",
      outlineOffset: "2px"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "red.500"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    },
    "& .dot": {
      height: "100%",
      width: "100%",
      borderRadius: "full",
      bg: "currentColor",
      scale: "0.4"
    }
  },
  variants: {
    variant: {
      solid: {
        borderWidth: "1px",
        borderColor: "border",
        _checked: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        borderWidth: "1px",
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        color: "transparent",
        _checked: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        },
        "& .dot": {
          scale: "0.6"
        }
      },
      inverted: {
        bg: "bg",
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.solid",
          borderColor: "currentcolor"
        }
      }
    },
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5"
      },
      lg: {
        boxSize: "6"
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const separatorRecipe = defineRecipe({
  className: "chakra-separator",
  base: {
    display: "block",
    borderColor: "border"
  },
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        height: "100%",
        borderInlineStartWidth: "var(--separator-thickness)"
      },
      horizontal: {
        width: "100%",
        borderTopWidth: "var(--separator-thickness)"
      }
    },
    size: {
      xs: {
        "--separator-thickness": "0.5px"
      },
      sm: {
        "--separator-thickness": "1px"
      },
      md: {
        "--separator-thickness": "2px"
      },
      lg: {
        "--separator-thickness": "3px"
      }
    }
  },
  defaultVariants: {
    size: "sm",
    variant: "solid",
    orientation: "horizontal"
  }
});
const skeletonRecipe = defineRecipe({
  className: "chakra-skeleton",
  base: {},
  variants: {
    loading: {
      true: {
        borderRadius: "l2",
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        flexShrink: "0",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      },
      false: {
        background: "unset",
        animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
      }
    },
    variant: {
      pulse: {
        background: "bg.emphasized",
        animation: "pulse",
        animationDuration: "var(--duration, 1.2s)"
      },
      shine: {
        "--animate-from": "200%",
        "--animate-to": "-200%",
        "--start-color": "colors.bg.muted",
        "--end-color": "colors.bg.emphasized",
        backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
        backgroundSize: "400% 100%",
        animation: "bg-position var(--duration, 5s) ease-in-out infinite"
      },
      none: {
        animation: "none"
      }
    }
  },
  defaultVariants: {
    variant: "pulse",
    loading: true
  }
});
const skipNavLinkRecipe = defineRecipe({
  className: "chakra-skip-nav",
  base: {
    display: "inline-flex",
    bg: "bg.panel",
    padding: "2.5",
    borderRadius: "l2",
    fontWeight: "semibold",
    focusVisibleRing: "outside",
    textStyle: "sm",
    // visually hidden
    userSelect: "none",
    border: "0",
    height: "1px",
    width: "1px",
    margin: "-1px",
    outline: "0",
    overflow: "hidden",
    position: "absolute",
    clip: "rect(0 0 0 0)",
    _focusVisible: {
      clip: "auto",
      width: "auto",
      height: "auto",
      position: "fixed",
      top: "6",
      insetStart: "6"
    }
  }
});
const spinnerRecipe = defineRecipe({
  className: "chakra-spinner",
  base: {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderWidth: "2px",
    borderRadius: "full",
    width: "var(--spinner-size)",
    height: "var(--spinner-size)",
    animation: "spin",
    animationDuration: "slowest",
    "--spinner-track-color": "transparent",
    borderBottomColor: "var(--spinner-track-color)",
    borderInlineStartColor: "var(--spinner-track-color)"
  },
  variants: {
    size: {
      inherit: { "--spinner-size": "1em" },
      xs: { "--spinner-size": "sizes.3" },
      sm: { "--spinner-size": "sizes.4" },
      md: { "--spinner-size": "sizes.5" },
      lg: { "--spinner-size": "sizes.8" },
      xl: { "--spinner-size": "sizes.10" }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const textareaRecipe = defineRecipe({
  className: "chakra-textarea",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      xs: {
        textStyle: "xs",
        px: "2",
        py: "1.5",
        scrollPaddingBottom: "1.5"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        py: "2",
        scrollPaddingBottom: "2"
      },
      md: {
        textStyle: "sm",
        px: "3",
        py: "2",
        scrollPaddingBottom: "2"
      },
      lg: {
        textStyle: "md",
        px: "4",
        py: "3",
        scrollPaddingBottom: "3"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        py: "3.5",
        scrollPaddingBottom: "3.5"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const recipes = {
  badge: badgeRecipe,
  button: buttonRecipe$1,
  code: codeRecipe,
  container: containerRecipe,
  heading: headingRecipe,
  input: inputRecipe,
  inputAddon: inputAddonRecipe,
  kbd: kbdRecipe,
  link: linkRecipe$1,
  mark: markRecipe,
  separator: separatorRecipe,
  skeleton: skeletonRecipe,
  skipNavLink: skipNavLinkRecipe,
  spinner: spinnerRecipe,
  textarea: textareaRecipe,
  icon: iconRecipe,
  checkmark: checkmarkRecipe,
  radiomark: radiomarkRecipe
};
const semanticColors = defineSemanticTokens.colors({
  bg: {
    DEFAULT: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    inverted: {
      value: { _light: "{colors.black}", _dark: "{colors.white}" }
    },
    panel: {
      value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
    },
    error: {
      value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
    },
    warning: {
      value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
    },
    success: {
      value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
    },
    info: {
      value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
    }
  },
  fg: {
    DEFAULT: {
      value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
    },
    muted: {
      value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
    },
    subtle: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
    },
    inverted: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
    },
    success: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
    },
    info: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
    }
  },
  border: {
    DEFAULT: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    inverted: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
    },
    success: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
    },
    info: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
    }
  },
  gray: {
    contrast: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    fg: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    subtle: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    muted: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    solid: {
      value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
    },
    focusRing: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    }
  },
  red: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
    },
    subtle: {
      value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
    },
    muted: {
      value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
    },
    emphasized: {
      value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
    },
    solid: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    },
    focusRing: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    }
  },
  orange: {
    contrast: {
      value: { _light: "white", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
    },
    subtle: {
      value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
    },
    muted: {
      value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
    },
    emphasized: {
      value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
    },
    solid: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    },
    focusRing: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    }
  },
  green: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
    },
    subtle: {
      value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
    },
    muted: {
      value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
    },
    emphasized: {
      value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
    },
    solid: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    },
    focusRing: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    }
  },
  blue: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
    },
    subtle: {
      value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
    },
    muted: {
      value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
    },
    emphasized: {
      value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
    },
    solid: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    },
    focusRing: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    }
  },
  yellow: {
    contrast: {
      value: { _light: "black", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
    },
    subtle: {
      value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
    },
    muted: {
      value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
    },
    emphasized: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
    },
    solid: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    },
    focusRing: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    }
  },
  teal: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
    },
    subtle: {
      value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
    },
    muted: {
      value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
    },
    emphasized: {
      value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
    },
    solid: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    },
    focusRing: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    }
  },
  purple: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
    },
    subtle: {
      value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
    },
    muted: {
      value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
    },
    emphasized: {
      value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
    },
    solid: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    },
    focusRing: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    }
  },
  pink: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
    },
    subtle: {
      value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
    },
    muted: {
      value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
    },
    emphasized: {
      value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
    },
    solid: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    },
    focusRing: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    }
  },
  cyan: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
    },
    subtle: {
      value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
    },
    muted: {
      value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
    },
    emphasized: {
      value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
    },
    solid: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    },
    focusRing: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    }
  }
});
const semanticRadii = defineSemanticTokens.radii({
  l1: { value: "{radii.xs}" },
  l2: { value: "{radii.sm}" },
  l3: { value: "{radii.md}" }
});
const semanticShadows = defineSemanticTokens.shadows({
  xs: {
    value: {
      _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
      _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
    }
  },
  sm: {
    value: {
      _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  md: {
    value: {
      _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  lg: {
    value: {
      _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  xl: {
    value: {
      _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  "2xl": {
    value: {
      _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  inner: {
    value: {
      _light: "inset 0 2px 4px 0 {black/5}",
      _dark: "inset 0 2px 4px 0 black"
    }
  },
  inset: {
    value: {
      _light: "inset 0 0 0 1px {black/5}",
      _dark: "inset 0 0 0 1px {colors.gray.300/5}"
    }
  }
});
var createAnatomy = (name, parts2 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts2)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts2, ...values]),
  rename: (newName) => createAnatomy(newName, parts2),
  keys: () => parts2,
  build: () => [...new Set(parts2)].reduce(
    (prev2, part) => Object.assign(prev2, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase$1(name)}"][data-part="${toKebabCase$1(part)}"]`,
          `& [data-scope="${toKebabCase$1(name)}"][data-part="${toKebabCase$1(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase$1(name), "data-part": toKebabCase$1(part) }
      }
    }),
    {}
  )
});
var toKebabCase$1 = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v2) => v2.length === 0;
var addDomEvent = (target, eventName, handler, options) => {
  const node2 = typeof target === "function" ? target() : target;
  node2 == null ? void 0 : node2.addEventListener(eventName, handler, options);
  return () => {
    node2 == null ? void 0 : node2.removeEventListener(eventName, handler, options);
  };
};
var isContextMenuEvent = (e2) => {
  return e2.button === 2 || isMac() && e2.ctrlKey && e2.button === 0;
};
function fireCustomEvent(el2, type, init) {
  if (!el2) return;
  const win = el2.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el2.dispatchEvent(event);
}
function clamp$2(value) {
  return Math.max(0, Math.min(1, value));
}
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset2 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp$2(offset2.x / width), y: clamp$2(offset2.y / height) };
  function getPercentValue2(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset2, percent, getPercentValue: getPercentValue2 };
}
var first = (v2) => v2[0];
var last = (v2) => v2[v2.length - 1];
function clear(v2) {
  while (v2.length > 0) v2.pop();
  return v2;
}
var runIfFn = (v2, ...a) => {
  const res = typeof v2 === "function" ? v2(...a) : v2;
  return res ?? void 0;
};
var cast = (v2) => v2;
var noop = () => {
};
var callAll = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id2 = 0;
  return () => {
    id2++;
    return id2.toString(36);
  };
})();
var isArray = (v2) => Array.isArray(v2);
var isObjectLike = (v2) => v2 != null && typeof v2 === "object";
var isObject$2 = (v2) => isObjectLike(v2) && !isArray(v2);
var isNumber = (v2) => typeof v2 === "number" && !Number.isNaN(v2);
var isString = (v2) => typeof v2 === "string";
var isFunction = (v2) => typeof v2 === "function";
var isNull = (v2) => v2 == null;
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v2) => Object.prototype.toString.call(v2);
var fnToString$1 = Function.prototype.toString;
var objectCtorString = fnToString$1.call(Object);
var isPlainObject$1 = (v2) => {
  if (!isObjectLike(v2) || baseGetTag(v2) != "[object Object]") return false;
  const proto = Object.getPrototypeOf(v2);
  if (proto === null) return true;
  const Ctor = hasProp(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString$1.call(Ctor) == objectCtorString;
};
function compact$1(obj) {
  if (!isPlainObject2(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact$1(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};
function warn(...a) {
  const m2 = a.length === 1 ? a[0] : a[1];
  const c2 = a.length === 2 ? a[0] : true;
  if (c2 && false) {
    console.warn(m2);
  }
}
function invariant(...a) {
  const m2 = a.length === 1 ? a[0] : a[1];
  const c2 = a.length === 2 ? a[0] : true;
  if (c2 && false) {
    throw new Error(m2);
  }
}
const TRACK_MEMO_SYMBOL = Symbol();
const GET_ORIGINAL_SYMBOL = Symbol();
const AFFECTED_PROPERTY = "a";
const IS_TARGET_COPIED_PROPERTY = "f";
const PROXY_PROPERTY = "p";
const PROXY_CACHE_PROPERTY = "c";
const TARGET_CACHE_PROPERTY = "t";
const NEXT_OBJECT_PROPERTY = "n";
const CHANGED_PROPERTY = "g";
const HAS_KEY_PROPERTY = "h";
const ALL_OWN_KEYS_PROPERTY = "w";
const HAS_OWN_KEY_PROPERTY = "o";
const KEYS_PROPERTY = "k";
let newProxy = (target, handler) => new Proxy(target, handler);
const getProto = Object.getPrototypeOf;
const objectsToTrack = /* @__PURE__ */ new WeakMap();
const isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
const isObject$1 = (x2) => typeof x2 === "object" && x2 !== null;
const needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
const copyTargetObject = (obj) => {
  if (Array.isArray(obj)) {
    return Array.from(obj);
  }
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  Object.values(descriptors).forEach((desc) => {
    desc.configurable = true;
  });
  return Object.create(getProto(obj), descriptors);
};
const createProxyHandler = (origObj, isTargetCopied) => {
  const state = {
    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
  };
  let trackObject = false;
  const recordUsage = (type, key) => {
    if (!trackObject) {
      let used = state[AFFECTED_PROPERTY].get(origObj);
      if (!used) {
        used = {};
        state[AFFECTED_PROPERTY].set(origObj, used);
      }
      if (type === ALL_OWN_KEYS_PROPERTY) {
        used[ALL_OWN_KEYS_PROPERTY] = true;
      } else {
        let set2 = used[type];
        if (!set2) {
          set2 = /* @__PURE__ */ new Set();
          used[type] = set2;
        }
        set2.add(key);
      }
    }
  };
  const recordObjectAsUsed = () => {
    trackObject = true;
    state[AFFECTED_PROPERTY].delete(origObj);
  };
  const handler = {
    get(target, key) {
      if (key === GET_ORIGINAL_SYMBOL) {
        return origObj;
      }
      recordUsage(KEYS_PROPERTY, key);
      return createProxy$1(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);
    },
    has(target, key) {
      if (key === TRACK_MEMO_SYMBOL) {
        recordObjectAsUsed();
        return true;
      }
      recordUsage(HAS_KEY_PROPERTY, key);
      return Reflect.has(target, key);
    },
    getOwnPropertyDescriptor(target, key) {
      recordUsage(HAS_OWN_KEY_PROPERTY, key);
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
    ownKeys(target) {
      recordUsage(ALL_OWN_KEYS_PROPERTY);
      return Reflect.ownKeys(target);
    }
  };
  if (isTargetCopied) {
    handler.set = handler.deleteProperty = () => false;
  }
  return [handler, state];
};
const getOriginalObject = (obj) => (
  // unwrap proxy
  obj[GET_ORIGINAL_SYMBOL] || // otherwise
  obj
);
const createProxy$1 = (obj, affected, proxyCache, targetCache2) => {
  if (!isObjectToTrack(obj))
    return obj;
  let targetAndCopied = targetCache2 && targetCache2.get(obj);
  if (!targetAndCopied) {
    const target2 = getOriginalObject(obj);
    if (needsToCopyTargetObject(target2)) {
      targetAndCopied = [target2, copyTargetObject(target2)];
    } else {
      targetAndCopied = [target2];
    }
    targetCache2 === null || targetCache2 === void 0 ? void 0 : targetCache2.set(obj, targetAndCopied);
  }
  const [target, copiedTarget] = targetAndCopied;
  let handlerAndState = proxyCache && proxyCache.get(target);
  if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
    handlerAndState = createProxyHandler(target, !!copiedTarget);
    handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
    if (proxyCache) {
      proxyCache.set(target, handlerAndState);
    }
  }
  handlerAndState[1][AFFECTED_PROPERTY] = affected;
  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache2;
  return handlerAndState[1][PROXY_PROPERTY];
};
const isAllOwnKeysChanged = (prevObj, nextObj) => {
  const prevKeys = Reflect.ownKeys(prevObj);
  const nextKeys = Reflect.ownKeys(nextObj);
  return prevKeys.length !== nextKeys.length || prevKeys.some((k2, i) => k2 !== nextKeys[i]);
};
const isChanged = (prevObj, nextObj, affected, cache2, isEqual2 = Object.is) => {
  if (isEqual2(prevObj, nextObj)) {
    return false;
  }
  if (!isObject$1(prevObj) || !isObject$1(nextObj))
    return true;
  const used = affected.get(getOriginalObject(prevObj));
  if (!used)
    return true;
  if (cache2) {
    const hit = cache2.get(prevObj);
    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {
      return hit[CHANGED_PROPERTY];
    }
    cache2.set(prevObj, {
      [NEXT_OBJECT_PROPERTY]: nextObj,
      [CHANGED_PROPERTY]: false
    });
  }
  let changed = null;
  try {
    for (const key of used[HAS_KEY_PROPERTY] || []) {
      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
      if (changed)
        return changed;
    }
    if (used[ALL_OWN_KEYS_PROPERTY] === true) {
      changed = isAllOwnKeysChanged(prevObj, nextObj);
      if (changed)
        return changed;
    } else {
      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
        changed = hasPrev !== hasNext;
        if (changed)
          return changed;
      }
    }
    for (const key of used[KEYS_PROPERTY] || []) {
      changed = isChanged(prevObj[key], nextObj[key], affected, cache2, isEqual2);
      if (changed)
        return changed;
    }
    if (changed === null)
      changed = true;
    return changed;
  } finally {
    if (cache2) {
      cache2.set(prevObj, {
        [NEXT_OBJECT_PROPERTY]: nextObj,
        [CHANGED_PROPERTY]: changed
      });
    }
  }
};
const getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
const markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};
function getGlobal() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function makeGlobal(key, value) {
  const g2 = getGlobal();
  if (!g2) return value();
  g2[key] || (g2[key] = value());
  return g2[key];
}
var isObject = (x2) => typeof x2 === "object" && x2 !== null;
var proxyStateMap = makeGlobal("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet = makeGlobal("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var isReactElement = (x2) => typeof x2 === "object" && x2 !== null && "$$typeof" in x2;
var isVueElement = (x2) => typeof x2 === "object" && x2 !== null && "__v_isVNode" in x2;
var isDOMElement = (x2) => typeof x2 === "object" && x2 !== null && "nodeType" in x2 && typeof x2.nodeName === "string";
var isElement$2 = (x2) => isReactElement(x2) || isVueElement(x2) || isDOMElement(x2);
var buildProxyFunction = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x2) => isObject(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !isElement$2(x2) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache2 = snapCache.get(target);
  if ((cache2 == null ? void 0 : cache2[0]) === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (listeners.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a2;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a2 = entry[1]) == null ? void 0 : _a2.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a2;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a2 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a2.set) ;
      else if (value instanceof Promise) {
        value.then((v2) => {
          Object.assign(value, { status: "fulfilled", value: v2 });
          notifyUpdate(["resolve", [prop], v2]);
        }).catch((e2) => {
          Object.assign(value, { status: "rejected", reason: e2 });
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe$1(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function proxyWithComputed(initialObject, computedFns) {
  const keys = Object.keys(computedFns);
  keys.forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get: get2, set: set2 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get2(snapshot(proxyObject));
    if (set2) {
      desc.set = (newValue) => set2(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}
function set(obj, key, val) {
  if (typeof val.value === "object") val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else obj[key] = val.value;
}
function klona(x2) {
  if (typeof x2 !== "object") return x2;
  var i = 0, k2, list, tmp, str = Object.prototype.toString.call(x2);
  if (str === "[object Object]") {
    tmp = Object.create(x2.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x2.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x2.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x2.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x2);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x2.source, x2.flags);
  } else if (str === "[object DataView]") {
    tmp = new x2.constructor(klona(x2.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x2.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x2.constructor(x2);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x2); i < list.length; i++) {
      set(tmp, list[i], Object.getOwnPropertyDescriptor(x2, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x2); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k2 = list[i]) && tmp[k2] === x2[k2]) continue;
      set(tmp, k2, Object.getOwnPropertyDescriptor(x2, k2));
    }
  }
  return tmp || x2;
}
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
function deepMerge(source, ...objects) {
  for (const obj of objects) {
    const target = compact$1(obj);
    for (const key in target) {
      if (isPlainObject$1(obj[key])) {
        if (!source[key]) {
          source[key] = {};
        }
        deepMerge(source[key], obj[key]);
      } else {
        source[key] = obj[key];
      }
    }
  }
  return source;
}
function structuredClone$1(v2) {
  return klona(v2);
}
function toEvent(event) {
  const obj = isString(event) ? { type: event } : event;
  return obj;
}
function toArray(value) {
  if (!value) return [];
  return isArray(value) ? value.slice() : [value];
}
function isGuardHelper(value) {
  return isObject$2(value) && value.predicate != null;
}
var Truthy = () => true;
function exec(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a2;
    if (isString(guard)) {
      return !!((_a2 = guardMap[guard]) == null ? void 0 : _a2.call(guardMap, ctx, event, meta));
    }
    if (isFunction(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or$1(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and$2(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not$2(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards = { or: or$1, and: and$2, not: not$2, stateIn };
function determineGuardFn(guard, guardMap) {
  guard = guard ?? Truthy;
  return (context, event, meta) => {
    if (isString(guard)) {
      const value = guardMap[guard];
      return isFunction(value) ? value(context, event, meta) : value;
    }
    if (isGuardHelper(guard)) {
      return guard.predicate(guardMap)(context, event, meta);
    }
    return guard == null ? void 0 : guard(context, event, meta);
  };
}
function determineActionsFn(values, guardMap) {
  return (context, event, meta) => {
    if (isGuardHelper(values)) {
      return values.predicate(guardMap)(context, event, meta);
    }
    return values;
  };
}
function createProxy(config2) {
  var _a2, _b2;
  const computedContext = config2.computed ?? cast({});
  const initialContext = config2.context ?? cast({});
  const initialTags = config2.initial ? (_b2 = (_a2 = config2.states) == null ? void 0 : _a2[config2.initial]) == null ? void 0 : _b2.tags : [];
  const state = proxy({
    value: config2.initial ?? "",
    previousValue: "",
    event: cast({}),
    previousEvent: cast({}),
    context: proxyWithComputed(initialContext, computedContext),
    done: false,
    tags: initialTags ?? [],
    hasTag(tag) {
      return this.tags.includes(tag);
    },
    matches(...value) {
      return value.includes(this.value);
    },
    can(event) {
      return cast(this).nextEvents.includes(event);
    },
    get nextEvents() {
      var _a3, _b3;
      const stateEvents = ((_b3 = (_a3 = config2.states) == null ? void 0 : _a3[this.value]) == null ? void 0 : _b3["on"]) ?? {};
      const globalEvents = (config2 == null ? void 0 : config2.on) ?? {};
      return Object.keys({ ...stateEvents, ...globalEvents });
    },
    get changed() {
      if (this.event.value === "machine.init" || !this.previousValue) return false;
      return this.value !== this.previousValue;
    }
  });
  return cast(state);
}
function determineDelayFn(delay3, delaysMap) {
  return (context, event) => {
    if (isNumber(delay3)) return delay3;
    if (isFunction(delay3)) {
      return delay3(context, event);
    }
    if (isString(delay3)) {
      const value = Number.parseFloat(delay3);
      if (!Number.isNaN(value)) {
        return value;
      }
      if (delaysMap) {
        const valueOrFn = delaysMap == null ? void 0 : delaysMap[delay3];
        invariant(
          valueOrFn == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay3}\`. It doesn't exist in \`options.delays\``
        );
        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn;
      }
    }
  };
}
function toTarget(target) {
  return isString(target) ? { target } : target;
}
function determineTransitionFn(transitions, guardMap) {
  return (context, event, meta) => {
    return toArray(transitions).map(toTarget).find((transition) => {
      const determineGuard = determineGuardFn(transition.guard, guardMap);
      const guard = determineGuard(context, event, meta);
      return guard ?? transition.target ?? transition.actions;
    });
  };
}
var Machine = class {
  // Let's get started!
  constructor(config2, options) {
    var _a2, _b2, _c2, _d2, _e2;
    __publicField2(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    );
    __publicField2(this, "state");
    __publicField2(this, "initialState");
    __publicField2(this, "initialContext");
    __publicField2(this, "id");
    __publicField2(
      this,
      "type",
      "machine"
      /* Machine */
    );
    __publicField2(this, "activityEvents", /* @__PURE__ */ new Map());
    __publicField2(this, "delayedEvents", /* @__PURE__ */ new Map());
    __publicField2(this, "stateListeners", /* @__PURE__ */ new Set());
    __publicField2(this, "doneListeners", /* @__PURE__ */ new Set());
    __publicField2(this, "contextWatchers", /* @__PURE__ */ new Set());
    __publicField2(this, "removeStateListener", noop);
    __publicField2(this, "parent");
    __publicField2(this, "children", /* @__PURE__ */ new Map());
    __publicField2(this, "guardMap");
    __publicField2(this, "actionMap");
    __publicField2(this, "delayMap");
    __publicField2(this, "activityMap");
    __publicField2(this, "sync");
    __publicField2(this, "options");
    __publicField2(this, "config");
    __publicField2(this, "_created", () => {
      var _a3;
      const event = toEvent(
        "machine.created"
        /* Created */
      );
      this.executeActions((_a3 = this.config) == null ? void 0 : _a3.created, event);
    });
    __publicField2(this, "start", (init) => {
      this.state.value = "";
      this.state.tags = [];
      if (this.status === "Running") {
        return this;
      }
      this.status = "Running";
      this.removeStateListener = subscribe$1(
        this.state,
        () => {
          this.stateListeners.forEach((listener) => {
            listener(this.stateSnapshot);
          });
        },
        this.sync
      );
      this.setupContextWatchers();
      this.executeActivities(
        toEvent(
          "machine.start"
          /* Start */
        ),
        toArray(this.config.activities),
        "machine.start"
        /* Start */
      );
      this.executeActions(this.config.entry, toEvent(
        "machine.start"
        /* Start */
      ));
      const event = toEvent(
        "machine.init"
        /* Init */
      );
      const target = isObject$2(init) ? init.value : init;
      const context = isObject$2(init) ? init.context : void 0;
      if (context) {
        this.setContext(context);
      }
      const transition = {
        target: target ?? this.config.initial
      };
      const next2 = this.getNextStateInfo(transition, event);
      this.initialState = next2;
      this.performStateChangeEffects(this.state.value, next2, event);
      return this;
    });
    __publicField2(this, "setupContextWatchers", () => {
      const { watch } = this.config;
      if (!watch) return;
      let prev2 = snapshot(this.state.context);
      const cleanup = subscribe$1(this.state.context, () => {
        var _a3;
        const next2 = snapshot(this.state.context);
        for (const [key, fn] of Object.entries(watch)) {
          const isEqual2 = ((_a3 = this.options.compareFns) == null ? void 0 : _a3[key]) ?? Object.is;
          if (isEqual2(prev2[key], next2[key])) continue;
          this.executeActions(fn, this.state.event);
        }
        prev2 = next2;
      });
      this.contextWatchers.add(cleanup);
    });
    __publicField2(this, "stop", () => {
      if (this.status === "Stopped") return;
      this.performExitEffects(this.state.value, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.executeActions(this.config.exit, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.setState("");
      this.setEvent(
        "machine.stop"
        /* Stop */
      );
      this.stopStateListeners();
      this.stopChildren();
      this.stopActivities();
      this.stopDelayedEvents();
      this.stopContextWatchers();
      this.status = "Stopped";
      return this;
    });
    __publicField2(this, "stopStateListeners", () => {
      this.removeStateListener();
      this.stateListeners.clear();
    });
    __publicField2(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((fn) => fn());
      this.contextWatchers.clear();
    });
    __publicField2(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((state) => {
        state.forEach((stop) => stop());
      });
      this.delayedEvents.clear();
    });
    __publicField2(this, "stopActivities", (state) => {
      var _a3, _b3;
      if (state) {
        (_a3 = this.activityEvents.get(state)) == null ? void 0 : _a3.forEach((stop) => stop());
        (_b3 = this.activityEvents.get(state)) == null ? void 0 : _b3.clear();
        this.activityEvents.delete(state);
      } else {
        this.activityEvents.forEach((state2) => {
          state2.forEach((stop) => stop());
          state2.clear();
        });
        this.activityEvents.clear();
      }
    });
    __publicField2(this, "sendChild", (evt, to) => {
      const event = toEvent(evt);
      const id2 = runIfFn(to, this.contextSnapshot);
      const child = this.children.get(id2);
      if (!child) {
        invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);
      }
      child.send(event);
    });
    __publicField2(this, "stopChild", (id2) => {
      if (!this.children.has(id2)) {
        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id2}`);
      }
      this.children.get(id2).stop();
      this.children.delete(id2);
    });
    __publicField2(this, "removeChild", (id2) => {
      this.children.delete(id2);
    });
    __publicField2(this, "stopChildren", () => {
      this.children.forEach((child) => child.stop());
      this.children.clear();
    });
    __publicField2(this, "setParent", (parent) => {
      this.parent = parent;
    });
    __publicField2(this, "spawn", (src, id2) => {
      const actor = runIfFn(src);
      if (id2) actor.id = id2;
      actor.type = "machine.actor";
      actor.setParent(this);
      this.children.set(actor.id, cast(actor));
      actor.onDone(() => {
        this.removeChild(actor.id);
      }).start();
      return cast(ref(actor));
    });
    __publicField2(this, "stopActivity", (key) => {
      var _a3;
      if (!this.state.value) return;
      const cleanups2 = this.activityEvents.get(this.state.value);
      (_a3 = cleanups2 == null ? void 0 : cleanups2.get(key)) == null ? void 0 : _a3();
      cleanups2 == null ? void 0 : cleanups2.delete(key);
    });
    __publicField2(this, "addActivityCleanup", (state, key, cleanup) => {
      var _a3;
      if (!state) return;
      if (!this.activityEvents.has(state)) {
        this.activityEvents.set(state, /* @__PURE__ */ new Map([[key, cleanup]]));
      } else {
        (_a3 = this.activityEvents.get(state)) == null ? void 0 : _a3.set(key, cleanup);
      }
    });
    __publicField2(this, "setState", (target) => {
      this.state.previousValue = this.state.value;
      this.state.value = target;
      const stateNode = this.getStateNode(target);
      if (target == null) {
        clear(this.state.tags);
      } else {
        this.state.tags = toArray(stateNode == null ? void 0 : stateNode.tags);
      }
    });
    __publicField2(this, "setContext", (context) => {
      if (!context) return;
      deepMerge(this.state.context, compact$1(context));
    });
    __publicField2(this, "setOptions", (options2) => {
      const opts = compact$1(options2);
      this.actionMap = { ...this.actionMap, ...opts.actions };
      this.delayMap = { ...this.delayMap, ...opts.delays };
      this.activityMap = { ...this.activityMap, ...opts.activities };
      this.guardMap = { ...this.guardMap, ...opts.guards };
    });
    __publicField2(this, "getStateNode", (state) => {
      var _a3;
      if (!state) return;
      return (_a3 = this.config.states) == null ? void 0 : _a3[state];
    });
    __publicField2(this, "getNextStateInfo", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      const isTargetless = !(transition == null ? void 0 : transition.target);
      const target = (transition == null ? void 0 : transition.target) ?? this.state.value;
      const changed = this.state.value !== target;
      const stateNode = this.getStateNode(target);
      const reenter = !isTargetless && !changed && !(transition == null ? void 0 : transition.internal);
      const info = {
        reenter,
        transition,
        stateNode,
        target,
        changed
      };
      this.log("NextState:", `[${event.type}]`, this.state.value, "---->", info.target);
      return info;
    });
    __publicField2(this, "getAfterActions", (transition, delay3) => {
      let id2;
      const current = this.state.value;
      return {
        entry: () => {
          id2 = globalThis.setTimeout(() => {
            const next2 = this.getNextStateInfo(transition, this.state.event);
            this.performStateChangeEffects(current, next2, this.state.event);
          }, delay3);
        },
        exit: () => {
          globalThis.clearTimeout(id2);
        }
      };
    });
    __publicField2(this, "getDelayedEventActions", (state) => {
      const stateNode = this.getStateNode(state);
      const event = this.state.event;
      if (!stateNode || !stateNode.after) return;
      const entries = [];
      const exits = [];
      if (isArray(stateNode.after)) {
        const transition = this.determineTransition(stateNode.after, event);
        if (!transition) return;
        if (!hasProp(transition, "delay")) {
          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);
        }
        const determineDelay = determineDelayFn(transition.delay, this.delayMap);
        const __delay = determineDelay(this.contextSnapshot, event);
        const actions = this.getAfterActions(transition, __delay);
        entries.push(actions.entry);
        exits.push(actions.exit);
        return { entries, exits };
      }
      if (isObject$2(stateNode.after)) {
        for (const delay3 in stateNode.after) {
          const transition = stateNode.after[delay3];
          const determineDelay = determineDelayFn(delay3, this.delayMap);
          const __delay = determineDelay(this.contextSnapshot, event);
          const actions = this.getAfterActions(transition, __delay);
          entries.push(actions.entry);
          exits.push(actions.exit);
        }
      }
      return { entries, exits };
    });
    __publicField2(this, "executeActions", (actions, event) => {
      var _a3;
      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      for (const action of toArray(pickedActions)) {
        const fn = isString(action) ? (_a3 = this.actionMap) == null ? void 0 : _a3[action] : action;
        warn(
          isString(action) && !fn,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
        );
        fn == null ? void 0 : fn(this.state.context, event, this.meta);
      }
    });
    __publicField2(this, "executeActivities", (event, activities, state) => {
      var _a3;
      for (const activity of activities) {
        const fn = isString(activity) ? (_a3 = this.activityMap) == null ? void 0 : _a3[activity] : activity;
        if (!fn) {
          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
          continue;
        }
        const cleanup = fn(this.state.context, event, this.meta);
        if (cleanup) {
          const key = isString(activity) ? activity : activity.name || uuid();
          this.addActivityCleanup(state ?? this.state.value, key, cleanup);
        }
      }
    });
    __publicField2(this, "createEveryActivities", (every, callbackfn) => {
      if (!every) return;
      if (isArray(every)) {
        const picked = toArray(every).find((transition) => {
          const delayOrFn = transition.delay;
          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
          const delay22 = determineDelay2(this.contextSnapshot, this.state.event);
          const determineGuard = determineGuardFn(transition.guard, this.guardMap);
          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);
          return guard ?? delay22 != null;
        });
        if (!picked) return;
        const determineDelay = determineDelayFn(picked.delay, this.delayMap);
        const delay3 = determineDelay(this.contextSnapshot, this.state.event);
        const activity = () => {
          const id2 = globalThis.setInterval(() => {
            this.executeActions(picked.actions, this.state.event);
          }, delay3);
          return () => {
            globalThis.clearInterval(id2);
          };
        };
        callbackfn(activity);
      } else {
        for (const interval in every) {
          const actions = every == null ? void 0 : every[interval];
          const determineDelay = determineDelayFn(interval, this.delayMap);
          const delay3 = determineDelay(this.contextSnapshot, this.state.event);
          const activity = () => {
            const id2 = globalThis.setInterval(() => {
              this.executeActions(actions, this.state.event);
            }, delay3);
            return () => {
              globalThis.clearInterval(id2);
            };
          };
          callbackfn(activity);
        }
      }
    });
    __publicField2(this, "setEvent", (event) => {
      this.state.previousEvent = this.state.event;
      this.state.event = ref(toEvent(event));
    });
    __publicField2(this, "performExitEffects", (current, event) => {
      const currentState = this.state.value;
      if (currentState === "") return;
      const stateNode = current ? this.getStateNode(current) : void 0;
      this.stopActivities(currentState);
      const _exit = determineActionsFn(stateNode == null ? void 0 : stateNode.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      const exitActions = toArray(_exit);
      const afterExitActions = this.delayedEvents.get(currentState);
      if (afterExitActions) {
        exitActions.push(...afterExitActions);
      }
      this.executeActions(exitActions, event);
      this.delayedEvents.delete(currentState);
    });
    __publicField2(this, "performEntryEffects", (next2, event) => {
      const stateNode = this.getStateNode(next2);
      const activities = toArray(stateNode == null ? void 0 : stateNode.activities);
      this.createEveryActivities(stateNode == null ? void 0 : stateNode.every, (activity) => {
        activities.unshift(activity);
      });
      if (activities.length > 0) {
        this.executeActivities(event, activities);
      }
      const pickedActions = determineActionsFn(stateNode == null ? void 0 : stateNode.entry, this.guardMap)(
        this.contextSnapshot,
        event,
        this.guardMeta
      );
      const entryActions = toArray(pickedActions);
      const afterActions = this.getDelayedEventActions(next2);
      if ((stateNode == null ? void 0 : stateNode.after) && afterActions) {
        this.delayedEvents.set(next2, afterActions == null ? void 0 : afterActions.exits);
        entryActions.push(...afterActions.entries);
      }
      this.executeActions(entryActions, event);
      if ((stateNode == null ? void 0 : stateNode.type) === "final") {
        this.state.done = true;
        this.doneListeners.forEach((listener) => {
          listener(this.stateSnapshot);
        });
        this.stop();
      }
    });
    __publicField2(this, "performTransitionEffects", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      this.executeActions(transition == null ? void 0 : transition.actions, event);
    });
    __publicField2(this, "performStateChangeEffects", (current, next2, event) => {
      this.setEvent(event);
      const changed = next2.changed || next2.reenter;
      if (changed) {
        this.performExitEffects(current, event);
      }
      this.performTransitionEffects(next2.transition, event);
      this.setState(next2.target);
      if (changed) {
        this.performEntryEffects(next2.target, event);
      }
    });
    __publicField2(this, "determineTransition", (transition, event) => {
      const fn = determineTransitionFn(transition, this.guardMap);
      return fn == null ? void 0 : fn(this.contextSnapshot, event, this.guardMeta);
    });
    __publicField2(this, "sendParent", (evt) => {
      var _a3;
      if (!this.parent) {
        invariant("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      }
      const event = toEvent(evt);
      (_a3 = this.parent) == null ? void 0 : _a3.send(event);
    });
    __publicField2(this, "log", (...args) => {
    });
    __publicField2(this, "send", (evt) => {
      const event = toEvent(evt);
      this.transition(this.state.value, event);
    });
    __publicField2(this, "transition", (state, evt) => {
      var _a3, _b3;
      const stateNode = isString(state) ? this.getStateNode(state) : state == null ? void 0 : state.stateNode;
      const event = toEvent(evt);
      if (!stateNode && !this.config.on) {
        const msg = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state}, \`event\`: ${event.type}`;
        warn(msg);
        return;
      }
      const transitions = (
        // @ts-expect-error - Fix this
        ((_a3 = stateNode == null ? void 0 : stateNode.on) == null ? void 0 : _a3[event.type]) ?? ((_b3 = this.config.on) == null ? void 0 : _b3[event.type])
      );
      const next2 = this.getNextStateInfo(transitions, event);
      this.performStateChangeEffects(this.state.value, next2, event);
      return next2.stateNode;
    });
    __publicField2(this, "subscribe", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return () => {
        this.stateListeners.delete(listener);
      };
    });
    __publicField2(this, "onDone", (listener) => {
      this.doneListeners.add(listener);
      return this;
    });
    __publicField2(this, "onTransition", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return this;
    });
    this.config = structuredClone$1(config2);
    this.options = structuredClone$1(options ?? {});
    this.id = this.config.id ?? `machine-${uuid()}`;
    this.guardMap = ((_a2 = this.options) == null ? void 0 : _a2.guards) ?? {};
    this.actionMap = ((_b2 = this.options) == null ? void 0 : _b2.actions) ?? {};
    this.delayMap = ((_c2 = this.options) == null ? void 0 : _c2.delays) ?? {};
    this.activityMap = ((_d2 = this.options) == null ? void 0 : _d2.activities) ?? {};
    this.sync = ((_e2 = this.options) == null ? void 0 : _e2.sync) ?? false;
    this.state = createProxy(this.config);
    this.initialContext = snapshot(this.state.context);
  }
  // immutable state value
  get stateSnapshot() {
    return cast(snapshot(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const self2 = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      stopActivity: this.stopActivity.bind(this),
      get state() {
        return self2.stateSnapshot;
      },
      get initialContext() {
        return self2.initialContext;
      },
      get initialState() {
        var _a2;
        return ((_a2 = self2.initialState) == null ? void 0 : _a2.target) ?? "";
      }
    };
  }
  get meta() {
    var _a2;
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: ((_a2 = this.initialState) == null ? void 0 : _a2.target) ?? "",
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
  getHydrationState() {
    const state = this.getState();
    return {
      value: state.value,
      tags: state.tags
    };
  }
};
var createMachine = (config2, options) => new Machine(config2, options);
var isMachine = (value) => {
  return value instanceof Machine || (value == null ? void 0 : value.type) === "machine";
};
var clsx = (...args) => args.map((str) => {
  var _a2;
  return (_a2 = str == null ? void 0 : str.trim) == null ? void 0 : _a2.call(str);
}).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize$1 = (style) => {
  const res = {};
  let match2;
  while (match2 = CSS_REGEX.exec(style)) {
    res[match2[1]] = match2[2];
  }
  return res;
};
var css = (a, b2) => {
  if (isString(a)) {
    if (isString(b2)) return `${a};${b2}`;
    a = serialize$1(a);
  } else if (isString(b2)) {
    b2 = serialize$1(b2);
  }
  return Object.assign({}, a ?? {}, b2 ?? {});
};
function mergeProps(...args) {
  let result = {};
  for (let props of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props[key] === "function") {
        result[key] = callAll(props[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props[key]);
        continue;
      }
      result[key] = props[key] !== void 0 ? props[key] : result[key];
    }
    for (let key in props) {
      if (result[key] === void 0) {
        result[key] = props[key];
      }
    }
  }
  return result;
}
function createNormalizer(fn) {
  return new Proxy({}, {
    get() {
      return fn;
    }
  });
}
var createProps = () => (props) => Array.from(new Set(props));
var anatomy$j = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
anatomy$j.build();
var dom$j = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `accordion:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.item) == null ? void 0 : _b2.call(_a2, value)) ?? `accordion:${ctx.id}:item:${value}`;
  },
  getItemContentId: (ctx, value) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemContent) == null ? void 0 : _b2.call(_a2, value)) ?? `accordion:${ctx.id}:content:${value}`;
  },
  getItemTriggerId: (ctx, value) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemTrigger) == null ? void 0 : _b2.call(_a2, value)) ?? `accordion:${ctx.id}:trigger:${value}`;
  },
  getRootEl: (ctx) => dom$j.getById(ctx, dom$j.getRootId(ctx)),
  getTriggerEls: (ctx) => {
    const ownerId = CSS.escape(dom$j.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom$j.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom$j.getTriggerEls(ctx)),
  getLastTriggerEl: (ctx) => last(dom$j.getTriggerEls(ctx)),
  getNextTriggerEl: (ctx, id2) => nextById(dom$j.getTriggerEls(ctx), dom$j.getItemTriggerId(ctx, id2)),
  getPrevTriggerEl: (ctx, id2) => prevById(dom$j.getTriggerEls(ctx), dom$j.getItemTriggerId(ctx, id2))
});
createProps()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value"
]);
createProps()(["value", "disabled"]);
var normalizeProps = createNormalizer((v2) => v2);
var isArrayLike$1 = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual = (a, b2) => {
  if (a.length !== b2.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual$1(a[i], b2[i])) return false;
  }
  return true;
};
var isEqual$1 = (a, b2) => {
  if (Object.is(a, b2)) return true;
  if (a == null && b2 != null || a != null && b2 == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b2 == null ? void 0 : b2.isEqual) === "function") {
    return a.isEqual(b2);
  }
  if (typeof a === "function" && typeof b2 === "function") {
    return a.toString() === b2.toString();
  }
  if (isArrayLike$1(a) && isArrayLike$1(b2)) {
    return isArrayEqual(Array.from(a), Array.from(b2));
  }
  if (!(typeof a === "object") || !(typeof b2 === "object")) return false;
  const keys = Object.keys(b2 ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual$1(a[key], b2[key])) return false;
  }
  return true;
};
var fnToString = Function.prototype.toString;
fnToString.call(Object);
function compact(obj) {
  if (!isPlainObject(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact(value);
    }
  }
  return filtered;
}
var isPlainObject = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};
function useUpdateEffect(callback, deps) {
  const render = reactExports.useRef(false);
  const effect2 = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const mounted = render.current;
    const run = mounted && effect2.current;
    if (run) {
      return callback();
    }
    effect2.current = true;
  }, deps);
  reactExports.useEffect(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
}
var { use } = React;
var targetCache = makeGlobal("__zag__targetCache", () => /* @__PURE__ */ new WeakMap());
function useSnapshot(service, options) {
  const { actions, context, sync: notifyInSync } = options ?? {};
  const lastSnapshot = reactExports.useRef();
  const lastAffected = reactExports.useRef();
  const currSnapshot = reactExports.useSyncExternalStore(
    reactExports.useCallback((callback) => subscribe$1(service.state, callback, notifyInSync), [notifyInSync]),
    () => {
      const nextSnapshot = snapshot(service.state, use);
      try {
        if (lastSnapshot.current && lastAffected.current && !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return lastSnapshot.current;
        }
      } catch {
      }
      return nextSnapshot;
    },
    () => snapshot(service.state, use)
  );
  service.setOptions({ actions });
  const ctx = reactExports.useMemo(() => compact(context ?? {}), [context]);
  useUpdateEffect(() => {
    const entries = Object.entries(ctx);
    const previousCtx = service.contextSnapshot ?? {};
    const equality = entries.map(([key, value]) => ({
      key,
      curr: value,
      prev: previousCtx[key],
      equal: isEqual$1(previousCtx[key], value)
    }));
    const allEqual = equality.every(({ equal }) => equal);
    if (!allEqual) {
      service.setContext(ctx);
    }
  }, [ctx]);
  const currAffected = /* @__PURE__ */ new WeakMap();
  reactExports.useEffect(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  const proxyCache = reactExports.useMemo(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy$1(currSnapshot, currAffected, proxyCache, targetCache);
}
function useActor(service) {
  const state = useSnapshot(service);
  return [state, service.send];
}
function useConstant(fn) {
  const ref2 = reactExports.useRef();
  if (!ref2.current) ref2.current = { v: fn() };
  return ref2.current.v;
}
var useSafeLayoutEffect = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useService(machine2, options) {
  const { state: hydratedState, context } = options ?? {};
  const service = useConstant(() => {
    const instance = typeof machine2 === "function" ? machine2() : machine2;
    if (context) instance.setContext(context);
    instance._created();
    return instance;
  });
  const snapshotRef = reactExports.useRef();
  useSafeLayoutEffect(() => {
    const stateInit = hydratedState ?? snapshotRef.current;
    service.start(stateInit);
    return () => {
      service.stop();
    };
  }, []);
  return service;
}
function useMachine(machine2, options) {
  const service = useService(machine2, options);
  const state = useSnapshot(service, options);
  return [state, service.send, service];
}
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs(...refs) {
  return (node2) => {
    for (const ref2 of refs) {
      setRef(ref2, node2);
    }
  };
}
function getRef(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
const withAsChild = (Component) => {
  const Comp = reactExports.memo(
    reactExports.forwardRef((props, ref2) => {
      const { asChild, children, ...restProps } = props;
      if (!asChild) {
        return reactExports.createElement(Component, { ...restProps, ref: ref2 }, children);
      }
      const onlyChild = reactExports.Children.only(children);
      if (!reactExports.isValidElement(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return reactExports.cloneElement(onlyChild, {
        ...mergeProps(restProps, onlyChild.props),
        ref: ref2 ? composeRefs(ref2, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
const jsxFactory = () => {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache2.has(asElement)) {
        cache2.set(asElement, withAsChild(asElement));
      }
      return cache2.get(asElement);
    }
  });
};
const ark = jsxFactory();
const createSplitProps = () => (props, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props }]
);
const splitCollapsibleProps = (props) => createSplitProps()(props, [
  "defaultOpen",
  "disabled",
  "id",
  "ids",
  "lazyMount",
  "onExitComplete",
  "onOpenChange",
  "open",
  "unmountOnExit"
]);
var anatomy$i = createAnatomy("collapsible").parts("root", "trigger", "content");
var parts$4 = anatomy$i.build();
var dom$i = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `collapsible:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.content) ?? `collapsible:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.trigger) ?? `collapsible:${ctx.id}:trigger`;
  },
  getRootEl: (ctx) => dom$i.getById(ctx, dom$i.getRootId(ctx)),
  getContentEl: (ctx) => dom$i.getById(ctx, dom$i.getContentId(ctx)),
  getTriggerEl: (ctx) => dom$i.getById(ctx, dom$i.getTriggerId(ctx))
});
function connect$5(state, send, normalize2) {
  const visible = state.matches("open", "closing");
  const open = state.matches("open");
  const height = state.context.height;
  const width = state.context.width;
  const disabled = !!state.context.disabled;
  const skip = !state.context.initial && open;
  return {
    disabled,
    visible,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getRootProps() {
      return normalize2.element({
        ...parts$4.root.attrs,
        "data-state": open ? "open" : "closed",
        dir: state.context.dir,
        id: dom$i.getRootId(state.context)
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts$4.content.attrs,
        "data-state": skip ? void 0 : open ? "open" : "closed",
        id: dom$i.getContentId(state.context),
        "data-disabled": dataAttr$1(disabled),
        hidden: !visible,
        style: {
          "--height": height != null ? `${height}px` : void 0,
          "--width": width != null ? `${width}px` : void 0
        }
      });
    },
    getTriggerProps() {
      return normalize2.element({
        ...parts$4.trigger.attrs,
        id: dom$i.getTriggerId(state.context),
        dir: state.context.dir,
        type: "button",
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr$1(disabled),
        "aria-controls": dom$i.getContentId(state.context),
        "aria-expanded": visible || false,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: open ? "CLOSE" : "OPEN", src: "trigger.click" });
        }
      });
    }
  };
}
function machine$4(userContext) {
  const ctx = compact$1(userContext);
  return createMachine(
    {
      id: "collapsible",
      initial: ctx.open ? "open" : "closed",
      context: {
        ...ctx,
        height: 0,
        width: 0,
        initial: false,
        stylesRef: null,
        unmountAnimationName: null
      },
      watch: {
        open: ["setInitial", "computeSize", "toggleVisibility"]
      },
      exit: ["clearInitial"],
      states: {
        closed: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "computeSize", "invokeOnOpen"]
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackAnimationEvents"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "invokeOnOpen"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnExitComplete"]
              },
              {
                target: "closed",
                actions: ["setInitial", "computeSize", "invokeOnExitComplete"]
              }
            ],
            "ANIMATION.END": {
              target: "closed",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        open: {
          tags: ["open"],
          on: {
            "CONTROLLED.CLOSE": "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closing",
                actions: ["setInitial", "computeSize", "invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          let cleanup;
          const rafCleanup = raf$1(() => {
            const contentEl = dom$i.getContentEl(ctx2);
            if (!contentEl) return;
            const animationName = getComputedStyle$2(contentEl).animationName;
            const hasNoAnimation = !animationName || animationName === "none";
            if (hasNoAnimation) {
              send({ type: "ANIMATION.END" });
              return;
            }
            const onEnd = (event) => {
              const win = contentEl.ownerDocument.defaultView || window;
              const animationName2 = win.getComputedStyle(contentEl).animationName;
              const target = getEventTarget(event);
              if (target === contentEl && animationName2 === ctx2.unmountAnimationName) {
                send({ type: "ANIMATION.END" });
              }
            };
            contentEl.addEventListener("animationend", onEnd);
            cleanup = () => {
              contentEl.removeEventListener("animationend", onEnd);
            };
          });
          return () => {
            rafCleanup();
            cleanup == null ? void 0 : cleanup();
          };
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        computeSize(ctx2, evt) {
          var _a2;
          (_a2 = ctx2._rafCleanup) == null ? void 0 : _a2.call(ctx2);
          ctx2._rafCleanup = raf$1(() => {
            const contentEl = dom$i.getContentEl(ctx2);
            if (!contentEl) return;
            ctx2.stylesRef || (ctx2.stylesRef = ref({
              animationName: contentEl.style.animationName,
              animationDuration: contentEl.style.animationDuration
            }));
            if (evt.type === "CLOSE" || !ctx2.open) {
              const win = contentEl.ownerDocument.defaultView || window;
              ctx2.unmountAnimationName = win.getComputedStyle(contentEl).animationName;
            }
            const hidden = contentEl.hidden;
            contentEl.style.animationName = "none";
            contentEl.style.animationDuration = "0s";
            contentEl.hidden = false;
            const rect = contentEl.getBoundingClientRect();
            ctx2.height = rect.height;
            ctx2.width = rect.width;
            if (ctx2.initial) {
              contentEl.style.animationName = ctx2.stylesRef.animationName;
              contentEl.style.animationDuration = ctx2.stylesRef.animationDuration;
            }
            contentEl.hidden = hidden;
          });
        },
        invokeOnOpen: (ctx2) => {
          var _a2;
          (_a2 = ctx2.onOpenChange) == null ? void 0 : _a2.call(ctx2, { open: true });
        },
        invokeOnClose: (ctx2) => {
          var _a2;
          (_a2 = ctx2.onOpenChange) == null ? void 0 : _a2.call(ctx2, { open: false });
        },
        invokeOnExitComplete(ctx2) {
          var _a2;
          (_a2 = ctx2.onExitComplete) == null ? void 0 : _a2.call(ctx2);
        },
        toggleVisibility: (ctx2, _evt, { send }) => {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE" });
        }
      }
    }
  );
}
createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "open.controlled",
  "open"
]);
const [EnvironmentContextProvider, useEnvironmentContext] = createContext$1({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});
function useEvent(callback, opts = {}) {
  const { sync = false } = opts;
  const callbackRef = useLatestRef(callback);
  return reactExports.useCallback(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      var _a2;
      if (sync) return queueMicrotask(() => {
        var _a3;
        return (_a3 = callbackRef.current) == null ? void 0 : _a3.call(callbackRef, ...args);
      });
      return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
    },
    [sync, callbackRef]
  );
}
function useLatestRef(value) {
  const ref2 = reactExports.useRef(value);
  ref2.current = value;
  return ref2;
}
const useCollapsible = (props = {}) => {
  const { lazyMount, unmountOnExit, ...collapsibleProps } = props;
  const wasVisible = reactExports.useRef(false);
  const { dir } = useLocaleContext();
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const initialContext = {
    id: reactExports.useId(),
    dir,
    getRootNode: getRootNode2,
    open: props.defaultOpen,
    "open.controlled": props.open !== void 0,
    ...collapsibleProps
  };
  const context = {
    ...initialContext,
    open: props.open,
    onOpenChange: useEvent(props.onOpenChange, { sync: true })
  };
  const [state, send] = useMachine(machine$4(initialContext), { context });
  const api = connect$5(state, send, normalizeProps);
  if (api.visible) {
    wasVisible.current = true;
  }
  const isUnmounted = !api.visible && !wasVisible.current && lazyMount || unmountOnExit && !api.visible && wasVisible.current;
  return { ...api, isUnmounted };
};
const [CollapsibleProvider, useCollapsibleContext] = createContext$1({
  name: "CollapsibleContext",
  hookName: "useCollapsibleContext",
  providerName: "<CollapsibleProvider />"
});
const CollapsibleRoot$1 = reactExports.forwardRef((props, ref2) => {
  const [useCollapsibleProps, localProps] = splitCollapsibleProps(props);
  const collapsible = useCollapsible(useCollapsibleProps);
  const mergedProps = mergeProps(collapsible.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleProvider, { value: collapsible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) });
});
CollapsibleRoot$1.displayName = "CollapsibleRoot";
function getRoundedValue(value, minValue, step) {
  return Math.round((value - minValue) / step) * step + minValue;
}
function clampValue(value, minValue, maxValue2) {
  return Math.min(Math.max(value, minValue), maxValue2);
}
function getValuePercent(value, minValue, maxValue2) {
  return (value - minValue) / (maxValue2 - minValue);
}
function getPercentValue(percent, minValue, maxValue2, step) {
  const value = percent * (maxValue2 - minValue) + minValue;
  const roundedValue = getRoundedValue(value, minValue, step);
  return clampValue(roundedValue, minValue, maxValue2);
}
function getValueTransformer(valueA, valueB) {
  const input = { min: valueA[0], max: valueA[1] };
  const output = { min: valueB[0], max: valueB[1] };
  return function getValue(value) {
    if (input.min === input.max || output.min === output.max) return output.min;
    const ratio = (output.max - output.min) / (input.max - input.min);
    return output.min + ratio * (value - input.min);
  };
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round$1 = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements: elements2,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements2[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements2.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements2.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: elements2,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$1 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements: elements2,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length2 = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements2.floating[clientProp] || rects.floating[length2];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length2] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset2 = clamp$1(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements: elements2
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a, b2) => a.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b2) => a[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements: elements2
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements: elements2
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements2.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow$1(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow$1(value).Node;
}
function isElement$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow$1(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement$1(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round$1(width) !== offsetWidth || round$1(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement$1(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round$1(rect.width) : rect.width) / width;
  let y2 = ($ ? round$1(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow$1(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement$1(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow$1(domElement);
    const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow$1(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements: elements2,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements2 ? isTopLayer(elements2.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement$1(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement$1(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow$1(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement$1(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement$1,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh2(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh2();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh2(false, 1e-7);
          }, 1e3);
        } else {
          refresh2(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh2(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset = offset$1;
const shift = shift$1;
const flip = flip$1;
const size = size$1;
const hide = hide$1;
const arrow = arrow$1;
const limitShift = limitShift$1;
const computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function createDOMRect(x2 = 0, y2 = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x2, y2, width, height);
  }
  const rect = {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x: x2, y: y2, width, height } = anchorRect;
  return createDOMRect(x2, y2, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement$1(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect == null ? void 0 : getAnchorRect(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow2) => ({
  top: "bottom center",
  "top-start": arrow2 ? `${arrow2.x}px bottom` : "left bottom",
  "top-end": arrow2 ? `${arrow2.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow2 ? `${arrow2.x}px top` : "top left",
  "bottom-end": arrow2 ? `${arrow2.x}px top` : "top right",
  left: "right center",
  "left-start": arrow2 ? `right ${arrow2.y}px` : "right top",
  "left-end": arrow2 ? `right ${arrow2.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow2 ? `left ${arrow2.y}px` : "left top",
  "right-end": arrow2 ? `left ${arrow2.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements: elements2, middlewareData }) {
    const { arrow: arrow2 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow2)[placement];
    const { floating } = elements2;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x: x2, y: y2 } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x2 != null ? `${x2}px` : "",
        top: y2 != null ? `${y2}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return arrow({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter)) return;
  return offset(({ placement }) => {
    var _a2, _b2;
    const arrowOffset = ((arrowElement == null ? void 0 : arrowElement.clientHeight) || 0) / 2;
    const gutter = ((_a2 = opts.offset) == null ? void 0 : _a2.mainAxis) ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift2 = !hasAlign ? opts.shift : void 0;
    const crossAxis = ((_b2 = opts.offset) == null ? void 0 : _b2.crossAxis) ?? shift2;
    return compact$1({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return flip({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return shift({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift()
  });
}
function getSizeMiddleware(opts) {
  return size({
    padding: opts.overflowPadding,
    apply({ elements: elements2, rects, availableHeight, availableWidth }) {
      const floating = elements2.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  var _a2;
  if (!opts.hideWhenDetached) return;
  return hide({ strategy: "referenceHidden", boundary: ((_a2 = opts.boundary) == null ? void 0 : _a2.call(opts)) ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware2 = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, options),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options),
    hideWhenDetachedMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    var _a2;
    if (!reference || !floating) return;
    const pos = await computePosition(reference, floating, {
      placement,
      middleware: middleware2,
      strategy
    });
    onComplete == null ? void 0 : onComplete(pos);
    onPositioned == null ? void 0 : onPositioned({ placed: true });
    const win = getWindow$2(floating);
    const x2 = roundByDpr(win, pos.x);
    const y2 = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x2}px`);
    floating.style.setProperty("--y", `${y2}px`);
    if (options.hideWhenDetached && ((_a2 = pos.middlewareData.hide) == null ? void 0 : _a2.referenceHidden)) {
      floating.style.setProperty("visibility", "hidden");
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const zIndex = win.getComputedStyle(contentEl).zIndex;
      floating.style.setProperty("--z-index", zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned == null ? void 0 : onPositioned({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop;
  update();
  return () => {
    cancelAutoUpdate == null ? void 0 : cancelAutoUpdate();
    onPositioned == null ? void 0 : onPositioned({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups2.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}
function getWindowFrames(win) {
  const frames = {
    each(cb2) {
      var _a2;
      for (let i = 0; i < ((_a2 = win.frames) == null ? void 0 : _a2.length); i += 1) {
        const frame = win.frames[i];
        if (frame) cb2(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.addEventListener(event, listener, options);
      } catch {
      }
      return () => {
        try {
          parent == null ? void 0 : parent.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.removeEventListener(event, listener, options);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node2 of composedPath) {
    if (isHTMLElement$1(node2) && isFocusable$1(node2)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node2, event) {
  if (!isPointerEvent(event) || !node2) return false;
  const rect = node2.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isEventWithinScrollbar(event, target) {
  if (!target || !isPointerEvent(event)) return false;
  const isScrollableY = target.scrollHeight > target.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > target.clientWidth;
  const isScrollableX = target.scrollWidth > target.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > target.clientHeight;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node2, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
  if (!node2) return;
  const doc = getDocument(node2);
  const win = getWindow$2(node2);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event) {
    const target = getEventTarget(event);
    if (!isHTMLElement$1(target)) return false;
    if (contains(node2, target)) return false;
    if (isEventPointWithin(node2, event)) return false;
    if (isEventWithinScrollbar(event, target)) return false;
    const scrollParent = getNearestOverflowAncestor$1(node2);
    if (isEventWithinScrollbar(event, scrollParent)) return false;
    return !(exclude == null ? void 0 : exclude(target));
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  function onPointerDown(event) {
    function handler() {
      var _a2;
      const func = defer ? raf$1 : (v2) => v2();
      const composedPath = ((_a2 = event.composedPath) == null ? void 0 : _a2.call(event)) ?? [event.target];
      func(() => {
        if (!node2 || !isEventOutside(event)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll(onPointerDownOutside, onInteractOutside);
          node2.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node2, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: event,
            contextmenu: isContextMenuEvent(event),
            focusable: isComposedPathFocusable(composedPath)
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups2 = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups2.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
    cleanups2.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups2.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf$1 : (v2) => v2();
    func(() => {
      if (!node2 || !isEventOutside(event)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll(onFocusOutside, onInteractOutside);
        node2.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node2, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable$1(getEventTarget(event))
        }
      });
    });
  }
  cleanups2.add(addDomEvent(doc, "focusin", onFocusin, true));
  cleanups2.add(parentWin.addEventListener("focusin", onFocusin, true));
  cleanups2.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups2.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackInteractOutsideImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackEscapeKeydown(node2, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn == null ? void 0 : fn(event);
  };
  return addDomEvent(getDocument(node2), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node2) {
    var _a2;
    const index = this.indexOf(node2);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf((_a2 = this.topMostPointerBlockingLayer()) == null ? void 0 : _a2.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node2) {
    const layer = this.layers[this.count() - 1];
    return (layer == null ? void 0 : layer.node) === node2;
  },
  getNestedLayers(node2) {
    return Array.from(this.layers).slice(this.indexOf(node2) + 1);
  },
  isInNestedLayer(node2, target) {
    return this.getNestedLayers(node2).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node2) {
    this.branches.push(node2);
  },
  remove(node2) {
    const index = this.indexOf(node2);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node2);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node2.style.removeProperty("--layer-index");
  },
  removeBranch(node2) {
    const index = this.branches.indexOf(node2);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node2) {
    return this.layers.findIndex((layer) => layer.node === node2);
  },
  dismiss(node2) {
    var _a2;
    (_a2 = this.layers[this.indexOf(node2)]) == null ? void 0 : _a2.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node: node2 }) => {
    node2.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node2) ? "none" : "auto";
  });
}
function clearPointerEvent(node2) {
  node2.style.pointerEvents = "";
}
function disablePointerEventsOutside(node2, peristentElements) {
  const doc = getDocument(node2);
  const cleanups2 = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (peristentElements) {
    const persistedCleanup = waitForElements(peristentElements, (el2) => {
      cleanups2.push(setStyle(el2, { pointerEvents: "auto" }));
    });
    cleanups2.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups2.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node2, options) {
  if (!node2) {
    warn("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node: node2, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    var _a2, _b2;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node2) || layerStack.isInBranch(target)) return;
    (_a2 = options.onPointerDownOutside) == null ? void 0 : _a2.call(options, event);
    (_b2 = options.onInteractOutside) == null ? void 0 : _b2.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onFocusOutside(event) {
    var _a2, _b2;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    (_a2 = options.onFocusOutside) == null ? void 0 : _a2.call(options, event);
    (_b2 = options.onInteractOutside) == null ? void 0 : _b2.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onEscapeKeyDown(event) {
    var _a2;
    if (!layerStack.isTopMost(node2)) return;
    (_a2 = options.onEscapeKeyDown) == null ? void 0 : _a2.call(options, event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    var _a2;
    if (!node2) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = (_a2 = options.persistentElements) == null ? void 0 : _a2.map((fn) => fn()).filter(isHTMLElement$1);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node22) => contains(node22, target)) || layerStack.isInNestedLayer(node2, target);
  }
  const cleanups2 = [
    pointerBlocking ? disablePointerEventsOutside(node2, options.persistentElements) : void 0,
    trackEscapeKeydown(node2, onEscapeKeyDown),
    trackInteractOutside(node2, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node2);
    assignPointerEventToLayers();
    clearPointerEvent(node2);
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableElement(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackDismissableElementImpl(node2, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf$1 : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node2 = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node2) {
        warn("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node2);
      cleanups2.push(() => {
        layerStack.removeBranch(node2);
      });
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
var getWindow = (el2) => el2.ownerDocument.defaultView || window;
function getDescriptor(el2, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow(el2)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function setElementValue(el2, value, option = {}) {
  var _a2;
  const descriptor = getDescriptor(el2, option);
  (_a2 = descriptor.set) == null ? void 0 : _a2.call(el2, value);
  el2.setAttribute("value", value);
}
function dispatchInputValueEvent(el2, options) {
  const { value, bubbles = true } = options;
  if (!el2) return;
  const win = getWindow(el2);
  if (!(el2 instanceof win.HTMLInputElement)) return;
  setElementValue(el2, `${value}`);
  el2.dispatchEvent(new win.Event("input", { bubbles }));
}
const CollapsibleContent$1 = reactExports.forwardRef(
  (props, ref2) => {
    const collapsible = useCollapsibleContext();
    if (collapsible.isUnmounted) {
      return null;
    }
    const mergedProps = mergeProps(collapsible.getContentProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleContent$1.displayName = "CollapsibleContent";
function connect$4(state, send, _normalize) {
  const present = state.matches("mounted", "unmountSuspended");
  return {
    skip: !state.context.initial && present,
    present,
    setNode(node2) {
      if (!node2) return;
      send({ type: "NODE.SET", node: node2 });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
function machine$3(ctx) {
  return createMachine(
    {
      initial: ctx.present ? "mounted" : "unmounted",
      context: {
        node: null,
        styles: null,
        unmountAnimationName: null,
        prevAnimationName: null,
        present: false,
        initial: false,
        ...ctx
      },
      exit: ["clearInitial"],
      watch: {
        present: ["setInitial", "syncPresence"]
      },
      on: {
        "NODE.SET": {
          actions: ["setNode", "setStyles"]
        }
      },
      states: {
        mounted: {
          on: {
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            },
            "UNMOUNT.SUSPEND": "unmountSuspended"
          }
        },
        unmountSuspended: {
          activities: ["trackAnimationEvents"],
          after: {
            // Fallback to timeout to ensure we exit this state even if the `animationend` event
            // did not get trigger
            ANIMATION_DURATION: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          },
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            },
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        unmounted: {
          entry: ["clearPrevAnimationName"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            }
          }
        }
      }
    },
    {
      delays: {
        ANIMATION_DURATION(ctx2) {
          var _a2, _b2;
          return parseMs((_a2 = ctx2.styles) == null ? void 0 : _a2.animationDuration) + parseMs((_b2 = ctx2.styles) == null ? void 0 : _b2.animationDelay) + ANIMATION_TIMEOUT_MARGIN;
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        invokeOnExitComplete(ctx2) {
          var _a2;
          (_a2 = ctx2.onExitComplete) == null ? void 0 : _a2.call(ctx2);
        },
        setNode(ctx2, evt) {
          ctx2.node = ref(evt.node);
        },
        setStyles(ctx2, evt) {
          const win = evt.node.ownerDocument.defaultView || window;
          ctx2.styles = ref(win.getComputedStyle(evt.node));
        },
        syncPresence(ctx2, _evt, { send }) {
          var _a2;
          if (ctx2.present) {
            send({ type: "MOUNT", src: "presence.changed" });
            return;
          }
          if (!ctx2.present && ((_a2 = ctx2.node) == null ? void 0 : _a2.ownerDocument.visibilityState) === "hidden") {
            send({ type: "UNMOUNT", src: "visibilitychange" });
            return;
          }
          const animationName = getAnimationName(ctx2.styles);
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            var _a3, _b2;
            ctx2.unmountAnimationName = animationName;
            if (animationName === "none" || animationName === ctx2.prevAnimationName || ((_a3 = ctx2.styles) == null ? void 0 : _a3.display) === "none" || ((_b2 = ctx2.styles) == null ? void 0 : _b2.animationDuration) === "0s") {
              send({ type: "UNMOUNT", src: "presence.changed" });
            } else {
              send({ type: "UNMOUNT.SUSPEND" });
            }
          });
        },
        setPrevAnimationName(ctx2) {
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            ctx2.prevAnimationName = getAnimationName(ctx2.styles);
          });
        },
        clearPrevAnimationName(ctx2) {
          ctx2.prevAnimationName = null;
        }
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          const node2 = ctx2.node;
          if (!node2) return;
          const onStart = (event) => {
            var _a2, _b2;
            const target = ((_b2 = (_a2 = event.composedPath) == null ? void 0 : _a2.call(event)) == null ? void 0 : _b2[0]) ?? event.target;
            if (target === node2) {
              ctx2.prevAnimationName = getAnimationName(ctx2.styles);
            }
          };
          const onEnd = (event) => {
            var _a2, _b2;
            const animationName = getAnimationName(ctx2.styles);
            const target = ((_b2 = (_a2 = event.composedPath) == null ? void 0 : _a2.call(event)) == null ? void 0 : _b2[0]) ?? event.target;
            if (target === node2 && animationName === ctx2.unmountAnimationName) {
              send({ type: "UNMOUNT", src: "animationend" });
            }
          };
          node2.addEventListener("animationstart", onStart);
          node2.addEventListener("animationcancel", onEnd);
          node2.addEventListener("animationend", onEnd);
          return () => {
            node2.removeEventListener("animationstart", onStart);
            node2.removeEventListener("animationcancel", onEnd);
            node2.removeEventListener("animationend", onEnd);
          };
        }
      }
    }
  );
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function parseMs(value) {
  return parseFloat(value || "0") * 1e3;
}
var ANIMATION_TIMEOUT_MARGIN = 16.667;
createProps()(["onExitComplete", "present", "immediate"]);
const usePresence = (props) => {
  const { lazyMount, unmountOnExit, ...rest } = props;
  const wasEverPresent = reactExports.useRef(false);
  const context = {
    ...rest,
    onExitComplete: useEvent(props.onExitComplete)
  };
  const [state, send] = useMachine(machine$3(context), { context });
  const api = connect$4(state, send);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = () => ({
    "data-state": props.present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    ref: api.setNode,
    getPresenceProps,
    present: api.present,
    unmounted
  };
};
const [PresenceProvider, usePresenceContext] = createContext$1({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});
const splitPresenceProps = (props) => createSplitProps()(props, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "unmountOnExit"
]);
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node2) {
  return node2 && (node2.host || unwrapHost(node2.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node2) {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        try {
          var attr = node2.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node2) || 0) + 1;
          var markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenNodes.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node2, true);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node2.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node2, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node2) {
      var counterValue = counterMap.get(node2) - 1;
      var markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var raf = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options = {}) {
  const { defer = true } = options;
  const func = defer ? raf : (v2) => v2();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements2 = targets.filter(Boolean);
      if (elements2.length === 0) return;
      cleanups2.push(hideOthers(elements2));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
var LOCK_CLASSNAME = "data-scroll-lock";
function assignStyle(el2, style) {
  if (!el2) return;
  const previousStyle = Object.keys(style).reduce(
    (acc, key) => {
      acc[key] = el2.style.getPropertyValue(key);
      return acc;
    },
    {}
  );
  Object.assign(el2.style, style);
  return () => {
    Object.assign(el2.style, previousStyle);
  };
}
function setCSSProperty(el2, property, value) {
  if (!el2) return;
  const previousValue = el2.style.getPropertyValue(property);
  el2.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el2.style.setProperty(property, previousValue);
    } else {
      el2.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setStyle2 = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
    const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups2 = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle2()];
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node2, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node2 && isInert2(node2.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node2) {
  var _node$getAttribute2;
  var attValue = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute2 = node2.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node2, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el2, includeContainer, filter) {
  if (isInert(el2)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el2.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el2, candidateSelector)) {
    candidates.unshift(el2);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements2, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements2);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content2 = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content2, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements2.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node2) {
  return !isNaN(parseInt(node2.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node2) {
  if (!node2) {
    throw new Error("No node provided");
  }
  if (node2.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node2.tagName) || isContentEditable(node2)) && !hasTabIndex(node2)) {
      return 0;
    }
  }
  return node2.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node2, isScope) {
  var tabIndex = getTabIndex(node2);
  if (tabIndex < 0 && isScope && !hasTabIndex(node2)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b2) {
  return a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node2) {
  return node2.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node2) {
  return isInput(node2) && node2.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node2) {
  var r2 = node2.tagName === "DETAILS" && Array.prototype.slice.apply(node2.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node2) {
  if (!node2.name) {
    return true;
  }
  var radioScope = node2.form || getRootNode(node2);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node2.name));
  } else {
    try {
      radioSet = queryRadios(node2.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node2.form);
  return !checked || checked === node2;
};
var isRadio = function isRadio2(node2) {
  return isInput(node2) && node2.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node2) {
  return isRadio(node2) && !isTabbableRadio(node2);
};
var isNodeAttached = function isNodeAttached2(node2) {
  var _nodeRoot;
  var nodeRoot = node2 && getRootNode(node2);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node2) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node2 !== null && node2 !== void 0 && (_node$ownerDocument = node2.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node2));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node2) {
  var _node$getBoundingClie = node2.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node2, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node2).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node2, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node2.parentElement : node2;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node2;
      while (node2) {
        var parentElement = node2.parentElement;
        var rootNode = getRootNode(node2);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node2);
        } else if (node2.assignedSlot) {
          node2 = node2.assignedSlot;
        } else if (!parentElement && rootNode !== node2.ownerDocument) {
          node2 = rootNode.host;
        } else {
          node2 = parentElement;
        }
      }
      node2 = originalNode;
    }
    if (isNodeAttached(node2)) {
      return !node2.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node2);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node2) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node2.tagName)) {
    var parentNode = node2.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node2);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node2) {
  if (node2.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node2) || isHiddenInput(node2) || isHidden(node2, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node2) || isDisabledFromFieldset(node2)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node2) {
  if (isNonTabbableRadio(node2) || getTabIndex(node2) < 0 || !isNodeMatchingSelectorFocusable(options, node2)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item2, i) {
    var isScope = !!item2.scopeParent;
    var element = isScope ? item2.scopeParent : item2;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements2 = isScope ? sortByOrder2(item2.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements2) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item: item2,
        isScope,
        content: elements2
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node2, options) {
  options = options || {};
  if (!node2) {
    throw new Error("No node provided");
  }
  if (matches.call(node2, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node2);
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node2, options) {
  options = options || {};
  if (!node2) {
    throw new Error("No node provided");
  }
  if (matches.call(node2, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node2);
};
/*!
* focus-trap 7.6.0
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function _defineProperty$1(e2, r2, t2) {
  return (r2 = _toPropertyKey$1(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _toPrimitive$1(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey$1(t2) {
  var i = _toPrimitive$1(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput2(node2) {
  return node2.tagName && node2.tagName.toLowerCase() === "input" && typeof node2.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e2) {
  return (e2 === null || e2 === void 0 ? void 0 : e2.key) === "Escape" || (e2 === null || e2 === void 0 ? void 0 : e2.key) === "Esc" || (e2 === null || e2 === void 0 ? void 0 : e2.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e2) {
  return (e2 === null || e2 === void 0 ? void 0 : e2.key) === "Tab" || (e2 === null || e2 === void 0 ? void 0 : e2.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e2) {
  return isTabEvent(e2) && !e2.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e2) {
  return isTabEvent(e2) && e2.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i) {
    if (fn(value)) {
      idx = i;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements2, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config2 = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config2[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node2) {
        return node2 === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config2[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node2 = optionValue;
    if (typeof optionValue === "string") {
      node2 = doc.querySelector(optionValue);
      if (!node2) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node2;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node2 = getNodeForOption("initialFocus");
    if (node2 === false) {
      return false;
    }
    if (node2 === void 0 || !isFocusable(node2, config2.tabbableOptions)) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node2 = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node2 = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node2) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node2;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config2.tabbableOptions);
      var focusableNodes = focusable(container, config2.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node2) {
        return isTabbable(node2);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node2) {
        return isTabbable(node2);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node2) {
        return getTabIndex(node2) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node2) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node2);
          if (nodeIdx < 0) {
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node2) + 1).find(function(el2) {
                return isTabbable(el2);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node2)).reverse().find(function(el2) {
              return isTabbable(el2);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group2) {
      return group2.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state.containerGroups.find(function(g2) {
      return g2.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var _getActiveElement = function getActiveElement2(el2) {
    var activeElement = el2.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return _getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var _tryFocus = function tryFocus(node2) {
    if (node2 === false) {
      return;
    }
    if (node2 === _getActiveElement(document)) {
      return;
    }
    if (!node2 || !node2.focus) {
      _tryFocus(getInitialFocusNode());
      return;
    }
    node2.focus({
      preventScroll: !!config2.preventScroll
    });
    state.mostRecentlyFocusedNode = node2;
    if (isSelectableInput(node2)) {
      node2.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node2 = getNodeForOption("setReturnFocus", previousActiveElement);
    return node2 ? node2 : node2 === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref2) {
    var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var firstTabbableNode = _ref3.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
          var lastTabbableNode = _ref4.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target, e2) >= 0) {
      return;
    }
    if (valueOrHandler(config2.clickOutsideDeactivates, e2)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config2.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config2.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      event.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node2) {
              return node2 === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config2.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state.containerGroups.some(function(g2) {
            return g2.tabbableNodes.some(function(n2) {
              return getTabIndex(n2) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config2.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        _tryFocus(nextNode);
      } else {
        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      _tryFocus(destinationNode);
    }
  };
  var checkTabKey = function checkTabKey2(event) {
    if (config2.isKeyForward(event) || config2.isKeyBackward(event)) {
      checkKeyNav(event, config2.isKeyBackward(event));
    }
  };
  var checkEscapeKey = function checkEscapeKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config2.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
    }
  };
  var checkClick = function checkClick2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target, e2) >= 0) {
      return;
    }
    if (valueOrHandler(config2.clickOutsideDeactivates, e2)) {
      return;
    }
    if (valueOrHandler(config2.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
    e2.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config2.delayInitialFocus ? delay(function() {
      _tryFocus(getInitialFocusNode());
    }) : _tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkTabKey, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkTabKey, true);
    doc.removeEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node2) {
        return node2 === state.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      _tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config2.onDeactivate,
        onPostDeactivate: config2.onPostDeactivate,
        checkCanReturnFocus: config2.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (state.paused || !state.active) {
        return this;
      }
      var onPause = getOption(pauseOptions, "onPause");
      var onPostPause = getOption(pauseOptions, "onPostPause");
      state.paused = true;
      onPause === null || onPause === void 0 || onPause();
      removeListeners();
      updateObservedNodes();
      onPostPause === null || onPostPause === void 0 || onPostPause();
      return this;
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.paused || !state.active) {
        return this;
      }
      var onUnpause = getOption(unpauseOptions, "onUnpause");
      var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
      state.paused = false;
      onUnpause === null || onUnpause === void 0 || onUnpause();
      updateTabbableNodes();
      addListeners();
      updateObservedNodes();
      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  trap.updateContainerElements(elements2);
  return trap;
};
var anatomy$h = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
anatomy$h.build();
var dom$h = createScope({
  getPositionerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.positioner) ?? `dialog:${ctx.id}:positioner`;
  },
  getBackdropId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.backdrop) ?? `dialog:${ctx.id}:backdrop`;
  },
  getContentId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.content) ?? `dialog:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.trigger) ?? `dialog:${ctx.id}:trigger`;
  },
  getTitleId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.title) ?? `dialog:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.description) ?? `dialog:${ctx.id}:description`;
  },
  getCloseTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.closeTrigger) ?? `dialog:${ctx.id}:close`;
  },
  getContentEl: (ctx) => dom$h.getById(ctx, dom$h.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$h.getById(ctx, dom$h.getPositionerId(ctx)),
  getBackdropEl: (ctx) => dom$h.getById(ctx, dom$h.getBackdropId(ctx)),
  getTriggerEl: (ctx) => dom$h.getById(ctx, dom$h.getTriggerId(ctx)),
  getTitleEl: (ctx) => dom$h.getById(ctx, dom$h.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom$h.getById(ctx, dom$h.getDescriptionId(ctx)),
  getCloseTriggerEl: (ctx) => dom$h.getById(ctx, dom$h.getCloseTriggerId(ctx))
});
createProps()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
const [FieldProvider, useFieldContext] = createContext$1({
  name: "FieldContext",
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});
var anatomy$g = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
anatomy$g.build();
var dom$g = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `editable:${ctx.id}`;
  },
  getAreaId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.area) ?? `editable:${ctx.id}:area`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `editable:${ctx.id}:label`;
  },
  getPreviewId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.preview) ?? `editable:${ctx.id}:preview`;
  },
  getInputId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.input) ?? `editable:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.control) ?? `editable:${ctx.id}:control`;
  },
  getSubmitTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.submitTrigger) ?? `editable:${ctx.id}:submit`;
  },
  getCancelTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.cancelTrigger) ?? `editable:${ctx.id}:cancel`;
  },
  getEditTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.editTrigger) ?? `editable:${ctx.id}:edit`;
  },
  getInputEl: (ctx) => dom$g.getById(ctx, dom$g.getInputId(ctx)),
  getPreviewEl: (ctx) => dom$g.getById(ctx, dom$g.getPreviewId(ctx)),
  getSubmitTriggerEl: (ctx) => dom$g.getById(ctx, dom$g.getSubmitTriggerId(ctx)),
  getCancelTriggerEl: (ctx) => dom$g.getById(ctx, dom$g.getCancelTriggerId(ctx)),
  getEditTriggerEl: (ctx) => dom$g.getById(ctx, dom$g.getEditTriggerId(ctx))
});
createProps()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEditChange",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "edit",
  "edit.controlled",
  "submitMode",
  "translations",
  "value"
]);
const FieldInput = reactExports.forwardRef((props, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field == null ? void 0 : field.getInputProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.input, { ...mergedProps, ref: ref2 });
});
FieldInput.displayName = "FieldInput";
const fieldAnatomy$1 = createAnatomy("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea",
  "requiredIndicator"
);
fieldAnatomy$1.build();
var anatomy$f = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
anatomy$f.build();
var dom$f = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `file:${ctx.id}`;
  },
  getDropzoneId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.dropzone) ?? `file:${ctx.id}:dropzone`;
  },
  getHiddenInputId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.hiddenInput) ?? `file:${ctx.id}:input`;
  },
  getTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.trigger) ?? `file:${ctx.id}:trigger`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `file:${ctx.id}:label`;
  },
  getItemId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.item) == null ? void 0 : _b2.call(_a2, id2)) ?? `file:${ctx.id}:item:${id2}`;
  },
  getItemNameId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemName) == null ? void 0 : _b2.call(_a2, id2)) ?? `file:${ctx.id}:item-name:${id2}`;
  },
  getItemSizeTextId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemSizeText) == null ? void 0 : _b2.call(_a2, id2)) ?? `file:${ctx.id}:item-size:${id2}`;
  },
  getItemPreviewId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemPreview) == null ? void 0 : _b2.call(_a2, id2)) ?? `file:${ctx.id}:item-preview:${id2}`;
  },
  getHiddenInputEl: (ctx) => dom$f.getById(ctx, dom$f.getHiddenInputId(ctx)),
  getDropzoneEl: (ctx) => dom$f.getById(ctx, dom$f.getDropzoneId(ctx))
});
createProps()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "invalid",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "required",
  "translations",
  "validate"
]);
createProps()(["file"]);
var anatomy$e = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
anatomy$e.build();
var dom$e = createScope({
  getTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.trigger) ?? `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.contextTrigger) ?? `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.content) ?? `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.arrow) ?? `menu:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.positioner) ?? `menu:${ctx.id}:popper`;
  },
  getGroupId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.group) == null ? void 0 : _b2.call(_a2, id2)) ?? `menu:${ctx.id}:group:${id2}`;
  },
  getGroupLabelId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.groupLabel) == null ? void 0 : _b2.call(_a2, id2)) ?? `menu:${ctx.id}:group-label:${id2}`;
  },
  getContentEl: (ctx) => dom$e.getById(ctx, dom$e.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$e.getById(ctx, dom$e.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom$e.getById(ctx, dom$e.getTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => ctx.highlightedValue ? dom$e.getById(ctx, ctx.highlightedValue) : null,
  getArrowEl: (ctx) => dom$e.getById(ctx, dom$e.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom$e.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom$e.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom$e.getElements(ctx)),
  getLastEl: (ctx) => last(dom$e.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom$e.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getPrevEl: (ctx, loop) => prevById(dom$e.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getElemByKey: (ctx, key) => getByTypeahead(dom$e.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),
  isTargetDisabled: (v2) => {
    return isHTMLElement$1(v2) && (v2.dataset.disabled === "" || v2.hasAttribute("disabled"));
  },
  isTriggerItem: (el2) => {
    var _a2;
    return !!((_a2 = el2 == null ? void 0 : el2.getAttribute("role")) == null ? void 0 : _a2.startsWith("menuitem")) && !!(el2 == null ? void 0 : el2.hasAttribute("aria-controls"));
  },
  getOptionFromItemEl(el2) {
    return {
      id: el2.id,
      name: el2.dataset.name,
      value: el2.dataset.value,
      valueText: el2.dataset.valueText,
      type: el2.dataset.type
    };
  }
});
createProps()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onEscapeKeyDown",
  "onSelect",
  "onHighlightChange",
  "open",
  "open.controlled",
  "positioning",
  "typeahead",
  "composite"
]);
createProps()(["closeOnSelect", "disabled", "value", "valueText"]);
createProps()(["htmlFor"]);
createProps()(["id"]);
createProps()([
  "disabled",
  "valueText",
  "closeOnSelect",
  "type",
  "value",
  "checked",
  "onCheckedChange"
]);
const [PopoverProvider, usePopoverContext] = createContext$1({
  name: "PopoverContext",
  hookName: "usePopoverContext",
  providerName: "<PopoverProvider />"
});
const PopoverAnchor = reactExports.forwardRef((props, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getAnchorProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverAnchor.displayName = "PopoverAnchor";
const PopoverArrow$1 = reactExports.forwardRef((props, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getArrowProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrow$1.displayName = "PopoverArrow";
const PopoverArrowTip$1 = reactExports.forwardRef((props, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getArrowTipProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrowTip$1.displayName = "PopoverArrowTip";
const PopoverCloseTrigger$1 = reactExports.forwardRef(
  (props, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps(popover.getCloseTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PopoverCloseTrigger$1.displayName = "PopoverCloseTrigger";
const PopoverContent$2 = reactExports.forwardRef((props, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(popover.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
PopoverContent$2.displayName = "PopoverContent";
const PopoverDescription = reactExports.forwardRef(
  (props, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps(popover.getDescriptionProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverDescription.displayName = "PopoverDescription";
const PopoverIndicator = reactExports.forwardRef((props, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getIndicatorProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverIndicator.displayName = "PopoverIndicator";
const PopoverPositioner$1 = reactExports.forwardRef(
  (props, ref2) => {
    const popover = usePopoverContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps(popover.getPositionerProps(), props);
    if (presence.unmounted) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverPositioner$1.displayName = "PopoverPositioner";
var anatomy$d = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts$3 = anatomy$d.build();
var dom$d = createScope({
  getAnchorId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.anchor) ?? `popover:${ctx.id}:anchor`;
  },
  getTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.trigger) ?? `popover:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.content) ?? `popover:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.positioner) ?? `popover:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.arrow) ?? `popover:${ctx.id}:arrow`;
  },
  getTitleId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.title) ?? `popover:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.description) ?? `popover:${ctx.id}:desc`;
  },
  getCloseTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.closeTrigger) ?? `popover:${ctx.id}:close`;
  },
  getAnchorEl: (ctx) => dom$d.getById(ctx, dom$d.getAnchorId(ctx)),
  getTriggerEl: (ctx) => dom$d.getById(ctx, dom$d.getTriggerId(ctx)),
  getContentEl: (ctx) => dom$d.getById(ctx, dom$d.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$d.getById(ctx, dom$d.getPositionerId(ctx)),
  getTitleEl: (ctx) => dom$d.getById(ctx, dom$d.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom$d.getById(ctx, dom$d.getDescriptionId(ctx)),
  getFocusableEls: (ctx) => getFocusables(dom$d.getContentEl(ctx)),
  getFirstFocusableEl: (ctx) => dom$d.getFocusableEls(ctx)[0]
});
function connect$3(state, send, normalize2) {
  const open = state.matches("open");
  const currentPlacement = state.context.currentPlacement;
  const portalled = state.context.currentPortalled;
  const rendered = state.context.renderedElements;
  const popperStyles = getPlacementStyles({
    ...state.context.positioning,
    placement: currentPlacement
  });
  return {
    portalled,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom$d.getArrowId(state.context),
        ...parts$3.arrow.attrs,
        dir: state.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts$3.arrowTip.attrs,
        dir: state.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getAnchorProps() {
      return normalize2.element({
        ...parts$3.anchor.attrs,
        dir: state.context.dir,
        id: dom$d.getAnchorId(state.context)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts$3.trigger.attrs,
        dir: state.context.dir,
        type: "button",
        "data-placement": currentPlacement,
        id: dom$d.getTriggerId(state.context),
        "aria-haspopup": "dialog",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom$d.getContentId(state.context),
        onPointerDown(event) {
          if (isSafari()) {
            event.currentTarget.focus();
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        },
        onBlur(event) {
          send({ type: "TRIGGER_BLUR", target: event.relatedTarget });
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts$3.indicator.attrs,
        dir: state.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom$d.getPositionerId(state.context),
        ...parts$3.positioner.attrs,
        dir: state.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts$3.content.attrs,
        dir: state.context.dir,
        id: dom$d.getContentId(state.context),
        tabIndex: -1,
        role: "dialog",
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-expanded": dataAttr$1(open),
        "aria-labelledby": rendered.title ? dom$d.getTitleId(state.context) : void 0,
        "aria-describedby": rendered.description ? dom$d.getDescriptionId(state.context) : void 0,
        "data-placement": currentPlacement
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts$3.title.attrs,
        id: dom$d.getTitleId(state.context),
        dir: state.context.dir
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts$3.description.attrs,
        id: dom$d.getDescriptionId(state.context),
        dir: state.context.dir
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts$3.closeTrigger.attrs,
        dir: state.context.dir,
        id: dom$d.getCloseTriggerId(state.context),
        type: "button",
        "aria-label": "close",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLOSE");
        }
      });
    }
  };
}
function machine$2(userContext) {
  const ctx = compact$1(userContext);
  return createMachine(
    {
      id: "popover",
      initial: ctx.open ? "open" : "closed",
      context: {
        closeOnInteractOutside: true,
        closeOnEscape: true,
        autoFocus: true,
        modal: false,
        portalled: true,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        },
        currentPlacement: void 0,
        ...ctx,
        renderedElements: {
          title: true,
          description: true
        }
      },
      computed: {
        currentPortalled: (ctx2) => !!ctx2.modal || !!ctx2.portalled
      },
      watch: {
        open: ["toggleVisibility"]
      },
      entry: ["checkRenderedElements"],
      states: {
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ]
          }
        },
        open: {
          activities: [
            "trapFocus",
            "preventScroll",
            "hideContentBelow",
            "trackPositioning",
            "trackDismissableElement",
            "proxyTabFocus"
          ],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["setFinalFocus"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = dom$d.getAnchorEl(ctx2) ?? dom$d.getTriggerEl(ctx2);
          const getPositionerEl = () => dom$d.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom$d.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(getContentEl, {
            pointerBlocking: ctx2.modal,
            exclude: dom$d.getTriggerEl(ctx2),
            defer: true,
            onEscapeKeyDown(event) {
              var _a2;
              (_a2 = ctx2.onEscapeKeyDown) == null ? void 0 : _a2.call(ctx2, event);
              if (ctx2.closeOnEscape) return;
              event.preventDefault();
            },
            onInteractOutside(event) {
              var _a2;
              (_a2 = ctx2.onInteractOutside) == null ? void 0 : _a2.call(ctx2, event);
              if (event.defaultPrevented) return;
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            persistentElements: ctx2.persistentElements,
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        proxyTabFocus(ctx2) {
          if (ctx2.modal || !ctx2.portalled) return;
          const getContentEl = () => dom$d.getContentEl(ctx2);
          return proxyTabFocus(getContentEl, {
            triggerElement: dom$d.getTriggerEl(ctx2),
            defer: true,
            onFocus(el2) {
              el2.focus({ preventScroll: true });
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom$d.getContentEl(ctx2), dom$d.getTriggerEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        },
        preventScroll(ctx2) {
          if (!ctx2.modal) return;
          return preventBodyScroll(dom$d.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.modal) return;
          let trap;
          nextTick(() => {
            const contentEl = dom$d.getContentEl(ctx2);
            if (!contentEl) return;
            trap = createFocusTrap(contentEl, {
              escapeDeactivates: false,
              allowOutsideClick: true,
              preventScroll: true,
              returnFocusOnDeactivate: true,
              document: dom$d.getDoc(ctx2),
              fallbackFocus: contentEl,
              initialFocus: getInitialFocus({
                root: dom$d.getContentEl(ctx2),
                getInitialEl: ctx2.initialFocusEl,
                enabled: ctx2.autoFocus
              })
            });
            try {
              trap.activate();
            } catch {
            }
          });
          return () => trap == null ? void 0 : trap.deactivate();
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const anchorEl = dom$d.getAnchorEl(ctx2) ?? dom$d.getTriggerEl(ctx2);
          const getPositionerEl = () => dom$d.getPositionerEl(ctx2);
          getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        checkRenderedElements(ctx2) {
          raf$1(() => {
            Object.assign(ctx2.renderedElements, {
              title: !!dom$d.getTitleEl(ctx2),
              description: !!dom$d.getDescriptionEl(ctx2)
            });
          });
        },
        setInitialFocus(ctx2) {
          if (ctx2.modal) return;
          raf$1(() => {
            const element = getInitialFocus({
              root: dom$d.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl,
              enabled: ctx2.autoFocus
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setFinalFocus(ctx2, evt) {
          var _a2;
          const restoreFocus = evt.restoreFocus ?? ((_a2 = evt.previousEvent) == null ? void 0 : _a2.restoreFocus);
          if (restoreFocus != null && !restoreFocus) return;
          raf$1(() => {
            const element = dom$d.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        invokeOnOpen(ctx2) {
          var _a2;
          (_a2 = ctx2.onOpenChange) == null ? void 0 : _a2.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a2;
          (_a2 = ctx2.onOpenChange) == null ? void 0 : _a2.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
createProps()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
const usePopover = (props = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: reactExports.useId(),
    dir,
    getRootNode: getRootNode2,
    open: props.defaultOpen,
    "open.controlled": props.open !== void 0,
    ...props
  };
  const context = {
    ...initialContext,
    open: props.open,
    onOpenChange: useEvent(props.onOpenChange, { sync: true })
  };
  const [state, send] = useMachine(machine$2(initialContext), { context });
  return connect$3(state, send, normalizeProps);
};
const PopoverRoot$2 = (props) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props);
  const popover = usePopover(localProps);
  const presence = usePresence(mergeProps({ present: popover.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverProvider, { value: popover, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) });
};
const PopoverRootProvider = (props) => {
  const [presenceProps, { value: popover, children }] = splitPresenceProps(props);
  const presence = usePresence(mergeProps({ present: popover.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverProvider, { value: popover, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) });
};
const PopoverTitle = reactExports.forwardRef((props, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getTitleProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverTitle.displayName = "PopoverTitle";
const PopoverTrigger$2 = reactExports.forwardRef((props, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...popover.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : popover.getTriggerProps()["aria-controls"]
    },
    props
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
});
PopoverTrigger$2.displayName = "PopoverTrigger";
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  return event.detail === 0 && !event.pointerType;
}
function isValidKey(e2) {
  return !(e2.metaKey || !isMac() && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e2) {
  const target = e2 ? getEventTarget(e2) : null;
  const win = getWindow$2(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target == null ? void 0 : target.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e2 instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e2.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e2) {
  for (let handler of changeHandlers) {
    handler(modality, e2);
  }
}
function handleKeyboardEvent(e2) {
  hasEventBeforeFocus = true;
  if (isValidKey(e2)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e2);
  }
}
function handlePointerEvent(e2) {
  currentModality = "pointer";
  if (e2.type === "mousedown" || e2.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e2);
  }
}
function handleClickEvent(e2) {
  if (isVirtualClick(e2)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e2) {
  const target = getEventTarget(e2);
  if (target === getWindow$2(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e2);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root2) {
  if (typeof window === "undefined" || listenerMap.get(getWindow$2(root2))) {
    return;
  }
  const win = getWindow$2(root2);
  const doc = getDocument(root2);
  let focus = win.HTMLElement.prototype.focus;
  win.HTMLElement.prototype.focus = function() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root2);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root2, loadListener) => {
  const win = getWindow$2(root2);
  const doc = getDocument(root2);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props = {}) {
  const { isTextInput, autoFocus, onChange, root: root2 } = props;
  setupGlobalFocusEvents(root2);
  onChange == null ? void 0 : onChange({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e2) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e2)) return;
    onChange == null ? void 0 : onChange({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}
var anatomy$c = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
anatomy$c.build();
var dom$c = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `radio-group:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `radio-group:${ctx.id}:label`;
  },
  getItemId: (ctx, value) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.item) == null ? void 0 : _b2.call(_a2, value)) ?? `radio-group:${ctx.id}:radio:${value}`;
  },
  getItemHiddenInputId: (ctx, value) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemHiddenInput) == null ? void 0 : _b2.call(_a2, value)) ?? `radio-group:${ctx.id}:radio:input:${value}`;
  },
  getItemControlId: (ctx, value) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemControl) == null ? void 0 : _b2.call(_a2, value)) ?? `radio-group:${ctx.id}:radio:control:${value}`;
  },
  getItemLabelId: (ctx, value) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemLabel) == null ? void 0 : _b2.call(_a2, value)) ?? `radio-group:${ctx.id}:radio:label:${value}`;
  },
  getIndicatorId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.indicator) ?? `radio-group:${ctx.id}:indicator`;
  },
  getRootEl: (ctx) => dom$c.getById(ctx, dom$c.getRootId(ctx)),
  getItemHiddenInputEl: (ctx, value) => dom$c.getById(ctx, dom$c.getItemHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom$c.getById(ctx, dom$c.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => {
    var _a2;
    return (_a2 = dom$c.getRootEl(ctx)) == null ? void 0 : _a2.querySelector("input:not(:disabled)");
  },
  getFirstEnabledAndCheckedInputEl: (ctx) => {
    var _a2;
    return (_a2 = dom$c.getRootEl(ctx)) == null ? void 0 : _a2.querySelector("input:not(:disabled):checked");
  },
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom$c.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom$c.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value) return;
    return dom$c.getById(ctx, dom$c.getItemId(ctx, ctx.value));
  },
  getOffsetRect: (el2) => ({
    left: (el2 == null ? void 0 : el2.offsetLeft) ?? 0,
    top: (el2 == null ? void 0 : el2.offsetTop) ?? 0,
    width: (el2 == null ? void 0 : el2.offsetWidth) ?? 0,
    height: (el2 == null ? void 0 : el2.offsetHeight) ?? 0
  }),
  getRectById: (ctx, id2) => {
    const radioEl = dom$c.getById(ctx, dom$c.getItemId(ctx, id2));
    if (!radioEl) return;
    return dom$c.resolveRect(dom$c.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
createProps()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value"
]);
createProps()(["value", "disabled", "invalid"]);
var anatomy$b = createAnatomy("rating-group").parts("root", "label", "item", "control");
anatomy$b.build();
var dom$b = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `rating:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `rating:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.hiddenInput) ?? `rating:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.control) ?? `rating:${ctx.id}:control`;
  },
  getItemId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.item) == null ? void 0 : _b2.call(_a2, id2)) ?? `rating:${ctx.id}:item:${id2}`;
  },
  getRootEl: (ctx) => dom$b.getById(ctx, dom$b.getRootId(ctx)),
  getControlEl: (ctx) => dom$b.getById(ctx, dom$b.getControlId(ctx)),
  getRadioEl: (ctx, value = ctx.value) => {
    const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
    return query(dom$b.getControlEl(ctx), selector);
  },
  getHiddenInputEl: (ctx) => dom$b.getById(ctx, dom$b.getHiddenInputId(ctx)),
  dispatchChangeEvent: (ctx) => {
    const inputEl = dom$b.getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: ctx.value });
  }
});
createProps()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value"
]);
createProps()(["index"]);
var anatomy$a = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
anatomy$a.build();
var dom$a = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `select:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.content) ?? `select:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.trigger) ?? `select:${ctx.id}:trigger`;
  },
  getClearTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.clearTrigger) ?? `select:${ctx.id}:clear-trigger`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `select:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.control) ?? `select:${ctx.id}:control`;
  },
  getItemId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.item) == null ? void 0 : _b2.call(_a2, id2)) ?? `select:${ctx.id}:option:${id2}`;
  },
  getHiddenSelectId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.hiddenSelect) ?? `select:${ctx.id}:select`;
  },
  getPositionerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.positioner) ?? `select:${ctx.id}:positioner`;
  },
  getItemGroupId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemGroup) == null ? void 0 : _b2.call(_a2, id2)) ?? `select:${ctx.id}:optgroup:${id2}`;
  },
  getItemGroupLabelId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.itemGroupLabel) == null ? void 0 : _b2.call(_a2, id2)) ?? `select:${ctx.id}:optgroup-label:${id2}`;
  },
  getHiddenSelectEl: (ctx) => dom$a.getById(ctx, dom$a.getHiddenSelectId(ctx)),
  getContentEl: (ctx) => dom$a.getById(ctx, dom$a.getContentId(ctx)),
  getControlEl: (ctx) => dom$a.getById(ctx, dom$a.getControlId(ctx)),
  getTriggerEl: (ctx) => dom$a.getById(ctx, dom$a.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom$a.getById(ctx, dom$a.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom$a.getById(ctx, dom$a.getPositionerId(ctx)),
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedValue) return null;
    return dom$a.getById(ctx, dom$a.getItemId(ctx, ctx.highlightedValue));
  }
});
createProps()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "deselectable",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "open.controlled",
  "open",
  "composite",
  "positioning",
  "required",
  "readOnly",
  "scrollToIndexFn",
  "value"
]);
createProps()(["item", "persistFocus"]);
createProps()(["id"]);
createProps()(["htmlFor"]);
var anatomy$9 = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker",
  "draggingIndicator"
);
anatomy$9.build();
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(ctx) {
  const [firstPercent, lastPercent] = getBounds(ctx.valuePercent);
  if (ctx.valuePercent.length === 1) {
    if (ctx.origin === "center") {
      const isNegative = ctx.valuePercent[0] < 50;
      const start = isNegative ? `${ctx.valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - ctx.valuePercent[0]}%`;
      return { start, end };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(ctx) {
  if (ctx.isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(ctx) {
  const { height = 0 } = ctx.thumbSize ?? {};
  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset(ctx) {
  const { width = 0 } = ctx.thumbSize ?? {};
  if (ctx.isRtl) {
    const getValue2 = getValueTransformer([ctx.max, ctx.min], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
  }
  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getOffset(ctx, percent) {
  if (ctx.thumbAlignment === "center") return `${percent}%`;
  const offset2 = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);
  return `calc(${percent}% - ${offset2}px)`;
}
function getThumbOffset(ctx) {
  let percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100;
  return getOffset(ctx, percent);
}
function getVisibility(ctx) {
  let visibility = "visible";
  if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(ctx, index) {
  const placementProp = ctx.isVertical ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility(ctx),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle(ctx) {
  const range2 = getRangeOffsets(ctx);
  const offsetStyles = ctx.value.reduce((styles, value, index) => {
    const offset2 = getThumbOffset({ ...ctx, value });
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset2 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : ctx.isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range2.start,
    "--slider-range-end": range2.end
  };
}
function getMarkerStyle(ctx, value) {
  return {
    // @ts-expect-error
    visibility: getVisibility(ctx),
    position: "absolute",
    pointerEvents: "none",
    // @ts-expect-error
    [ctx.isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset({ ...ctx, value }),
    translate: "var(--tx) var(--ty)",
    "--tx": ctx.isHorizontal ? ctx.isRtl ? "50%" : "-50%" : "0%",
    "--ty": !ctx.isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
var styleGetterFns = {
  getRootStyle,
  getControlStyle,
  getThumbStyle,
  getRangeStyle,
  getMarkerStyle,
  getMarkerGroupStyle
};
var dom$9 = createScope({
  ...styleGetterFns,
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `slider:${ctx.id}`;
  },
  getThumbId: (ctx, index) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.thumb) == null ? void 0 : _b2.call(_a2, index)) ?? `slider:${ctx.id}:thumb:${index}`;
  },
  getHiddenInputId: (ctx, index) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.hiddenInput) == null ? void 0 : _b2.call(_a2, index)) ?? `slider:${ctx.id}:input:${index}`;
  },
  getControlId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.control) ?? `slider:${ctx.id}:control`;
  },
  getTrackId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.track) ?? `slider:${ctx.id}:track`;
  },
  getRangeId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.range) ?? `slider:${ctx.id}:range`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `slider:${ctx.id}:label`;
  },
  getValueTextId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.valueText) ?? `slider:${ctx.id}:value-text`;
  },
  getMarkerId: (ctx, value) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.marker) == null ? void 0 : _b2.call(_a2, value)) ?? `slider:${ctx.id}:marker:${value}`;
  },
  getRootEl: (ctx) => dom$9.getById(ctx, dom$9.getRootId(ctx)),
  getThumbEl: (ctx, index) => dom$9.getById(ctx, dom$9.getThumbId(ctx, index)),
  getHiddenInputEl: (ctx, index) => dom$9.getById(ctx, dom$9.getHiddenInputId(ctx, index)),
  getControlEl: (ctx) => dom$9.getById(ctx, dom$9.getControlId(ctx)),
  getElements: (ctx) => queryAll(dom$9.getControlEl(ctx), "[role=slider]"),
  getFirstEl: (ctx) => dom$9.getElements(ctx)[0],
  getRangeEl: (ctx) => dom$9.getById(ctx, dom$9.getRangeId(ctx)),
  getValueFromPoint(ctx, point) {
    const controlEl = dom$9.getControlEl(ctx);
    if (!controlEl) return;
    const relativePoint = getRelativePoint(point, controlEl);
    const percent = relativePoint.getPercentValue({
      orientation: ctx.orientation,
      dir: ctx.dir,
      inverted: { y: true }
    });
    return getPercentValue(percent, ctx.min, ctx.max, ctx.step);
  },
  dispatchChangeEvent(ctx) {
    const valueArray = Array.from(ctx.value);
    valueArray.forEach((value, index) => {
      const inputEl = dom$9.getHiddenInputEl(ctx, index);
      if (!inputEl) return;
      dispatchInputValueEvent(inputEl, { value });
    });
  }
});
createProps()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value"
]);
createProps()(["index", "name"]);
var anatomy$8 = createAnatomy("switch").parts("root", "label", "control", "thumb");
anatomy$8.build();
var dom$8 = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `switch:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `switch:${ctx.id}:label`;
  },
  getThumbId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.thumb) ?? `switch:${ctx.id}:thumb`;
  },
  getControlId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.control) ?? `switch:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.hiddenInput) ?? `switch:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom$8.getById(ctx, dom$8.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom$8.getById(ctx, dom$8.getHiddenInputId(ctx))
});
createProps()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var anatomy$7 = createAnatomy("avatar").parts("root", "image", "fallback");
anatomy$7.build();
var dom$7 = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `avatar:${ctx.id}`;
  },
  getImageId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.image) ?? `avatar:${ctx.id}:image`;
  },
  getFallbackId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.fallback) ?? `avatar:${ctx.id}:fallback`;
  },
  getRootEl: (ctx) => dom$7.getById(ctx, dom$7.getRootId(ctx)),
  getImageEl: (ctx) => dom$7.getById(ctx, dom$7.getImageId(ctx))
});
createProps()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var anatomy$6 = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
anatomy$6.build();
var dom$6 = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `checkbox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `checkbox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.control) ?? `checkbox:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.hiddenInput) ?? `checkbox:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom$6.getById(ctx, dom$6.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom$6.getById(ctx, dom$6.getHiddenInputId(ctx))
});
createProps()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
const checkboxAnatomy = anatomy$6.extendWith("group");
const CollapsibleRootProvider = reactExports.forwardRef(
  (props, ref2) => {
    const [{ value: collapsible }, localProps] = createSplitProps()(props, [
      "value"
    ]);
    const mergedProps = mergeProps(collapsible.getRootProps(), localProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleProvider, { value: collapsible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
CollapsibleRootProvider.displayName = "CollapsibleRootProvider";
const CollapsibleTrigger = reactExports.forwardRef(
  (props, ref2) => {
    const collapsible = useCollapsibleContext();
    const mergedProps = mergeProps(collapsible.getTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleTrigger.displayName = "CollapsibleTrigger";
const fieldsetAnatomy = createAnatomy("fieldset").parts(
  "root",
  "errorText",
  "helperText",
  "legend"
);
fieldsetAnatomy.build();
var anatomy$5 = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
anatomy$5.build();
var dom$5 = createScope({
  getTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.trigger) ?? `hover-card:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.content) ?? `hover-card:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.positioner) ?? `hover-card:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.arrow) ?? `hover-card:${ctx.id}:arrow`;
  },
  getTriggerEl: (ctx) => dom$5.getById(ctx, dom$5.getTriggerId(ctx)),
  getContentEl: (ctx) => dom$5.getById(ctx, dom$5.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$5.getById(ctx, dom$5.getPositionerId(ctx))
});
createProps()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
function wrap(num, max2) {
  return (num % max2 + max2) % max2;
}
function roundToDevicePixel(num) {
  if (typeof window.devicePixelRatio !== "number") return Math.round(num);
  const dp = window.devicePixelRatio;
  return Math.floor(num * dp + 0.5) / dp;
}
var anatomy$4 = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
anatomy$4.build();
var dom$4 = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `number-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.input) ?? `number-input:${ctx.id}:input`;
  },
  getIncrementTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.incrementTrigger) ?? `number-input:${ctx.id}:inc`;
  },
  getDecrementTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.decrementTrigger) ?? `number-input:${ctx.id}:dec`;
  },
  getScrubberId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.scrubber) ?? `number-input:${ctx.id}:scrubber`;
  },
  getCursorId: (ctx) => `number-input:${ctx.id}:cursor`,
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `number-input:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom$4.getById(ctx, dom$4.getInputId(ctx)),
  getIncrementTriggerEl: (ctx) => dom$4.getById(ctx, dom$4.getIncrementTriggerId(ctx)),
  getDecrementTriggerEl: (ctx) => dom$4.getById(ctx, dom$4.getDecrementTriggerId(ctx)),
  getScrubberEl: (ctx) => dom$4.getById(ctx, dom$4.getScrubberId(ctx)),
  getCursorEl: (ctx) => dom$4.getDoc(ctx).getElementById(dom$4.getCursorId(ctx)),
  getPressedTriggerEl: (ctx, hint = ctx.hint) => {
    let btnEl = null;
    if (hint === "increment") {
      btnEl = dom$4.getIncrementTriggerEl(ctx);
    }
    if (hint === "decrement") {
      btnEl = dom$4.getDecrementTriggerEl(ctx);
    }
    return btnEl;
  },
  setupVirtualCursor(ctx) {
    if (isSafari()) return;
    dom$4.createVirtualCursor(ctx);
    return () => {
      var _a2;
      (_a2 = dom$4.getCursorEl(ctx)) == null ? void 0 : _a2.remove();
    };
  },
  preventTextSelection(ctx) {
    const doc = dom$4.getDoc(ctx);
    const html = doc.documentElement;
    const body = doc.body;
    body.style.pointerEvents = "none";
    html.style.userSelect = "none";
    html.style.cursor = "ew-resize";
    return () => {
      body.style.pointerEvents = "";
      html.style.userSelect = "";
      html.style.cursor = "";
      if (!html.style.length) {
        html.removeAttribute("style");
      }
      if (!body.style.length) {
        body.removeAttribute("style");
      }
    };
  },
  getMousementValue(ctx, event) {
    const x2 = roundToDevicePixel(event.movementX);
    const y2 = roundToDevicePixel(event.movementY);
    let hint = x2 > 0 ? "increment" : x2 < 0 ? "decrement" : null;
    if (ctx.isRtl && hint === "increment") hint = "decrement";
    if (ctx.isRtl && hint === "decrement") hint = "increment";
    const point = {
      x: ctx.scrubberCursorPoint.x + x2,
      y: ctx.scrubberCursorPoint.y + y2
    };
    const win = dom$4.getWin(ctx);
    const width = win.innerWidth;
    const half = roundToDevicePixel(7.5);
    point.x = wrap(point.x + half, width) - half;
    return { hint, point };
  },
  createVirtualCursor(ctx) {
    const doc = dom$4.getDoc(ctx);
    const el2 = doc.createElement("div");
    el2.className = "scrubber--cursor";
    el2.id = dom$4.getCursorId(ctx);
    Object.assign(el2.style, {
      width: "15px",
      height: "15px",
      position: "fixed",
      pointerEvents: "none",
      left: "0px",
      top: "0px",
      zIndex: MAX_Z_INDEX,
      transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,
      willChange: "transform"
    });
    el2.innerHTML = `
        <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
          <g transform="translate(2 3)">
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
          </g>
        </svg>`;
    doc.body.appendChild(el2);
  }
});
var anatomy$3 = createAnatomy("pinInput").parts("root", "label", "input", "control");
anatomy$3.build();
var dom$3 = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `pin-input:${ctx.id}`;
  },
  getInputId: (ctx, id2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = ctx.ids) == null ? void 0 : _a2.input) == null ? void 0 : _b2.call(_a2, id2)) ?? `pin-input:${ctx.id}:${id2}`;
  },
  getHiddenInputId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.hiddenInput) ?? `pin-input:${ctx.id}:hidden`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `pin-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.control) ?? `pin-input:${ctx.id}:control`;
  },
  getRootEl: (ctx) => dom$3.getById(ctx, dom$3.getRootId(ctx)),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom$3.getRootId(ctx));
    const selector = `input[data-ownedby=${ownerId}]`;
    return queryAll(dom$3.getRootEl(ctx), selector);
  },
  getInputEl: (ctx, id2) => dom$3.getById(ctx, dom$3.getInputId(ctx, id2)),
  getFocusedInputEl: (ctx) => dom$3.getInputEls(ctx)[ctx.focusedIndex],
  getFirstInputEl: (ctx) => dom$3.getInputEls(ctx)[0],
  getHiddenInputEl: (ctx) => dom$3.getById(ctx, dom$3.getHiddenInputId(ctx))
});
const [ProgressProvider, useProgressContext] = createContext$1({
  name: "ProgressContext",
  hookName: "useProgressContext",
  providerName: "<ProgressProvider />"
});
const ProgressLabel$1 = reactExports.forwardRef((props, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref: ref2 });
});
ProgressLabel$1.displayName = "ProgressLabel";
const ProgressRange$1 = reactExports.forwardRef((props, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getRangeProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressRange$1.displayName = "ProgressRange";
var anatomy$2 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts$2 = anatomy$2.build();
var dom$2 = createScope({
  getRootId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.root) ?? `progress-${ctx.id}`;
  },
  getTrackId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.track) ?? `progress-${ctx.id}-track`;
  },
  getLabelId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.label) ?? `progress-${ctx.id}-label`;
  },
  getCircleId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.circle) ?? `progress-${ctx.id}-circle`;
  }
});
function connect$2(state, send, normalize2) {
  const percent = state.context.percent;
  const percentAsString = state.context.isIndeterminate ? "" : `${percent}%`;
  const max2 = state.context.max;
  const min2 = state.context.min;
  const orientation = state.context.orientation;
  const translations = state.context.translations;
  const indeterminate = state.context.isIndeterminate;
  const value = state.context.value;
  const valueAsString = translations.value({ value, max: max2, percent, min: min2 });
  const progressState = getProgressState(value, max2);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max2,
    "aria-valuemin": min2,
    "aria-valuemax": max2,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps = getCircleProps(state.context);
  return {
    value,
    valueAsString,
    min: min2,
    max: max2,
    percent,
    percentAsString,
    indeterminate,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max2 });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: min2 });
    },
    getRootProps() {
      return normalize2.element({
        dir: state.context.dir,
        ...parts$2.root.attrs,
        id: dom$2.getRootId(state.context),
        "data-max": max2,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        dir: state.context.dir,
        id: dom$2.getLabelId(state.context),
        ...parts$2.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize2.element({
        dir: state.context.dir,
        "aria-live": "polite",
        ...parts$2.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize2.element({
        dir: state.context.dir,
        id: dom$2.getTrackId(state.context),
        ...parts$2.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize2.element({
        dir: state.context.dir,
        ...parts$2.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [state.context.isHorizontal ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize2.element({
        dir: state.context.dir,
        id: dom$2.getCircleId(state.context),
        ...parts$2.circle.attrs,
        ...progressbarProps,
        ...circleProps.root
      });
    },
    getCircleTrackProps() {
      return normalize2.element({
        dir: state.context.dir,
        "data-orientation": orientation,
        ...parts$2.circleTrack.attrs,
        ...circleProps.track
      });
    },
    getCircleRangeProps() {
      return normalize2.element({
        dir: state.context.dir,
        ...parts$2.circleRange.attrs,
        ...circleProps.range,
        "data-state": progressState
      });
    },
    getViewProps(props2) {
      return normalize2.element({
        dir: state.context.dir,
        ...parts$2.view.attrs,
        "data-state": props2.state,
        hidden: props2.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue2) {
  return value == null ? "indeterminate" : value === maxValue2 ? "complete" : "loading";
}
function getCircleProps(ctx) {
  const circleProps = {
    style: {
      "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
      cx: "calc(var(--size) / 2)",
      cy: "calc(var(--size) / 2)",
      r: "var(--radius)",
      fill: "transparent",
      strokeWidth: "var(--thickness)"
    }
  };
  return {
    root: {
      style: {
        width: "var(--size)",
        height: "var(--size)"
      }
    },
    track: circleProps,
    range: {
      opacity: ctx.value === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": ctx.percent,
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: ctx.isIndeterminate ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
function midValue(min2, max2) {
  return min2 + (max2 - min2) / 2;
}
function machine$1(userContext) {
  const ctx = compact$1(userContext);
  return createMachine(
    {
      id: "progress",
      initial: "idle",
      context: {
        max: ctx.max ?? 100,
        min: ctx.min ?? 0,
        value: midValue(ctx.min ?? 0, ctx.max ?? 100),
        orientation: "horizontal",
        translations: {
          value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
          ...ctx.translations
        },
        ...ctx
      },
      created: ["validateContext"],
      computed: {
        isIndeterminate: (ctx2) => ctx2.value === null,
        percent(ctx2) {
          if (!isNumber(ctx2.value)) return -1;
          return Math.round((ctx2.value - ctx2.min) / (ctx2.max - ctx2.min) * 100);
        },
        isAtMax: (ctx2) => ctx2.value === ctx2.max,
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isRtl: (ctx2) => ctx2.dir === "rtl"
      },
      states: {
        idle: {
          on: {
            "VALUE.SET": {
              actions: ["setValue"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue: (ctx2, evt) => {
          ctx2.value = evt.value === null ? null : Math.max(0, Math.min(evt.value, ctx2.max));
        },
        validateContext: (ctx2) => {
          if (ctx2.value == null) return;
          if (!isValidNumber(ctx2.max)) {
            throw new Error(`[progress] The max value passed \`${ctx2.max}\` is not a valid number`);
          }
          if (!isValidMax(ctx2.value, ctx2.max)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the max value \`${ctx2.max}\``);
          }
          if (!isValidMin(ctx2.value, ctx2.min)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the min value \`${ctx2.min}\``);
          }
        }
      }
    }
  );
}
function isValidNumber(max2) {
  return isNumber(max2) && !isNaN(max2);
}
function isValidMax(value, max2) {
  return isValidNumber(value) && value <= max2;
}
function isValidMin(value, min2) {
  return isValidNumber(value) && value >= min2;
}
createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value"
]);
const useProgress = (props = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: reactExports.useId(),
    dir,
    getRootNode: getRootNode2,
    ...props
  };
  const context = {
    ...initialContext,
    value: props.value
  };
  const [state, send] = useMachine(machine$1(initialContext), { context });
  return connect$2(state, send, normalizeProps);
};
const ProgressRoot$1 = reactExports.forwardRef((props, ref2) => {
  const [progressProps, localProps] = createSplitProps()(props, [
    "id",
    "ids",
    "max",
    "min",
    "orientation",
    "translations",
    "value"
  ]);
  const progress = useProgress(progressProps);
  const mergedProps = mergeProps(progress.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressProvider, { value: progress, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) });
});
ProgressRoot$1.displayName = "ProgressRoot";
const ProgressRootProvider = reactExports.forwardRef(
  (props, ref2) => {
    const [{ value: progress }, localProps] = createSplitProps()(props, [
      "value"
    ]);
    const mergedProps = mergeProps(progress.getRootProps(), localProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressProvider, { value: progress, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ProgressRootProvider.displayName = "ProgressRootProvider";
const ProgressTrack$1 = reactExports.forwardRef((props, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getTrackProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressTrack$1.displayName = "ProgressTrack";
const ProgressValueText$1 = reactExports.forwardRef(
  (props, ref2) => {
    const { children, ...rest } = props;
    const progress = useProgressContext();
    const mergedProps = mergeProps(progress.getValueTextProps(), rest);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref: ref2, children: children || progress.percentAsString });
  }
);
ProgressValueText$1.displayName = "ProgressValueText";
const segmentGroupAnatomy = anatomy$c.rename("segment-group");
segmentGroupAnatomy.build();
const [TooltipProvider, useTooltipContext] = createContext$1({
  name: "TooltipContext",
  hookName: "useTooltipContext",
  providerName: "<TooltipProvider />"
});
const TooltipArrow$1 = reactExports.forwardRef((props, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrow$1.displayName = "TooltipArrow";
const TooltipArrowTip$1 = reactExports.forwardRef((props, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowTipProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrowTip$1.displayName = "TooltipArrowTip";
const TooltipContent$1 = reactExports.forwardRef((props, ref2) => {
  const tooltip = useTooltipContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(tooltip.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
TooltipContent$1.displayName = "TooltipContent";
const TooltipPositioner$1 = reactExports.forwardRef(
  (props, ref2) => {
    const tooltip = useTooltipContext();
    const mergedProps = mergeProps(tooltip.getPositionerProps(), props);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TooltipPositioner$1.displayName = "TooltipPositioner";
var anatomy$1 = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts$1 = anatomy$1.build();
var dom$1 = createScope({
  getTriggerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.trigger) ?? `tooltip:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.content) ?? `tooltip:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.arrow) ?? `tooltip:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a2;
    return ((_a2 = ctx.ids) == null ? void 0 : _a2.positioner) ?? `tooltip:${ctx.id}:popper`;
  },
  getTriggerEl: (ctx) => dom$1.getById(ctx, dom$1.getTriggerId(ctx)),
  getContentEl: (ctx) => dom$1.getById(ctx, dom$1.getContentId(ctx)),
  getPositionerEl: (ctx) => dom$1.getById(ctx, dom$1.getPositionerId(ctx)),
  getArrowEl: (ctx) => dom$1.getById(ctx, dom$1.getArrowId(ctx))
});
var store = proxy({
  id: null,
  prevId: null,
  setId(val) {
    this.prevId = this.id;
    this.id = val;
  }
});
function connect$1(state, send, normalize2) {
  const id2 = state.context.id;
  const hasAriaLabel = state.context.hasAriaLabel;
  const open = state.hasTag("open");
  const triggerId = dom$1.getTriggerId(state.context);
  const contentId = dom$1.getContentId(state.context);
  const disabled = state.context.disabled;
  const popperStyles = getPlacementStyles({
    ...state.context.positioning,
    placement: state.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts$1.trigger.attrs,
        id: triggerId,
        dir: state.context.dir,
        "data-expanded": dataAttr$1(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state.context.closeOnClick) return;
          send({ type: "CLOSE", src: "trigger.click" });
        },
        onFocus(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (state.event.src === "trigger.pointerdown") return;
          if (!isFocusVisible()) return;
          send({ type: "OPEN", src: "trigger.focus" });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id2 === store.id) {
            send({ type: "CLOSE", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state.context.closeOnPointerDown) return;
          if (id2 === store.id) {
            send({ type: "CLOSE", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send("POINTER_MOVE");
        },
        onPointerLeave() {
          if (disabled) return;
          send("POINTER_LEAVE");
        },
        onPointerCancel() {
          if (disabled) return;
          send("POINTER_LEAVE");
        }
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom$1.getArrowId(state.context),
        ...parts$1.arrow.attrs,
        dir: state.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts$1.arrowTip.attrs,
        dir: state.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom$1.getPositionerId(state.context),
        ...parts$1.positioner.attrs,
        dir: state.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts$1.content.attrs,
        dir: state.context.dir,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": state.context.currentPlacement,
        onPointerEnter() {
          send("CONTENT.POINTER_MOVE");
        },
        onPointerLeave() {
          send("CONTENT.POINTER_LEAVE");
        },
        style: {
          pointerEvents: state.context.interactive ? "auto" : "none"
        }
      });
    }
  };
}
var { and: and$1, not: not$1 } = guards;
function machine(userContext) {
  const ctx = compact$1(userContext);
  return createMachine(
    {
      id: "tooltip",
      initial: ctx.open ? "open" : "closed",
      activities: ["trackFocusVisible"],
      context: {
        openDelay: 1e3,
        closeDelay: 500,
        closeOnPointerDown: true,
        closeOnEscape: true,
        interactive: false,
        closeOnScroll: true,
        closeOnClick: true,
        ...ctx,
        currentPlacement: void 0,
        hasPointerMoveOpened: false,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      computed: {
        hasAriaLabel: (ctx2) => !!ctx2["aria-label"]
      },
      watch: {
        disabled: ["closeIfDisabled"],
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearGlobalId"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            },
            POINTER_LEAVE: {
              actions: ["clearPointerMoveOpened"]
            },
            POINTER_MOVE: [
              {
                guard: and$1("noVisibleTooltip", not$1("hasPointerMoveOpened")),
                target: "opening"
              },
              {
                guard: not$1("hasPointerMoveOpened"),
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          activities: ["trackScroll", "trackPointerlockChange"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
          entry: ["setGlobalId"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            POINTER_LEAVE: [
              {
                guard: "isVisible",
                target: "closing",
                actions: ["clearPointerMoveOpened"]
              },
              // == group ==
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            "CONTENT.POINTER_LEAVE": {
              guard: "isInteractive",
              target: "closing"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackStore", "trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_MOVE: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ],
            "CONTENT.POINTER_MOVE": {
              guard: "isInteractive",
              target: "open"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      activities: {
        trackFocusVisible(ctx2) {
          return trackFocusVisible({ root: dom$1.getRootNode(ctx2) });
        },
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom$1.getPositionerEl(ctx2);
          return getPlacement(dom$1.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackPointerlockChange(ctx2, _evt, { send }) {
          const onChange = () => send({ type: "CLOSE", src: "pointerlock:change" });
          return addDomEvent(dom$1.getDoc(ctx2), "pointerlockchange", onChange, false);
        },
        trackScroll(ctx2, _evt, { send }) {
          if (!ctx2.closeOnScroll) return;
          const triggerEl = dom$1.getTriggerEl(ctx2);
          if (!triggerEl) return;
          const overflowParents = getOverflowAncestors$1(triggerEl);
          const cleanups2 = overflowParents.map((overflowParent) => {
            const onScroll = () => {
              send({ type: "CLOSE", src: "scroll" });
            };
            return addDomEvent(overflowParent, "scroll", onScroll, { passive: true, capture: true });
          });
          return () => {
            cleanups2.forEach((fn) => fn == null ? void 0 : fn());
          };
        },
        trackStore(ctx2, _evt, { send }) {
          return subscribe$1(store, () => {
            if (store.id !== ctx2.id) {
              send({ type: "CLOSE", src: "id.change" });
            }
          });
        },
        trackEscapeKey(ctx2, _evt, { send }) {
          if (!ctx2.closeOnEscape) return;
          const onKeyDown = (event) => {
            if (isComposingEvent(event)) return;
            if (event.key !== "Escape") return;
            event.stopPropagation();
            send({ type: "CLOSE", src: "keydown.escape" });
          };
          return addDomEvent(dom$1.getDoc(ctx2), "keydown", onKeyDown, true);
        }
      },
      actions: {
        setGlobalId(ctx2) {
          store.setId(ctx2.id);
        },
        clearGlobalId(ctx2) {
          if (ctx2.id === store.id) {
            store.setId(null);
          }
        },
        invokeOnOpen(ctx2) {
          var _a2;
          (_a2 = ctx2.onOpenChange) == null ? void 0 : _a2.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a2;
          (_a2 = ctx2.onOpenChange) == null ? void 0 : _a2.call(ctx2, { open: false });
        },
        closeIfDisabled(ctx2, _evt, { send }) {
          if (!ctx2.disabled) return;
          send({ type: "CLOSE", src: "disabled.change" });
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom$1.getPositionerEl(ctx2);
          getPlacement(dom$1.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        setPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = true;
        },
        clearPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = false;
        }
      },
      guards: {
        noVisibleTooltip: () => store.id === null,
        isVisible: (ctx2) => ctx2.id === store.id,
        isInteractive: (ctx2) => ctx2.interactive,
        hasPointerMoveOpened: (ctx2) => !!ctx2.hasPointerMoveOpened,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
createProps()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
const useTooltip = (props = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: reactExports.useId(),
    dir,
    getRootNode: getRootNode2,
    open: props.defaultOpen,
    "open.controlled": props.open !== void 0,
    ...props
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props.onOpenChange, { sync: true })
  };
  const [state, send] = useMachine(machine(initialContext), { context });
  return connect$1(state, send, normalizeProps);
};
const TooltipRoot$1 = (props) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props);
  const tooltip = useTooltip(localProps);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { value: tooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) });
};
const TooltipRootProvider = (props) => {
  const [presenceProps, { value: tooltip, children }] = splitPresenceProps(props);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { value: tooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) });
};
const TooltipTrigger$1 = reactExports.forwardRef((props, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
});
TooltipTrigger$1.displayName = "TooltipTrigger";
const accordionAnatomy = anatomy$j.extendWith("itemBody");
const actionBarAnatomy = createAnatomy("action-bar").parts(
  "positioner",
  "content",
  "separator",
  "selectionTrigger",
  "closeTrigger"
);
const alertAnatomy = createAnatomy("alert").parts(
  "title",
  "description",
  "root",
  "indicator",
  "content"
);
const breadcrumbAnatomy = createAnatomy("breadcrumb").parts(
  "link",
  "currentLink",
  "item",
  "list",
  "root",
  "ellipsis",
  "separator"
);
const blockquoteAnatomy = createAnatomy("blockquote").parts(
  "root",
  "icon",
  "content",
  "caption"
);
const cardAnatomy = createAnatomy("card").parts(
  "root",
  "header",
  "body",
  "footer",
  "title",
  "description"
);
const checkboxCardAnatomy = createAnatomy("checkbox-card", [
  "root",
  "control",
  "label",
  "description",
  "addon",
  "indicator",
  "content"
]);
const dataListAnatomy = createAnatomy("data-list").parts(
  "root",
  "item",
  "itemLabel",
  "itemValue"
);
const dialogAnatomy = anatomy$h.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
const drawerAnatomy = anatomy$h.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
const editableAnatomy = anatomy$g.extendWith("textarea");
const emptyStateAnatomy = createAnatomy("empty-state", [
  "root",
  "content",
  "indicator",
  "title",
  "description"
]);
const fieldAnatomy = fieldAnatomy$1.extendWith("requiredIndicator");
const fileUploadAnatomy = anatomy$f.extendWith(
  "itemContent",
  "dropzoneContent"
);
const listAnatomy = createAnatomy("list").parts(
  "root",
  "item",
  "indicator"
);
const menuAnatomy = anatomy$e.extendWith("itemCommand");
const nativeSelectAnatomy = createAnatomy("select").parts(
  "root",
  "field",
  "indicator"
);
const popoverAnatomy = anatomy$d.extendWith(
  "header",
  "body",
  "footer"
);
const radioGroupAnatomy = anatomy$c.extendWith(
  "itemAddon",
  "itemIndicator"
);
const radioCardAnatomy = radioGroupAnatomy.extendWith(
  "itemContent",
  "itemDescription"
);
const ratingGroupAnatomy = anatomy$b.extendWith("itemIndicator");
const selectAnatomy = anatomy$a.extendWith("indicatorGroup");
const sliderAnatomy = anatomy$9.extendWith("markerIndicator");
const statAnatomy = createAnatomy("stat").parts(
  "root",
  "label",
  "helpText",
  "valueText",
  "valueUnit",
  "indicator"
);
const statusAnatomy = createAnatomy("status").parts("root", "indicator");
const stepsAnatomy = createAnatomy("steps", [
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "title",
  "description",
  "nextTrigger",
  "prevTrigger",
  "progress"
]);
const switchAnatomy = anatomy$8.extendWith("indicator");
const tableAnatomy = createAnatomy("table").parts(
  "root",
  "header",
  "body",
  "row",
  "columnHeader",
  "cell",
  "footer",
  "caption"
);
const toastAnatomy = createAnatomy("toast").parts(
  "root",
  "title",
  "description",
  "indicator",
  "closeTrigger",
  "actionTrigger"
);
const tabsAnatomy = createAnatomy("tabs").parts(
  "root",
  "trigger",
  "list",
  "content",
  "contentGroup",
  "indicator"
);
const tagAnatomy = createAnatomy("tag").parts(
  "root",
  "label",
  "closeTrigger",
  "startElement",
  "endElement"
);
const timelineAnatomy = createAnatomy("timeline").parts(
  "root",
  "item",
  "content",
  "separator",
  "indicator",
  "connector",
  "title",
  "description"
);
const accordionSlotRecipe = defineSlotRecipe({
  className: "chakra-accordion",
  slots: accordionAnatomy.keys(),
  base: {
    root: {
      width: "full",
      "--accordion-radius": "radii.l2"
    },
    item: {
      overflowAnchor: "none"
    },
    itemTrigger: {
      display: "flex",
      alignItems: "center",
      width: "full",
      outline: "0",
      gap: "3",
      fontWeight: "medium",
      borderRadius: "var(--accordion-radius)",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemBody: {
      pt: "var(--accordion-padding-y)",
      pb: "calc(var(--accordion-padding-y) * 2)"
    },
    itemContent: {
      overflow: "hidden",
      borderRadius: "var(--accordion-radius)",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    },
    itemIndicator: {
      transition: "rotate 0.2s",
      transformOrigin: "center",
      color: "fg.subtle",
      _open: {
        rotate: "180deg"
      },
      _icon: {
        width: "1.2em",
        height: "1.2em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        item: {
          borderBottomWidth: "1px"
        }
      },
      subtle: {
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          borderRadius: "var(--accordion-radius)",
          _open: {
            bg: "colorPalette.subtle"
          }
        }
      },
      enclosed: {
        root: {
          borderWidth: "1px",
          borderRadius: "var(--accordion-radius)",
          divideY: "1px",
          overflow: "hidden"
        },
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          _open: {
            bg: "bg.subtle"
          }
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--accordion-padding-x": "spacing.3",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "sm",
          py: "var(--accordion-padding-y)"
        }
      },
      md: {
        root: {
          "--accordion-padding-x": "spacing.4",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "md",
          py: "var(--accordion-padding-y)"
        }
      },
      lg: {
        root: {
          "--accordion-padding-x": "spacing.4.5",
          "--accordion-padding-y": "spacing.2.5"
        },
        itemTrigger: {
          textStyle: "lg",
          py: "var(--accordion-padding-y)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const actionBarSlotRecipe = defineSlotRecipe({
  className: "chakra-action-bar",
  slots: actionBarAnatomy.keys(),
  base: {
    positioner: {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      pointerEvents: "none",
      insetInline: "0",
      top: "unset",
      bottom: "calc(env(safe-area-inset-bottom) + 20px)"
    },
    content: {
      bg: "bg.panel",
      shadow: "md",
      display: "flex",
      alignItems: "center",
      gap: "3",
      borderRadius: "l3",
      py: "2.5",
      px: "3",
      pointerEvents: "auto",
      // Stabilize the position of the action bar when the scrollbar is hidden
      // by using the scrollbar width to offset the position.
      translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
      _open: {
        animationName: "slide-from-bottom, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "slide-to-bottom, fade-out",
        animationDuration: "faster"
      }
    },
    separator: {
      width: "1px",
      height: "5",
      bg: "border"
    },
    selectionTrigger: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2",
      alignSelf: "stretch",
      textStyle: "sm",
      px: "4",
      py: "1",
      borderRadius: "l2",
      borderWidth: "1px",
      borderStyle: "dashed"
    }
  }
});
const alertSlotRecipe = defineSlotRecipe({
  slots: alertAnatomy.keys(),
  className: "chakra-alert",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      borderRadius: "l3"
    },
    title: {
      fontWeight: "medium"
    },
    description: {
      display: "inline"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      width: "1em",
      height: "1em",
      _icon: { boxSize: "full" }
    },
    content: {
      display: "flex",
      flex: "1",
      gap: "1"
    }
  },
  variants: {
    status: {
      info: {
        root: { colorPalette: "blue" }
      },
      warning: {
        root: { colorPalette: "orange" }
      },
      success: {
        root: { colorPalette: "green" }
      },
      error: {
        root: { colorPalette: "red" }
      },
      neutral: {
        root: { colorPalette: "gray" }
      }
    },
    inline: {
      true: {
        content: {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center"
        }
      },
      false: {
        content: {
          display: "flex",
          flexDirection: "column"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        }
      },
      surface: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        indicator: {
          color: "colorPalette.contrast"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "2",
          px: "3",
          py: "3",
          textStyle: "xs"
        },
        indicator: {
          textStyle: "lg"
        }
      },
      md: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "sm"
        },
        indicator: {
          textStyle: "xl"
        }
      },
      lg: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "md"
        },
        indicator: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    status: "info",
    variant: "subtle",
    size: "md",
    inline: false
  }
});
const avatarSlotRecipe = defineSlotRecipe({
  slots: anatomy$7.keys(),
  className: "chakra-avatar",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "medium",
      position: "relative",
      verticalAlign: "top",
      flexShrink: "0",
      userSelect: "none",
      width: "var(--avatar-size)",
      height: "var(--avatar-size)",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)",
      "&[data-group-item]": {
        borderWidth: "2px",
        borderColor: "bg"
      }
    },
    image: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "var(--avatar-radius)"
    },
    fallback: {
      lineHeight: "1",
      textTransform: "uppercase",
      fontWeight: "medium",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)"
    }
  },
  variants: {
    size: {
      full: {
        root: {
          "--avatar-size": "100%",
          "--avatar-font-size": "100%"
        }
      },
      "2xs": {
        root: {
          "--avatar-font-size": "fontSizes.2xs",
          "--avatar-size": "sizes.6"
        }
      },
      xs: {
        root: {
          "--avatar-font-size": "fontSizes.xs",
          "--avatar-size": "sizes.8"
        }
      },
      sm: {
        root: {
          "--avatar-font-size": "fontSizes.sm",
          "--avatar-size": "sizes.9"
        }
      },
      md: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.10"
        }
      },
      lg: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.11"
        }
      },
      xl: {
        root: {
          "--avatar-font-size": "fontSizes.lg",
          "--avatar-size": "sizes.12"
        }
      },
      "2xl": {
        root: {
          "--avatar-font-size": "fontSizes.xl",
          "--avatar-size": "sizes.16"
        }
      }
    },
    variant: {
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      subtle: {
        root: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        root: { "--avatar-radius": "radii.l3" }
      },
      full: {
        root: { "--avatar-radius": "radii.full" }
      }
    },
    borderless: {
      true: {
        root: {
          "&[data-group-item]": {
            borderWidth: "0px"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "full",
    variant: "subtle"
  }
});
const blockquoteSlotRecipe = defineSlotRecipe({
  className: "chakra-blockquote",
  slots: blockquoteAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      gap: "2"
    },
    caption: {
      textStyle: "sm",
      color: "fg.muted"
    },
    icon: {
      boxSize: "5"
    }
  },
  variants: {
    justify: {
      start: {
        root: {
          alignItems: "flex-start",
          textAlign: "start"
        }
      },
      center: {
        root: {
          alignItems: "center",
          textAlign: "center"
        }
      },
      end: {
        root: {
          alignItems: "flex-end",
          textAlign: "end"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.muted"
        },
        icon: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.solid"
        },
        icon: {
          color: "colorPalette.solid"
        }
      },
      plain: {
        root: {
          paddingX: "5"
        },
        icon: {
          color: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    justify: "start"
  }
});
const breadcrumbSlotRecipe = defineSlotRecipe({
  className: "chakra-breadcrumb",
  slots: breadcrumbAnatomy.keys(),
  base: {
    list: {
      display: "flex",
      alignItems: "center",
      wordBreak: "break-word",
      color: "fg.muted"
    },
    link: {
      outline: "0",
      textDecoration: "none",
      borderRadius: "l1",
      focusRing: "outside",
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    item: {
      display: "inline-flex",
      alignItems: "center"
    },
    separator: {
      color: "fg.muted",
      opacity: "0.8",
      _icon: {
        boxSize: "1em"
      }
    },
    ellipsis: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      _icon: {
        boxSize: "1em"
      }
    }
  },
  variants: {
    variant: {
      underline: {
        link: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "0.2em",
          textDecorationColor: "colorPalette.muted"
        },
        currentLink: {
          color: "colorPalette.fg"
        }
      },
      plain: {
        link: {
          color: "fg.muted",
          _hover: { color: "fg" }
        },
        currentLink: {
          color: "fg"
        }
      }
    },
    size: {
      sm: {
        list: {
          gap: "1",
          textStyle: "xs"
        }
      },
      md: {
        list: {
          gap: "1.5",
          textStyle: "sm"
        }
      },
      lg: {
        list: {
          gap: "2",
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain",
    size: "md"
  }
});
const cardSlotRecipe = defineSlotRecipe({
  className: "chakra-card",
  slots: cardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      minWidth: "0",
      wordWrap: "break-word",
      borderRadius: "l3",
      color: "fg",
      textAlign: "start"
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted",
      fontSize: "sm"
    },
    header: {
      paddingInline: "var(--card-padding)",
      paddingTop: "var(--card-padding)",
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    body: {
      padding: "var(--card-padding)",
      flex: "1",
      display: "flex",
      flexDirection: "column"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      paddingInline: "var(--card-padding)",
      paddingBottom: "var(--card-padding)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--card-padding": "spacing.4"
        },
        title: {
          textStyle: "md"
        }
      },
      md: {
        root: {
          "--card-padding": "spacing.6"
        },
        title: {
          textStyle: "lg"
        }
      },
      lg: {
        root: {
          "--card-padding": "spacing.7"
        },
        title: {
          textStyle: "xl"
        }
      }
    },
    variant: {
      elevated: {
        root: {
          bg: "bg.panel",
          boxShadow: "md"
        }
      },
      outline: {
        root: {
          bg: "bg.panel",
          borderWidth: "1px",
          borderColor: "border"
        }
      },
      subtle: {
        root: {
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
});
const checkboxSlotRecipe = defineSlotRecipe({
  slots: checkboxAnatomy.keys(),
  className: "chakra-checkbox",
  base: {
    root: {
      display: "inline-flex",
      gap: "2",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    },
    control: checkmarkRecipe.base,
    label: {
      fontWeight: "medium",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    size: {
      xs: {
        root: { gap: "1.5" },
        label: { textStyle: "xs" },
        control: (_b = (_a = checkmarkRecipe.variants) == null ? void 0 : _a.size) == null ? void 0 : _b.xs
      },
      sm: {
        root: { gap: "2" },
        label: { textStyle: "sm" },
        control: (_d = (_c = checkmarkRecipe.variants) == null ? void 0 : _c.size) == null ? void 0 : _d.sm
      },
      md: {
        root: { gap: "2.5" },
        label: { textStyle: "sm" },
        control: (_f = (_e = checkmarkRecipe.variants) == null ? void 0 : _e.size) == null ? void 0 : _f.md
      },
      lg: {
        root: { gap: "3" },
        label: { textStyle: "md" },
        control: (_h = (_g = checkmarkRecipe.variants) == null ? void 0 : _g.size) == null ? void 0 : _h.lg
      }
    },
    variant: {
      outline: {
        control: (_j = (_i = checkmarkRecipe.variants) == null ? void 0 : _i.variant) == null ? void 0 : _j.outline
      },
      solid: {
        control: (_l = (_k = checkmarkRecipe.variants) == null ? void 0 : _k.variant) == null ? void 0 : _l.solid
      },
      subtle: {
        control: (_n = (_m = checkmarkRecipe.variants) == null ? void 0 : _m.variant) == null ? void 0 : _n.subtle
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const checkboxCardSlotRecipe = defineSlotRecipe({
  slots: checkboxCardAnatomy.keys(),
  className: "chakra-checkbox-card",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      flex: "1",
      focusVisibleRing: "outside",
      _disabled: {
        opacity: "0.8",
        borderColor: "border.subtle"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error"
      }
    },
    control: {
      display: "inline-flex",
      flex: "1",
      position: "relative",
      borderRadius: "inherit",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    },
    label: {
      fontWeight: "medium",
      display: "flex",
      alignItems: "center",
      gap: "2",
      _disabled: {
        opacity: "0.5"
      }
    },
    description: {
      opacity: "0.64",
      textStyle: "sm"
    },
    addon: {
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: checkmarkRecipe.base,
    content: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "3",
          gap: "1.5"
        },
        addon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        indicator: (_o = checkmarkRecipe.variants) == null ? void 0 : _o.size.sm
      },
      md: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "4",
          gap: "2.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_p = checkmarkRecipe.variants) == null ? void 0 : _p.size.md
      },
      lg: {
        root: {
          textStyle: "md"
        },
        control: {
          padding: "4",
          gap: "3.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_q = checkmarkRecipe.variants) == null ? void 0 : _q.size.lg
      }
    },
    variant: {
      surface: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          },
          _disabled: {
            bg: "bg.muted"
          }
        },
        indicator: (_r = checkmarkRecipe.variants) == null ? void 0 : _r.variant.solid
      },
      subtle: {
        root: {
          bg: "bg.muted"
        },
        control: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        indicator: (_s = checkmarkRecipe.variants) == null ? void 0 : _s.variant.plain
      },
      outline: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_t = checkmarkRecipe.variants) == null ? void 0 : _t.variant.solid
      },
      solid: {
        root: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_u = checkmarkRecipe.variants) == null ? void 0 : _u.variant.inverted
      }
    },
    justify: {
      start: {
        root: { "--checkbox-card-justify": "flex-start" }
      },
      end: {
        root: { "--checkbox-card-justify": "flex-end" }
      },
      center: {
        root: { "--checkbox-card-justify": "center" }
      }
    },
    align: {
      start: {
        root: { "--checkbox-card-align": "flex-start" },
        content: { textAlign: "start" }
      },
      end: {
        root: { "--checkbox-card-align": "flex-end" },
        content: { textAlign: "end" }
      },
      center: {
        root: { "--checkbox-card-align": "center" },
        content: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        control: { flexDirection: "column" }
      },
      horizontal: {
        control: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});
const collapsibleSlotRecipe = defineSlotRecipe({
  slots: anatomy$i.keys(),
  className: "chakra-collapsible",
  base: {
    content: {
      overflow: "hidden",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    }
  }
});
const dataListSlotRecipe = defineSlotRecipe({
  slots: dataListAnatomy.keys(),
  className: "chakra-data-list",
  base: {
    itemLabel: {
      display: "flex",
      alignItems: "center",
      gap: "1"
    },
    itemValue: {
      display: "flex",
      minWidth: "0",
      flex: "1"
    }
  },
  variants: {
    orientation: {
      horizontal: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "inline-flex",
          alignItems: "center",
          gap: "4"
        },
        itemLabel: {
          minWidth: "120px"
        }
      },
      vertical: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "flex",
          flexDirection: "column",
          gap: "1"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "3"
        },
        item: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        item: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "5"
        },
        item: {
          textStyle: "md"
        }
      }
    },
    variant: {
      subtle: {
        itemLabel: {
          color: "fg.muted"
        }
      },
      bold: {
        itemLabel: {
          fontWeight: "medium"
        },
        itemValue: {
          color: "fg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    orientation: "vertical",
    variant: "subtle"
  }
});
const dialogSlotRecipe = defineSlotRecipe({
  slots: dialogAnatomy.keys(),
  className: "chakra-dialog",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      left: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      left: 0,
      top: 0,
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      justifyContent: "center",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      borderRadius: "l3",
      textStyle: "sm",
      my: "var(--dialog-margin, var(--dialog-base-margin))",
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "moderate"
      },
      _closed: {
        animationDuration: "faster"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      flex: "1",
      px: "6",
      pt: "2",
      pb: "6"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    placement: {
      center: {
        positioner: {
          alignItems: "center"
        },
        content: {
          "--dialog-base-margin": "auto",
          mx: "auto"
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      }
    },
    scrollBehavior: {
      inside: {
        positioner: {
          overflow: "hidden"
        },
        content: {
          maxH: "calc(100% - 7.5rem)"
        },
        body: {
          overflow: "auto"
        }
      },
      outside: {
        positioner: {
          overflow: "auto",
          pointerEvents: "auto"
        }
      }
    },
    size: {
      xs: {
        content: {
          maxW: "sm"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      cover: {
        positioner: {
          padding: "10"
        },
        content: {
          width: "100%",
          height: "100%",
          "--dialog-margin": "0"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          minH: "100vh",
          "--dialog-margin": "0",
          borderRadius: "0"
        }
      }
    },
    motionPreset: {
      scale: {
        content: {
          _open: { animationName: "scale-in, fade-in" },
          _closed: { animationName: "scale-out, fade-out" }
        }
      },
      "slide-in-bottom": {
        content: {
          _open: { animationName: "slide-from-bottom, fade-in" },
          _closed: { animationName: "slide-to-bottom, fade-out" }
        }
      },
      "slide-in-top": {
        content: {
          _open: { animationName: "slide-from-top, fade-in" },
          _closed: { animationName: "slide-to-top, fade-out" }
        }
      },
      "slide-in-left": {
        content: {
          _open: { animationName: "slide-from-left, fade-in" },
          _closed: { animationName: "slide-to-left, fade-out" }
        }
      },
      "slide-in-right": {
        content: {
          _open: { animationName: "slide-from-right, fade-in" },
          _closed: { animationName: "slide-to-right, fade-out" }
        }
      },
      none: {}
    }
  },
  defaultVariants: {
    size: "md",
    scrollBehavior: "outside",
    placement: "top",
    motionPreset: "scale"
  }
});
const drawerSlotRecipe = defineSlotRecipe({
  slots: drawerAnatomy.keys(),
  className: "chakra-drawer",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      insetInlineStart: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      insetInlineStart: 0,
      top: 0,
      zIndex: "modal",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      zIndex: "modal",
      textStyle: "sm",
      maxH: "100dvh",
      color: "inherit",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "slowest",
        animationTimingFunction: "ease-in-smooth"
      },
      _closed: {
        animationDuration: "slower",
        animationTimingFunction: "ease-in-smooth"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          maxW: "xs"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          h: "100dvh"
        }
      }
    },
    placement: {
      start: {
        positioner: {
          justifyContent: "flex-start"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-left-full, fade-in",
              _rtl: "slide-from-right-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-left-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      end: {
        positioner: {
          justifyContent: "flex-end"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-right-full, fade-in",
              _rtl: "slide-from-left-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-right-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-top-full, fade-in" },
          _closed: { animationName: "slide-to-top-full, fade-out" }
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-bottom-full, fade-in" },
          _closed: { animationName: "slide-to-bottom-full, fade-out" }
        }
      }
    },
    contained: {
      true: {
        positioner: {
          padding: "4"
        },
        content: {
          borderRadius: "l3"
        }
      }
    }
  },
  defaultVariants: {
    size: "xs",
    placement: "end"
  }
});
const sharedStyles = defineStyle({
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent",
  borderRadius: "l2"
});
const editableSlotRecipe = defineSlotRecipe({
  slots: editableAnatomy.keys(),
  className: "chakra-editable",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      gap: "1.5",
      width: "full"
    },
    preview: {
      ...sharedStyles,
      py: "1",
      px: "1",
      display: "inline-flex",
      alignItems: "center",
      transitionProperty: "common",
      transitionDuration: "normal",
      cursor: "text",
      _hover: {
        bg: "bg.muted"
      },
      _disabled: {
        userSelect: "none"
      }
    },
    input: {
      ...sharedStyles,
      outline: "0",
      py: "1",
      px: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      _placeholder: { opacity: 0.6 }
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      gap: "1.5"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "8" },
        input: { minH: "8" }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "9" },
        input: { minH: "9" }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        preview: { minH: "10" },
        input: { minH: "10" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const emptyStateSlotRecipe = defineSlotRecipe({
  slots: emptyStateAnatomy.keys(),
  className: "chakra-empty-state",
  base: {
    root: {
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "fg.subtle",
      _icon: {
        boxSize: "1em"
      }
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      textStyle: "sm",
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "4",
          py: "6"
        },
        title: {
          textStyle: "md"
        },
        content: {
          gap: "4"
        },
        indicator: {
          textStyle: "2xl"
        }
      },
      md: {
        root: {
          px: "8",
          py: "12"
        },
        title: {
          textStyle: "lg"
        },
        content: {
          gap: "6"
        },
        indicator: {
          textStyle: "4xl"
        }
      },
      lg: {
        root: {
          px: "12",
          py: "16"
        },
        title: {
          textStyle: "xl"
        },
        content: {
          gap: "8"
        },
        indicator: {
          textStyle: "6xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const fieldSlotRecipe = defineSlotRecipe({
  className: "chakra-field",
  slots: fieldAnatomy.keys(),
  base: {
    requiredIndicator: {
      color: "fg.error",
      lineHeight: "1"
    },
    root: {
      display: "flex",
      width: "100%",
      position: "relative",
      gap: "1.5"
    },
    label: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      textStyle: "sm",
      fontWeight: "medium",
      gap: "1",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      gap: "1",
      color: "fg.error",
      textStyle: "xs"
    },
    helperText: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "column",
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between"
        },
        label: {
          flex: "0 0 var(--field-label-width, 80px)"
        }
      }
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});
const fieldsetSlotRecipe = defineSlotRecipe({
  className: "fieldset",
  slots: [...fieldsetAnatomy.keys(), "content"],
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    legend: {
      color: "fg",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    helperText: {
      color: "fg.muted",
      textStyle: "sm"
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      color: "fg.error",
      gap: "2",
      fontWeight: "medium",
      textStyle: "sm"
    }
  },
  variants: {
    size: {
      sm: {
        root: { spaceY: "2" },
        content: { gap: "1.5" },
        legend: { textStyle: "sm" }
      },
      md: {
        root: { spaceY: "4" },
        content: { gap: "4" },
        legend: { textStyle: "sm" }
      },
      lg: {
        root: { spaceY: "6" },
        content: { gap: "4" },
        legend: { textStyle: "md" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const fileUploadSlotRecipe = defineSlotRecipe({
  className: "chakra-file-upload",
  slots: fileUploadAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "4",
      width: "100%",
      alignItems: "flex-start"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    dropzone: {
      background: "bg",
      borderRadius: "l3",
      borderWidth: "2px",
      borderStyle: "dashed",
      display: "flex",
      alignItems: "center",
      flexDirection: "column",
      gap: "4",
      justifyContent: "center",
      minHeight: "2xs",
      px: "3",
      py: "2",
      transition: "backgrounds",
      focusVisibleRing: "outside",
      _hover: {
        bg: "bg.subtle"
      },
      _dragging: {
        bg: "colorPalette.subtle",
        borderStyle: "solid",
        borderColor: "colorPalette.solid"
      }
    },
    dropzoneContent: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      gap: "1",
      textStyle: "sm"
    },
    item: {
      textStyle: "sm",
      animationName: "fade-in",
      animationDuration: "moderate",
      background: "bg",
      borderRadius: "l2",
      borderWidth: "1px",
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: "3",
      p: "4"
    },
    itemGroup: {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: "3"
    },
    itemName: {
      color: "fg",
      fontWeight: "medium",
      lineClamp: "1"
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5",
      flex: "1"
    },
    itemSizeText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    itemDeleteTrigger: {
      alignSelf: "flex-start"
    },
    itemPreviewImage: {
      width: "10",
      height: "10",
      objectFit: "scale-down"
    }
  },
  defaultVariants: {}
});
const hoverCardSlotRecipe = defineSlotRecipe({
  className: "chakra-hover-card",
  slots: anatomy$5.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--hovercard-bg": "colors.bg.panel",
      bg: "var(--hovercard-bg)",
      boxShadow: "lg",
      maxWidth: "80",
      borderRadius: "l3",
      zIndex: "popover",
      transformOrigin: "var(--transform-origin)",
      outline: "0",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--hovercard-bg)"
    },
    arrowTip: {
      borderTopWidth: "0.5px",
      borderInlineStartWidth: "0.5px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          padding: "3"
        }
      },
      sm: {
        content: {
          padding: "4"
        }
      },
      md: {
        content: {
          padding: "5"
        }
      },
      lg: {
        content: {
          padding: "6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const listSlotRecipe = defineSlotRecipe({
  className: "chakra-list",
  slots: listAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "var(--list-gap)",
      "& :where(ul, ol)": {
        marginTop: "var(--list-gap)"
      }
    },
    item: {
      whiteSpace: "normal",
      display: "list-item"
    },
    indicator: {
      marginEnd: "2",
      minHeight: "1lh",
      flexShrink: 0,
      display: "inline-block",
      verticalAlign: "middle"
    }
  },
  variants: {
    variant: {
      marker: {
        root: {
          listStyle: "revert",
          listStylePosition: "inside"
        },
        item: {
          _marker: {
            color: "fg.subtle"
          }
        }
      },
      plain: {
        item: {
          alignItems: "flex-start",
          display: "inline-flex"
        }
      }
    },
    align: {
      center: {
        item: { alignItems: "center" }
      },
      start: {
        item: { alignItems: "flex-start" }
      },
      end: {
        item: { alignItems: "flex-end" }
      }
    }
  },
  defaultVariants: {
    variant: "marker"
  }
});
const menuSlotRecipe = defineSlotRecipe({
  className: "chakra-menu",
  slots: menuAnatomy.keys(),
  base: {
    content: {
      outline: 0,
      bg: "bg.panel",
      boxShadow: "lg",
      color: "fg",
      "--menu-z-index": "zIndex.dropdown",
      zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
      borderRadius: "l2",
      overflow: "hidden",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    item: {
      textDecoration: "none",
      color: "fg",
      userSelect: "none",
      borderRadius: "l1",
      width: "100%",
      display: "flex",
      cursor: "menuitem",
      alignItems: "center",
      textAlign: "start",
      position: "relative",
      flex: "0 0 auto",
      outline: 0,
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemText: {
      flex: "1"
    },
    itemGroupLabel: {
      px: "2",
      py: "1.5",
      fontWeight: "semibold",
      textStyle: "sm"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    itemCommand: {
      opacity: "0.6",
      textStyle: "xs",
      ms: "auto",
      ps: "4",
      letterSpacing: "widest"
    },
    separator: {
      height: "1px",
      bg: "bg.muted",
      my: "1",
      mx: "-1"
    }
  },
  variants: {
    variant: {
      subtle: {
        item: {
          _highlighted: {
            bg: { _light: "bg.muted", _dark: "bg.emphasized" }
          }
        }
      },
      solid: {
        item: {
          _highlighted: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        }
      }
    },
    size: {
      sm: {
        content: {
          minW: "8rem",
          padding: "1"
        },
        item: {
          gap: "1",
          textStyle: "xs",
          py: "1",
          px: "1.5"
        }
      },
      md: {
        content: {
          minW: "8rem",
          padding: "1.5"
        },
        item: {
          gap: "2",
          textStyle: "sm",
          py: "1.5",
          px: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "subtle"
  }
});
const selectSlotRecipe = defineSlotRecipe({
  className: "chakra-select",
  slots: selectAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "full",
      minH: "var(--select-trigger-height)",
      px: "var(--select-trigger-padding-x)",
      borderRadius: "l2",
      userSelect: "none",
      textAlign: "start",
      focusVisibleRing: "inside",
      _placeholderShown: {
        color: "fg.muted"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      }
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      gap: "1",
      pos: "absolute",
      right: "0",
      top: "0",
      bottom: "0",
      px: "var(--select-trigger-padding-x)",
      pointerEvents: "none"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "fastest"
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: { _light: "bg.muted", _dark: "bg.emphasized" }
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        width: "4",
        height: "4"
      }
    },
    control: {
      pos: "relative"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      _first: { mt: "0" }
    },
    itemGroupLabel: {
      py: "1",
      fontWeight: "medium"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    valueText: {
      lineClamp: "1",
      maxW: "80%"
    }
  },
  variants: {
    variant: {
      outline: {
        trigger: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          _expanded: {
            borderColor: "border.emphasized"
          }
        }
      },
      subtle: {
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--select-trigger-height": "sizes.8",
          "--select-trigger-padding-x": "spacing.2"
        },
        content: {
          p: "1",
          gap: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        },
        item: {
          py: "1",
          px: "2"
        },
        itemGroupLabel: {
          py: "1",
          px: "2"
        },
        indicator: {
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        }
      },
      sm: {
        root: {
          "--select-trigger-height": "sizes.9",
          "--select-trigger-padding-x": "spacing.2.5"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        },
        item: {
          py: "1",
          px: "1.5"
        },
        itemGroup: {
          mt: "1"
        },
        itemGroupLabel: {
          py: "1",
          px: "1.5"
        }
      },
      md: {
        root: {
          "--select-trigger-height": "sizes.10",
          "--select-trigger-padding-x": "spacing.3"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        itemGroup: {
          mt: "1.5"
        },
        item: {
          py: "1.5",
          px: "2"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        itemGroupLabel: {
          py: "1.5",
          px: "2"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        }
      },
      lg: {
        root: {
          "--select-trigger-height": "sizes.12",
          "--select-trigger-padding-x": "spacing.4"
        },
        content: {
          p: "1.5",
          textStyle: "md"
        },
        itemGroup: {
          mt: "2"
        },
        item: {
          py: "2",
          px: "3"
        },
        itemGroupLabel: {
          py: "2",
          px: "3"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "5",
            height: "5"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const nativeSelectSlotRecipe = defineSlotRecipe({
  className: "chakra-native-select",
  slots: nativeSelectAnatomy.keys(),
  base: {
    root: {
      height: "fit-content",
      display: "flex",
      width: "100%",
      position: "relative"
    },
    field: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      appearance: "none",
      borderRadius: "l2",
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      },
      focusVisibleRing: "inside",
      lineHeight: "normal",
      "& > option, & > optgroup": {
        bg: "inherit"
      }
    },
    indicator: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)",
      height: "100%",
      color: "fg.muted",
      _disabled: {
        opacity: "0.5"
      },
      _invalid: {
        color: "fg.error"
      },
      _icon: {
        width: "1em",
        height: "1em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        field: (_v = selectSlotRecipe.variants) == null ? void 0 : _v.variant.outline.trigger
      },
      subtle: {
        field: (_w = selectSlotRecipe.variants) == null ? void 0 : _w.variant.subtle.trigger
      },
      plain: {
        field: {
          bg: "transparent",
          color: "fg",
          focusRingWidth: "2px"
        }
      }
    },
    size: {
      xs: {
        field: {
          textStyle: "xs",
          ps: "2",
          pe: "6",
          height: "6"
        },
        indicator: {
          textStyle: "sm",
          insetEnd: "1.5"
        }
      },
      sm: {
        field: {
          textStyle: "sm",
          ps: "2.5",
          pe: "8",
          height: "8"
        },
        indicator: {
          textStyle: "md",
          insetEnd: "2"
        }
      },
      md: {
        field: {
          textStyle: "sm",
          ps: "3",
          pe: "8",
          height: "10"
        },
        indicator: {
          textStyle: "lg",
          insetEnd: "2"
        }
      },
      lg: {
        field: {
          textStyle: "md",
          ps: "4",
          pe: "8",
          height: "11"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      },
      xl: {
        field: {
          textStyle: "md",
          ps: "4.5",
          pe: "10",
          height: "12"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      }
    }
  },
  defaultVariants: selectSlotRecipe.defaultVariants
});
function mapEntries(obj, f2) {
  const result = {};
  for (const key in obj) {
    const kv = f2(key, obj[key]);
    result[kv[0]] = kv[1];
  }
  return result;
}
const triggerStyle = defineStyle({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: "1",
  userSelect: "none",
  cursor: "button",
  lineHeight: "1",
  color: "fg.muted",
  "--stepper-base-radius": "radii.xs",
  "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
  _icon: {
    boxSize: "1em"
  },
  _disabled: {
    opacity: "0.5"
  },
  _hover: {
    bg: "bg.muted"
  },
  _active: {
    bg: "bg.emphasized"
  }
});
const numberInputSlotRecipe = defineSlotRecipe({
  className: "chakra-number-input",
  slots: anatomy$4.keys(),
  base: {
    root: {
      position: "relative",
      zIndex: "0",
      isolation: "isolate"
    },
    input: {
      ...inputRecipe.base,
      verticalAlign: "top",
      pe: "calc(var(--stepper-width) + 0.5rem)"
    },
    control: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      width: "var(--stepper-width)",
      height: "calc(100% - 2px)",
      zIndex: "1",
      borderStartWidth: "1px",
      divideY: "1px"
    },
    incrementTrigger: {
      ...triggerStyle,
      borderTopEndRadius: "var(--stepper-radius)"
    },
    decrementTrigger: {
      ...triggerStyle,
      borderBottomEndRadius: "var(--stepper-radius)"
    },
    valueText: {
      fontWeight: "medium",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  },
  variants: {
    size: {
      xs: {
        input: inputRecipe.variants.size.xs,
        control: {
          fontSize: "2xs",
          "--stepper-width": "sizes.4"
        }
      },
      sm: {
        input: inputRecipe.variants.size.sm,
        control: {
          fontSize: "xs",
          "--stepper-width": "sizes.5"
        }
      },
      md: {
        input: inputRecipe.variants.size.md,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      },
      lg: {
        input: inputRecipe.variants.size.lg,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      }
    },
    variant: mapEntries(inputRecipe.variants.variant, (key, variantStyles) => [
      key,
      { input: variantStyles }
    ])
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const { variants, defaultVariants } = inputRecipe;
const pinInputSlotRecipe = defineSlotRecipe({
  className: "chakra-pin-input",
  slots: anatomy$3.keys(),
  base: {
    input: {
      ...inputRecipe.base,
      textAlign: "center",
      width: "var(--input-height)"
    }
  },
  variants: {
    size: mapEntries(variants.size, (key, value) => [key, { input: value }]),
    variant: mapEntries(variants.variant, (key, value) => [
      key,
      { input: value }
    ])
  },
  defaultVariants
});
const popoverSlotRecipe = defineSlotRecipe({
  className: "chakra-popover",
  slots: popoverAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--popover-bg": "colors.bg.panel",
      bg: "var(--popover-bg)",
      boxShadow: "lg",
      "--popover-size": "sizes.xs",
      "--popover-mobile-size": "calc(100dvw - 1rem)",
      width: {
        base: "min(var(--popover-mobile-size), var(--popover-size))",
        sm: "var(--popover-size)"
      },
      borderRadius: "l3",
      "--popover-z-index": "zIndex.popover",
      zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
      outline: "0",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "faster"
      }
    },
    header: {
      paddingInline: "var(--popover-padding)",
      paddingTop: "var(--popover-padding)"
    },
    body: {
      padding: "var(--popover-padding)",
      flex: "1"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      paddingInline: "var(--popover-padding)",
      paddingBottom: "var(--popover-padding)"
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--popover-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          "--popover-padding": "spacing.3"
        }
      },
      sm: {
        content: {
          "--popover-padding": "spacing.4"
        }
      },
      md: {
        content: {
          "--popover-padding": "spacing.5"
        }
      },
      lg: {
        content: {
          "--popover-padding": "spacing.6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const progressSlotRecipe = defineSlotRecipe({
  slots: anatomy$2.keys(),
  className: "chakra-progress",
  base: {
    root: {
      textStyle: "sm",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      position: "relative"
    },
    range: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "width, height",
      transitionDuration: "slow",
      height: "100%",
      bgColor: "var(--track-color)",
      _indeterminate: {
        "--animate-from-x": "-40%",
        "--animate-to-x": "100%",
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: "position 1s ease infinite normal none running",
        backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      alignItems: "center",
      gap: "1"
    },
    valueText: {
      textStyle: "xs",
      lineHeight: "1",
      fontWeight: "medium"
    }
  },
  variants: {
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bgColor: "bg.muted"
        },
        range: {
          bgColor: "colorPalette.solid"
        }
      },
      subtle: {
        track: {
          bgColor: "colorPalette.muted"
        },
        range: {
          bgColor: "colorPalette.solid/72"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        track: {
          borderRadius: "l1"
        }
      },
      full: {
        track: {
          borderRadius: "full"
        }
      }
    },
    striped: {
      true: {
        range: {
          backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
          backgroundSize: `var(--stripe-size) var(--stripe-size)`,
          "--stripe-size": "1rem",
          "--stripe-color": {
            _light: "rgba(255, 255, 255, 0.3)",
            _dark: "rgba(0, 0, 0, 0.3)"
          }
        }
      }
    },
    animated: {
      true: {
        range: {
          "--animate-from": "var(--stripe-size)",
          animation: "bg-position 1s linear infinite"
        }
      }
    },
    size: {
      xs: {
        track: { h: "1.5" }
      },
      sm: {
        track: { h: "2" }
      },
      md: {
        track: { h: "2.5" }
      },
      lg: {
        track: { h: "3" }
      },
      xl: {
        track: { h: "4" }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md",
    shape: "rounded"
  }
});
const progressCircleSlotRecipe = defineSlotRecipe({
  className: "chakra-progress-circle",
  slots: anatomy$2.keys(),
  base: {
    root: {
      display: "inline-flex",
      textStyle: "sm",
      position: "relative"
    },
    circle: {
      _indeterminate: {
        animation: "spin 2s linear infinite"
      }
    },
    circleTrack: {
      "--track-color": "colors.colorPalette.muted",
      stroke: "var(--track-color)"
    },
    circleRange: {
      stroke: "colorPalette.solid",
      transitionProperty: "stroke-dasharray",
      transitionDuration: "0.6s",
      _indeterminate: {
        animation: "circular-progress 1.5s linear infinite"
      }
    },
    label: {
      display: "inline-flex"
    },
    valueText: {
      lineHeight: "1",
      fontWeight: "medium",
      letterSpacing: "tight",
      fontVariantNumeric: "tabular-nums"
    }
  },
  variants: {
    size: {
      xs: {
        circle: {
          "--size": "24px",
          "--thickness": "4px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      sm: {
        circle: {
          "--size": "32px",
          "--thickness": "5px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      md: {
        circle: {
          "--size": "40px",
          "--thickness": "6px"
        },
        valueText: {
          textStyle: "xs"
        }
      },
      lg: {
        circle: {
          "--size": "48px",
          "--thickness": "7px"
        },
        valueText: {
          textStyle: "sm"
        }
      },
      xl: {
        circle: {
          "--size": "64px",
          "--thickness": "8px"
        },
        valueText: {
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const radioCardSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-card",
  slots: radioCardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      isolation: "isolate"
    },
    item: {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      _focus: {
        bg: "colorPalette.muted/20"
      },
      _disabled: {
        opacity: "0.8",
        borderColor: "border.disabled"
      },
      _checked: {
        zIndex: "1"
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    itemText: {
      fontWeight: "medium"
    },
    itemDescription: {
      opacity: "0.64",
      textStyle: "sm"
    },
    itemControl: {
      display: "inline-flex",
      flex: "1",
      pos: "relative",
      rounded: "inherit",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)",
      _disabled: {
        bg: "bg.muted"
      }
    },
    itemIndicator: radiomarkRecipe.base,
    itemAddon: {
      roundedBottom: "inherit",
      _disabled: {
        color: "fg.muted"
      }
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "3",
          gap: "1.5"
        },
        itemAddon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        itemIndicator: (_x = radiomarkRecipe.variants) == null ? void 0 : _x.size.sm
      },
      md: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "4",
          gap: "2.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_y = radiomarkRecipe.variants) == null ? void 0 : _y.size.md
      },
      lg: {
        item: {
          textStyle: "md"
        },
        itemControl: {
          padding: "4",
          gap: "3.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_z = radiomarkRecipe.variants) == null ? void 0 : _z.size.lg
      }
    },
    variant: {
      surface: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          }
        },
        itemIndicator: (_A = radiomarkRecipe.variants) == null ? void 0 : _A.variant.solid
      },
      subtle: {
        item: {
          bg: "bg.muted"
        },
        itemControl: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        itemIndicator: (_B = radiomarkRecipe.variants) == null ? void 0 : _B.variant.outline
      },
      outline: {
        item: {
          borderWidth: "1px",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_C = radiomarkRecipe.variants) == null ? void 0 : _C.variant.solid
      },
      solid: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_D = radiomarkRecipe.variants) == null ? void 0 : _D.variant.inverted
      }
    },
    justify: {
      start: {
        item: { "--radio-card-justify": "flex-start" }
      },
      end: {
        item: { "--radio-card-justify": "flex-end" }
      },
      center: {
        item: { "--radio-card-justify": "center" }
      }
    },
    align: {
      start: {
        item: { "--radio-card-align": "flex-start" },
        itemControl: { textAlign: "start" }
      },
      end: {
        item: { "--radio-card-align": "flex-end" },
        itemControl: { textAlign: "end" }
      },
      center: {
        item: { "--radio-card-align": "center" },
        itemControl: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        itemControl: { flexDirection: "column" }
      },
      horizontal: {
        itemControl: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});
const radioGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-group",
  slots: radioGroupAnatomy.keys(),
  base: {
    item: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      fontWeight: "medium",
      _disabled: {
        cursor: "disabled"
      }
    },
    itemControl: radiomarkRecipe.base,
    label: {
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        itemControl: (_F = (_E = radiomarkRecipe.variants) == null ? void 0 : _E.variant) == null ? void 0 : _F.outline
      },
      subtle: {
        itemControl: (_H = (_G = radiomarkRecipe.variants) == null ? void 0 : _G.variant) == null ? void 0 : _H.subtle
      },
      solid: {
        itemControl: (_J = (_I = radiomarkRecipe.variants) == null ? void 0 : _I.variant) == null ? void 0 : _J.solid
      }
    },
    size: {
      xs: {
        item: { textStyle: "xs", gap: "1.5" },
        itemControl: (_L = (_K = radiomarkRecipe.variants) == null ? void 0 : _K.size) == null ? void 0 : _L.xs
      },
      sm: {
        item: { textStyle: "sm", gap: "2" },
        itemControl: (_N = (_M = radiomarkRecipe.variants) == null ? void 0 : _M.size) == null ? void 0 : _N.sm
      },
      md: {
        item: { textStyle: "sm", gap: "2.5" },
        itemControl: (_P = (_O = radiomarkRecipe.variants) == null ? void 0 : _O.size) == null ? void 0 : _P.md
      },
      lg: {
        item: { textStyle: "md", gap: "3" },
        itemControl: (_R = (_Q = radiomarkRecipe.variants) == null ? void 0 : _Q.size) == null ? void 0 : _R.lg
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});
const ratingGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-rating-group",
  slots: ratingGroupAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex"
    },
    control: {
      display: "inline-flex",
      alignItems: "center"
    },
    item: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none"
    },
    itemIndicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "1em",
      height: "1em",
      position: "relative",
      _icon: {
        stroke: "currentColor",
        width: "100%",
        height: "100%",
        display: "inline-block",
        flexShrink: 0,
        position: "absolute",
        left: 0,
        top: 0
      },
      "& [data-bg]": {
        color: "bg.emphasized"
      },
      "& [data-fg]": {
        color: "transparent"
      },
      "&[data-highlighted]:not([data-half])": {
        "& [data-fg]": {
          color: "colorPalette.solid"
        }
      },
      "&[data-half]": {
        "& [data-fg]": {
          color: "colorPalette.solid",
          clipPath: "inset(0 50% 0 0)"
        }
      }
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "sm"
        }
      },
      sm: {
        item: {
          textStyle: "md"
        }
      },
      md: {
        item: {
          textStyle: "xl"
        }
      },
      lg: {
        item: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const segmentGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-segment-group",
  slots: segmentGroupAnatomy.keys(),
  base: {
    root: {
      "--segment-radius": "radii.l2",
      borderRadius: "l2",
      display: "inline-flex",
      boxShadow: "inset",
      minW: "max-content",
      textAlign: "center",
      position: "relative",
      isolation: "isolate",
      bg: "bg.muted"
    },
    item: {
      display: "flex",
      alignItems: "center",
      userSelect: "none",
      fontSize: "sm",
      position: "relative",
      color: "fg",
      borderRadius: "var(--segment-radius)",
      _disabled: {
        opacity: "0.5"
      },
      "&:has(input:focus-visible)": {
        focusRing: "outside"
      },
      _before: {
        content: '""',
        position: "absolute",
        insetInlineStart: 0,
        insetBlock: "1.5",
        bg: "border",
        width: "1px",
        transition: "opacity 0.2s"
      },
      "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
        _before: {
          opacity: "0"
        }
      },
      "&[data-state=checked][data-ssr]": {
        shadow: "sm",
        bg: "bg",
        borderRadius: "var(--segment-radius)"
      }
    },
    indicator: {
      shadow: "sm",
      pos: "absolute",
      bg: { _light: "bg", _dark: "bg.emphasized" },
      width: "var(--width)",
      height: "var(--height)",
      top: "var(--top)",
      left: "var(--left)",
      zIndex: -1,
      borderRadius: "var(--segment-radius)"
    }
  },
  variants: {
    size: {
      xs: {
        root: {
          height: "6"
        },
        item: {
          textStyle: "xs",
          px: "3",
          gap: "1"
        }
      },
      sm: {
        root: {
          height: "8"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      md: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      lg: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "md",
          px: "5",
          gap: "3"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const sliderSlotRecipe = defineSlotRecipe({
  className: "chakra-slider",
  slots: sliderAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      fontSize: "sm",
      position: "relative",
      isolation: "isolate",
      touchAction: "none"
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      borderRadius: "full",
      flex: "1"
    },
    range: {
      width: "inherit",
      height: "inherit",
      _disabled: { bg: "border.emphasized!" }
    },
    markerGroup: {
      position: "absolute!",
      top: "var(--slider-marker-top)",
      insetInline: "var(--slider-marker-inset)",
      zIndex: "1"
    },
    marker: {
      "--marker-bg": { base: "white", _underValue: "colors.bg" },
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "1.5",
      color: "fg.muted",
      fontSize: "xs"
    },
    markerIndicator: {
      width: "var(--slider-marker-size)",
      height: "var(--slider-marker-size)",
      borderRadius: "full",
      bg: "var(--marker-bg)"
    },
    thumb: {
      width: "var(--slider-thumb-size)",
      height: "var(--slider-thumb-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      zIndex: "2",
      borderRadius: "full",
      _focusVisible: {
        ring: "2px",
        ringColor: "colorPalette.focusRing",
        ringOffset: "2px",
        ringOffsetColor: "bg"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--slider-thumb-size": "sizes.4",
          "--slider-track-size": "sizes.1.5",
          "--slider-marker-top": "6px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "3px"
        }
      },
      md: {
        root: {
          "--slider-thumb-size": "sizes.5",
          "--slider-track-size": "sizes.2",
          "--slider-marker-top": "8px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "4px"
        }
      },
      lg: {
        root: {
          "--slider-thumb-size": "sizes.6",
          "--slider-track-size": "sizes.2.5",
          "--slider-marker-top": "9px",
          "--slider-marker-size": "sizes.1.5",
          "--slider-marker-inset": "5px"
        }
      }
    },
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bg: "bg.emphasized/72"
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          borderWidth: "2px",
          borderColor: "colorPalette.solid",
          bg: "bg",
          _disabled: {
            bg: "border.emphasized",
            borderColor: "border.emphasized"
          }
        }
      },
      solid: {
        track: {
          bg: "colorPalette.subtle",
          _disabled: {
            bg: "bg.muted"
          }
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          bg: "colorPalette.solid",
          _disabled: {
            bg: "border.emphasized"
          }
        }
      }
    },
    orientation: {
      vertical: {
        root: {
          display: "inline-flex"
        },
        control: {
          flexDirection: "column",
          height: "100%",
          minWidth: "var(--slider-thumb-size)"
        },
        track: {
          width: "var(--slider-track-size)"
        },
        thumb: {
          left: "50%",
          translate: "-50% 0"
        }
      },
      horizontal: {
        control: {
          flexDirection: "row",
          width: "100%",
          minHeight: "var(--slider-thumb-size)"
        },
        track: {
          height: "var(--slider-track-size)"
        },
        thumb: {
          top: "50%",
          translate: "0 -50%"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    orientation: "horizontal"
  }
});
const statSlotRecipe = defineSlotRecipe({
  className: "chakra-stat",
  slots: statAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      position: "relative",
      flex: "1"
    },
    label: {
      color: "fg.muted",
      textStyle: "sm"
    },
    helpText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    valueUnit: {
      color: "fg.muted",
      textStyle: "xs",
      fontWeight: "initial",
      letterSpacing: "initial"
    },
    valueText: {
      verticalAlign: "baseline",
      fontWeight: "semibold",
      letterSpacing: "tight",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums",
      display: "inline-flex",
      gap: "1"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      marginEnd: 1,
      "& :where(svg)": {
        w: "1em",
        h: "1em"
      },
      "&[data-type=up]": {
        color: "fg.success"
      },
      "&[data-type=down]": {
        color: "fg.error"
      }
    }
  },
  variants: {
    size: {
      sm: {
        valueText: {
          textStyle: "xl"
        }
      },
      md: {
        valueText: {
          textStyle: "2xl"
        }
      },
      lg: {
        valueText: {
          textStyle: "3xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const statusSlotRecipe = defineSlotRecipe({
  className: "chakra-status",
  slots: statusAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    indicator: {
      width: "0.64em",
      height: "0.64em",
      flexShrink: 0,
      borderRadius: "full",
      forcedColorAdjust: "none",
      bg: "colorPalette.solid"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const stepsSlotRecipe = defineSlotRecipe({
  className: "chakra-steps",
  slots: stepsAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      width: "full"
    },
    list: {
      display: "flex",
      justifyContent: "space-between",
      "--steps-gutter": "spacing.3",
      "--steps-thickness": "2px"
    },
    title: {
      fontWeight: "medium",
      color: "fg"
    },
    description: {
      color: "fg.muted"
    },
    separator: {
      bg: "border",
      flex: "1"
    },
    indicator: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: "0",
      borderRadius: "full",
      fontWeight: "medium",
      width: "var(--steps-size)",
      height: "var(--steps-size)",
      _icon: {
        flexShrink: "0",
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)"
      }
    },
    item: {
      position: "relative",
      display: "flex",
      flex: "1 0 0",
      "&:last-of-type": {
        flex: "initial",
        "& [data-part=separator]": {
          display: "none"
        }
      }
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      gap: "3",
      textAlign: "start",
      focusVisibleRing: "outside",
      borderRadius: "l2"
    },
    content: {
      focusVisibleRing: "outside"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "row",
          height: "100%"
        },
        list: {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        separator: {
          position: "absolute",
          width: "var(--steps-thickness)",
          height: "100%",
          maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
          top: "calc(var(--steps-size) + var(--steps-gutter))",
          insetStart: "calc(var(--steps-size) / 2 - 1px)"
        },
        item: {
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "column",
          width: "100%"
        },
        list: {
          flexDirection: "row",
          alignItems: "center"
        },
        separator: {
          width: "100%",
          height: "var(--steps-thickness)",
          marginX: "var(--steps-gutter)"
        },
        item: {
          alignItems: "center"
        }
      }
    },
    variant: {
      solid: {
        indicator: {
          _incomplete: {
            borderWidth: "var(--steps-thickness)"
          },
          _current: {
            bg: "colorPalette.muted",
            borderWidth: "var(--steps-thickness)",
            borderColor: "colorPalette.solid",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.solid",
            borderColor: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.solid"
          }
        }
      },
      subtle: {
        indicator: {
          _incomplete: {
            bg: "bg.muted"
          },
          _current: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.emphasized",
            color: "colorPalette.fg"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.emphasized"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          gap: "2.5"
        },
        list: {
          "--steps-size": "sizes.6",
          "--steps-icon-size": "sizes.3.5",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      sm: {
        root: {
          gap: "3"
        },
        list: {
          "--steps-size": "sizes.8",
          "--steps-icon-size": "sizes.4",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        list: {
          "--steps-size": "sizes.10",
          "--steps-icon-size": "sizes.4",
          textStyle: "sm"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "6"
        },
        list: {
          "--steps-size": "sizes.11",
          "--steps-icon-size": "sizes.5",
          textStyle: "md"
        },
        title: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    orientation: "horizontal"
  }
});
const switchSlotRecipe = defineSlotRecipe({
  slots: switchAnatomy.keys(),
  className: "chakra-switch",
  base: {
    root: {
      display: "inline-flex",
      gap: "2.5",
      alignItems: "center",
      position: "relative",
      verticalAlign: "middle",
      "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
      "--switch-x": {
        base: "var(--switch-diff)",
        _rtl: "calc(var(--switch-diff) * -1)"
      }
    },
    label: {
      lineHeight: "1",
      userSelect: "none",
      fontSize: "sm",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: {
      position: "absolute",
      height: "var(--switch-height)",
      width: "var(--switch-height)",
      fontSize: "var(--switch-indicator-font-size)",
      fontWeight: "medium",
      flexShrink: 0,
      userSelect: "none",
      display: "grid",
      placeContent: "center",
      transition: "inset-inline-start 0.12s ease",
      insetInlineStart: "calc(var(--switch-x) - 2px)",
      _checked: {
        insetInlineStart: "2px"
      }
    },
    control: {
      display: "inline-flex",
      gap: "0.5rem",
      flexShrink: 0,
      justifyContent: "flex-start",
      cursor: "switch",
      borderRadius: "full",
      position: "relative",
      width: "var(--switch-width)",
      height: "var(--switch-height)",
      _disabled: {
        opacity: "0.5",
        cursor: "not-allowed"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error",
        outlineOffset: "2px"
      }
    },
    thumb: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      transitionProperty: "translate",
      transitionDuration: "fast",
      borderRadius: "inherit",
      _checked: {
        translate: "var(--switch-x) 0"
      }
    }
  },
  variants: {
    variant: {
      solid: {
        control: {
          borderRadius: "full",
          bg: "bg.emphasized",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        },
        thumb: {
          bg: "white",
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          scale: "0.8",
          boxShadow: "sm",
          _checked: {
            bg: "colorPalette.contrast"
          }
        }
      },
      raised: {
        control: {
          borderRadius: "full",
          height: "calc(var(--switch-height) / 2)",
          bg: "bg.muted",
          boxShadow: "inset",
          _checked: {
            bg: "colorPalette.solid/60"
          }
        },
        thumb: {
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          position: "relative",
          top: "calc(var(--switch-height) * -0.25)",
          bg: "white",
          boxShadow: "xs",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          "--switch-width": "sizes.6",
          "--switch-height": "sizes.3",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      sm: {
        root: {
          "--switch-width": "sizes.8",
          "--switch-height": "sizes.4",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      md: {
        root: {
          "--switch-width": "sizes.10",
          "--switch-height": "sizes.5",
          "--switch-indicator-font-size": "fontSizes.sm"
        }
      },
      lg: {
        root: {
          "--switch-width": "sizes.12",
          "--switch-height": "sizes.6",
          "--switch-indicator-font-size": "fontSizes.md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const tableSlotRecipe = defineSlotRecipe({
  className: "chakra-table",
  slots: tableAnatomy.keys(),
  base: {
    root: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full",
      textAlign: "start",
      verticalAlign: "top"
    },
    row: {
      _selected: {
        bg: "colorPalette.subtle"
      }
    },
    cell: {
      textAlign: "start",
      alignItems: "center"
    },
    columnHeader: {
      fontWeight: "medium",
      textAlign: "start",
      color: "fg"
    },
    caption: {
      fontWeight: "medium",
      textStyle: "xs"
    },
    footer: {
      fontWeight: "medium"
    }
  },
  variants: {
    interactive: {
      true: {
        body: {
          "& tr": {
            _hover: {
              bg: "colorPalette.subtle"
            }
          }
        }
      }
    },
    stickyHeader: {
      true: {
        header: {
          "& :where(tr)": {
            top: "var(--table-sticky-offset, 0)",
            position: "sticky",
            zIndex: 1
          }
        }
      }
    },
    striped: {
      true: {
        row: {
          "&:nth-of-type(odd) td": {
            bg: "bg.muted"
          }
        }
      }
    },
    showColumnBorder: {
      true: {
        columnHeader: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        },
        cell: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        }
      }
    },
    variant: {
      line: {
        columnHeader: {
          borderBottomWidth: "1px"
        },
        cell: {
          borderBottomWidth: "1px"
        },
        row: {
          bg: "bg"
        }
      },
      outline: {
        root: {
          boxShadow: "0 0 0 1px {colors.border}",
          overflow: "hidden"
        },
        columnHeader: {
          borderBottomWidth: "1px"
        },
        header: {
          bg: "bg.muted"
        },
        row: {
          "&:not(:last-of-type)": {
            borderBottomWidth: "1px"
          }
        },
        footer: {
          borderTopWidth: "1px"
        }
      }
    },
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "2",
          py: "2"
        },
        cell: {
          px: "2",
          py: "2"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "3",
          py: "3"
        },
        cell: {
          px: "3",
          py: "3"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        columnHeader: {
          px: "4",
          py: "3"
        },
        cell: {
          px: "4",
          py: "3"
        }
      }
    }
  },
  defaultVariants: {
    variant: "line",
    size: "md"
  }
});
const tabsSlotRecipe = defineSlotRecipe({
  slots: tabsAnatomy.keys(),
  className: "chakra-tabs",
  base: {
    root: {
      "--tabs-trigger-radius": "radii.l2",
      position: "relative",
      _horizontal: {
        display: "block"
      },
      _vertical: {
        display: "flex"
      }
    },
    list: {
      display: "inline-flex",
      position: "relative",
      isolation: "isolate",
      "--tabs-indicator-shadow": "shadows.xs",
      "--tabs-indicator-bg": "colors.bg",
      minH: "var(--tabs-height)",
      _horizontal: {
        flexDirection: "row"
      },
      _vertical: {
        flexDirection: "column"
      }
    },
    trigger: {
      outline: "0",
      minW: "var(--tabs-height)",
      height: "var(--tabs-height)",
      display: "flex",
      alignItems: "center",
      fontWeight: "medium",
      position: "relative",
      cursor: "button",
      gap: "2",
      _focusVisible: {
        zIndex: 1,
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.5
      }
    },
    content: {
      focusVisibleRing: "inside",
      _horizontal: {
        width: "100%",
        pt: "var(--tabs-content-padding)"
      },
      _vertical: {
        height: "100%",
        ps: "var(--tabs-content-padding)"
      }
    },
    indicator: {
      width: "var(--width)",
      height: "var(--height)",
      borderRadius: "var(--tabs-indicator-radius)",
      bg: "var(--tabs-indicator-bg)",
      shadow: "var(--tabs-indicator-shadow)",
      zIndex: -1
    }
  },
  variants: {
    fitted: {
      true: {
        list: {
          display: "flex"
        },
        trigger: {
          flex: 1,
          textAlign: "center",
          justifyContent: "center"
        }
      }
    },
    justify: {
      start: {
        list: {
          justifyContent: "flex-start"
        }
      },
      center: {
        list: {
          justifyContent: "center"
        }
      },
      end: {
        list: {
          justifyContent: "flex-end"
        }
      }
    },
    size: {
      sm: {
        root: {
          "--tabs-height": "sizes.9",
          "--tabs-content-padding": "spacing.3"
        },
        trigger: {
          py: "1",
          px: "3",
          textStyle: "sm"
        }
      },
      md: {
        root: {
          "--tabs-height": "sizes.10",
          "--tabs-content-padding": "spacing.4"
        },
        trigger: {
          py: "2",
          px: "4",
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--tabs-height": "sizes.11",
          "--tabs-content-padding": "spacing.4.5"
        },
        trigger: {
          py: "2",
          px: "4.5",
          textStyle: "md"
        }
      }
    },
    variant: {
      line: {
        list: {
          display: "flex",
          borderColor: "border",
          _horizontal: {
            borderBottomWidth: "1px"
          },
          _vertical: {
            borderEndWidth: "1px"
          }
        },
        trigger: {
          color: "fg.muted",
          _disabled: {
            _active: { bg: "initial" }
          },
          _selected: {
            color: "fg",
            _horizontal: {
              layerStyle: "indicator.bottom",
              "--indicator-offset-y": "-1px",
              "--indicator-color": "colors.colorPalette.solid"
            },
            _vertical: {
              layerStyle: "indicator.end",
              "--indicator-offset-x": "-1px"
            }
          }
        }
      },
      subtle: {
        trigger: {
          borderRadius: "var(--tabs-trigger-radius)",
          color: "fg.muted",
          _selected: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        }
      },
      enclosed: {
        list: {
          bg: "bg.muted",
          padding: "1",
          borderRadius: "l3",
          minH: "calc(var(--tabs-height) - 4px)"
        },
        trigger: {
          justifyContent: "center",
          color: "fg.muted",
          borderRadius: "var(--tabs-trigger-radius)",
          _selected: {
            bg: "bg",
            color: "colorPalette.fg",
            shadow: "xs"
          }
        }
      },
      outline: {
        list: {
          "--line-thickness": "1px",
          "--line-offset": "calc(var(--line-thickness) * -1)",
          borderColor: "border",
          display: "flex",
          _horizontal: {
            _before: {
              content: '""',
              position: "absolute",
              bottom: "0px",
              width: "100%",
              borderBottomWidth: "var(--line-thickness)",
              borderBottomColor: "border"
            }
          },
          _vertical: {
            _before: {
              content: '""',
              position: "absolute",
              insetInline: "var(--line-offset)",
              height: "calc(100% - calc(var(--line-thickness) * 2))",
              borderEndWidth: "var(--line-thickness)",
              borderEndColor: "border"
            }
          }
        },
        trigger: {
          color: "fg.muted",
          borderWidth: "1px",
          borderColor: "transparent",
          _selected: {
            bg: "currentBg",
            color: "colorPalette.fg"
          },
          _horizontal: {
            borderTopRadius: "var(--tabs-trigger-radius)",
            marginBottom: "var(--line-offset)",
            marginEnd: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderBottomColor: "transparent"
            }
          },
          _vertical: {
            borderStartRadius: "var(--tabs-trigger-radius)",
            marginEnd: "var(--line-offset)",
            marginBottom: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderEndColor: "transparent"
            }
          }
        }
      },
      plain: {
        trigger: {
          color: "fg.muted",
          _selected: {
            color: "colorPalette.fg"
          },
          borderRadius: "var(--tabs-trigger-radius)",
          "&[data-selected][data-ssr]": {
            bg: "var(--tabs-indicator-bg)",
            shadow: "var(--tabs-indicator-shadow)",
            borderRadius: "var(--tabs-indicator-radius)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "line"
  }
});
const badgeVariant = (_S = badgeRecipe.variants) == null ? void 0 : _S.variant;
const tagSlotRecipe = defineSlotRecipe({
  slots: tagAnatomy.keys(),
  className: "chakra-tag",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      maxWidth: "100%",
      userSelect: "none",
      borderRadius: "l2",
      focusVisibleRing: "outside"
    },
    label: {
      lineClamp: "1"
    },
    closeTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      borderRadius: "l1",
      color: "currentColor",
      focusVisibleRing: "inside",
      focusRingWidth: "2px"
    },
    startElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      ms: "var(--tag-element-offset)",
      "&:has([data-scope=avatar])": {
        boxSize: "var(--tag-avatar-size)",
        ms: "calc(var(--tag-element-offset) * 1.5)"
      },
      _icon: { boxSize: "100%" }
    },
    endElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      me: "var(--tag-element-offset)",
      _icon: { boxSize: "100%" },
      "&:has(button)": {
        ms: "calc(var(--tag-element-offset) * -1)"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "1.5",
          minH: "4.5",
          gap: "1",
          "--tag-avatar-size": "spacing.3",
          "--tag-element-size": "spacing.3",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          px: "1.5",
          minH: "5",
          gap: "1",
          "--tag-avatar-size": "spacing.3.5",
          "--tag-element-size": "spacing.3.5",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      lg: {
        root: {
          px: "2",
          minH: "6",
          gap: "1.5",
          "--tag-avatar-size": "spacing.4.5",
          "--tag-element-size": "spacing.4",
          "--tag-element-offset": "-3px"
        },
        label: {
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          px: "2.5",
          minH: "8",
          gap: "1.5",
          "--tag-avatar-size": "spacing.6",
          "--tag-element-size": "spacing.4.5",
          "--tag-element-offset": "-4px"
        },
        label: {
          textStyle: "sm"
        }
      }
    },
    variant: {
      subtle: {
        root: badgeVariant == null ? void 0 : badgeVariant.subtle
      },
      solid: {
        root: badgeVariant == null ? void 0 : badgeVariant.solid
      },
      outline: {
        root: badgeVariant == null ? void 0 : badgeVariant.outline
      },
      surface: {
        root: badgeVariant == null ? void 0 : badgeVariant.surface
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "surface"
  }
});
const timelineSlotRecipe = defineSlotRecipe({
  slots: timelineAnatomy.keys(),
  className: "chakra-timeline",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full",
      "--timeline-thickness": "1px",
      "--timeline-gutter": "4px"
    },
    item: {
      display: "flex",
      position: "relative",
      alignItems: "flex-start",
      flexShrink: 0,
      gap: "4",
      _last: {
        "& :where(.chakra-timeline__separator)": { display: "none" }
      }
    },
    separator: {
      position: "absolute",
      borderStartWidth: "var(--timeline-thickness)",
      ms: "calc(-1 * var(--timeline-thickness) / 2)",
      insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
      insetBlock: "0",
      borderColor: "border"
    },
    indicator: {
      outline: "2px solid {colors.bg}",
      position: "relative",
      flexShrink: "0",
      boxSize: "var(--timeline-indicator-size)",
      fontSize: "var(--timeline-font-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "full",
      fontWeight: "medium"
    },
    connector: {
      alignSelf: "stretch",
      position: "relative"
    },
    content: {
      pb: "6",
      display: "flex",
      flexDirection: "column",
      width: "full",
      gap: "2"
    },
    title: {
      display: "flex",
      fontWeight: "medium",
      flexWrap: "wrap",
      gap: "1.5",
      alignItems: "center",
      mt: "var(--timeline-margin)"
    },
    description: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    variant: {
      subtle: {
        indicator: {
          bg: "colorPalette.muted"
        }
      },
      solid: {
        indicator: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      outline: {
        indicator: {
          bg: "currentBg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--timeline-indicator-size": "sizes.4",
          "--timeline-font-size": "fontSizes.2xs"
        },
        title: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          "--timeline-indicator-size": "sizes.5",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--timeline-indicator-size": "sizes.6",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          mt: "0.5",
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          "--timeline-indicator-size": "sizes.8",
          "--timeline-font-size": "fontSizes.sm"
        },
        title: {
          mt: "1.5",
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});
const toastSlotRecipe = defineSlotRecipe({
  slots: toastAnatomy.keys(),
  className: "chakra-toast",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      gap: "3",
      py: "4",
      ps: "4",
      pe: "6",
      borderRadius: "l2",
      translate: "var(--x) var(--y)",
      scale: "var(--scale)",
      zIndex: "var(--z-index)",
      height: "var(--height)",
      opacity: "var(--opacity)",
      willChange: "translate, opacity, scale",
      transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
      transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
      _closed: {
        transition: "translate 400ms, scale 400ms, opacity 200ms",
        transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
      },
      bg: "bg.panel",
      color: "fg",
      boxShadow: "xl",
      "--toast-trigger-bg": "colors.bg.muted",
      "&[data-type=warning]": {
        bg: "orange.solid",
        color: "orange.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=success]": {
        bg: "green.solid",
        color: "green.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=error]": {
        bg: "red.solid",
        color: "red.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      }
    },
    title: {
      fontWeight: "medium",
      textStyle: "sm",
      marginEnd: "2"
    },
    description: {
      display: "inline",
      textStyle: "sm",
      opacity: "0.8"
    },
    indicator: {
      flexShrink: "0",
      boxSize: "5"
    },
    actionTrigger: {
      textStyle: "sm",
      fontWeight: "medium",
      height: "8",
      px: "3",
      borderRadius: "l2",
      alignSelf: "center",
      borderWidth: "1px",
      borderColor: "var(--toast-border-color, inherit)",
      transition: "background 200ms",
      _hover: {
        bg: "var(--toast-trigger-bg)"
      }
    },
    closeTrigger: {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      padding: "1",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      color: "{currentColor/60}",
      borderRadius: "l2",
      textStyle: "md",
      transition: "background 200ms"
    }
  }
});
const tooltipSlotRecipe = defineSlotRecipe({
  slots: anatomy$1.keys(),
  className: "chakra-tooltip",
  base: {
    content: {
      "--tooltip-bg": "colors.bg.inverted",
      bg: "var(--tooltip-bg)",
      color: "fg.inverted",
      px: "2.5",
      py: "1",
      borderRadius: "l2",
      fontWeight: "medium",
      textStyle: "xs",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "fast"
      }
    },
    arrow: {
      "--arrow-size": "sizes.2",
      "--arrow-background": "var(--tooltip-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px",
      borderColor: "var(--tooltip-bg)"
    }
  }
});
const slotRecipes = {
  accordion: accordionSlotRecipe,
  actionBar: actionBarSlotRecipe,
  alert: alertSlotRecipe,
  avatar: avatarSlotRecipe,
  blockquote: blockquoteSlotRecipe,
  breadcrumb: breadcrumbSlotRecipe,
  card: cardSlotRecipe,
  checkbox: checkboxSlotRecipe,
  checkboxCard: checkboxCardSlotRecipe,
  collapsible: collapsibleSlotRecipe,
  dataList: dataListSlotRecipe,
  dialog: dialogSlotRecipe,
  drawer: drawerSlotRecipe,
  editable: editableSlotRecipe,
  emptyState: emptyStateSlotRecipe,
  field: fieldSlotRecipe,
  fieldset: fieldsetSlotRecipe,
  fileUpload: fileUploadSlotRecipe,
  hoverCard: hoverCardSlotRecipe,
  list: listSlotRecipe,
  menu: menuSlotRecipe,
  nativeSelect: nativeSelectSlotRecipe,
  numberInput: numberInputSlotRecipe,
  pinInput: pinInputSlotRecipe,
  popover: popoverSlotRecipe,
  progress: progressSlotRecipe,
  progressCircle: progressCircleSlotRecipe,
  radioCard: radioCardSlotRecipe,
  radioGroup: radioGroupSlotRecipe,
  ratingGroup: ratingGroupSlotRecipe,
  segmentGroup: segmentGroupSlotRecipe,
  select: selectSlotRecipe,
  slider: sliderSlotRecipe,
  stat: statSlotRecipe,
  steps: stepsSlotRecipe,
  switch: switchSlotRecipe,
  table: tableSlotRecipe,
  tabs: tabsSlotRecipe,
  tag: tagSlotRecipe,
  toast: toastSlotRecipe,
  tooltip: tooltipSlotRecipe,
  status: statusSlotRecipe,
  timeline: timelineSlotRecipe
};
const textStyles = defineTextStyles({
  "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
  xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
  sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
  md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
  lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
  xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
  "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
  "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
  "4xl": {
    value: {
      fontSize: "4xl",
      lineHeight: "2.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "5xl": {
    value: {
      fontSize: "5xl",
      lineHeight: "3.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "6xl": {
    value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
  },
  "7xl": {
    value: {
      fontSize: "7xl",
      lineHeight: "5.75rem",
      letterSpacing: "-0.025em"
    }
  },
  none: {
    value: {}
  }
});
const animations = defineTokens.animations({
  spin: { value: "spin 1s linear infinite" },
  ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
  pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
  bounce: { value: "bounce 1s infinite" }
});
const aspectRatios = defineTokens.aspectRatios({
  square: { value: "1 / 1" },
  landscape: { value: "4 / 3" },
  portrait: { value: "3 / 4" },
  wide: { value: "16 / 9" },
  ultrawide: { value: "18 / 5" },
  golden: { value: "1.618 / 1" }
});
const blurs = defineTokens.blurs({
  none: { value: " " },
  sm: { value: "4px" },
  md: { value: "8px" },
  lg: { value: "12px" },
  xl: { value: "16px" },
  "2xl": { value: "24px" },
  "3xl": { value: "40px" },
  "4xl": { value: "64px" }
});
const borders = defineTokens.borders({
  xs: { value: "0.5px solid" },
  sm: { value: "1px solid" },
  md: { value: "2px solid" },
  lg: { value: "4px solid" },
  xl: { value: "8px solid" }
});
const colors = defineTokens.colors({
  transparent: { value: "transparent" },
  current: { value: "currentColor" },
  black: { value: "#09090B" },
  white: { value: "#FFFFFF" },
  whiteAlpha: {
    50: { value: "rgba(255, 255, 255, 0.04)" },
    100: { value: "rgba(255, 255, 255, 0.06)" },
    200: { value: "rgba(255, 255, 255, 0.08)" },
    300: { value: "rgba(255, 255, 255, 0.16)" },
    400: { value: "rgba(255, 255, 255, 0.24)" },
    500: { value: "rgba(255, 255, 255, 0.36)" },
    600: { value: "rgba(255, 255, 255, 0.48)" },
    700: { value: "rgba(255, 255, 255, 0.64)" },
    800: { value: "rgba(255, 255, 255, 0.80)" },
    900: { value: "rgba(255, 255, 255, 0.92)" },
    950: { value: "rgba(255, 255, 255, 0.95)" }
  },
  blackAlpha: {
    50: { value: "rgba(0, 0, 0, 0.04)" },
    100: { value: "rgba(0, 0, 0, 0.06)" },
    200: { value: "rgba(0, 0, 0, 0.08)" },
    300: { value: "rgba(0, 0, 0, 0.16)" },
    400: { value: "rgba(0, 0, 0, 0.24)" },
    500: { value: "rgba(0, 0, 0, 0.36)" },
    600: { value: "rgba(0, 0, 0, 0.48)" },
    700: { value: "rgba(0, 0, 0, 0.64)" },
    800: { value: "rgba(0, 0, 0, 0.80)" },
    900: { value: "rgba(0, 0, 0, 0.92)" },
    950: { value: "rgba(0, 0, 0, 0.95)" }
  },
  gray: {
    50: { value: "#fafafa" },
    100: { value: "#f4f4f5" },
    200: { value: "#e4e4e7" },
    300: { value: "#d4d4d8" },
    400: { value: "#a1a1aa" },
    500: { value: "#71717a" },
    600: { value: "#52525b" },
    700: { value: "#3f3f46" },
    800: { value: "#27272a" },
    900: { value: "#18181b" },
    950: { value: "#111111" }
  },
  red: {
    50: { value: "#fef2f2" },
    100: { value: "#fee2e2" },
    200: { value: "#fecaca" },
    300: { value: "#fca5a5" },
    400: { value: "#f87171" },
    500: { value: "#ef4444" },
    600: { value: "#dc2626" },
    700: { value: "#991919" },
    800: { value: "#511111" },
    900: { value: "#300c0c" },
    950: { value: "#1f0808" }
  },
  orange: {
    50: { value: "#fff7ed" },
    100: { value: "#ffedd5" },
    200: { value: "#fed7aa" },
    300: { value: "#fdba74" },
    400: { value: "#fb923c" },
    500: { value: "#f97316" },
    600: { value: "#ea580c" },
    700: { value: "#92310a" },
    800: { value: "#6c2710" },
    900: { value: "#3b1106" },
    950: { value: "#220a04" }
  },
  yellow: {
    50: { value: "#fefce8" },
    100: { value: "#fef9c3" },
    200: { value: "#fef08a" },
    300: { value: "#fde047" },
    400: { value: "#facc15" },
    500: { value: "#eab308" },
    600: { value: "#ca8a04" },
    700: { value: "#845209" },
    800: { value: "#713f12" },
    900: { value: "#422006" },
    950: { value: "#281304" }
  },
  green: {
    50: { value: "#f0fdf4" },
    100: { value: "#dcfce7" },
    200: { value: "#bbf7d0" },
    300: { value: "#86efac" },
    400: { value: "#4ade80" },
    500: { value: "#22c55e" },
    600: { value: "#16a34a" },
    700: { value: "#116932" },
    800: { value: "#124a28" },
    900: { value: "#042713" },
    950: { value: "#03190c" }
  },
  teal: {
    50: { value: "#f0fdfa" },
    100: { value: "#ccfbf1" },
    200: { value: "#99f6e4" },
    300: { value: "#5eead4" },
    400: { value: "#2dd4bf" },
    500: { value: "#14b8a6" },
    600: { value: "#0d9488" },
    700: { value: "#0c5d56" },
    800: { value: "#114240" },
    900: { value: "#032726" },
    950: { value: "#021716" }
  },
  blue: {
    50: { value: "#eff6ff" },
    100: { value: "#dbeafe" },
    200: { value: "#bfdbfe" },
    300: { value: "#a3cfff" },
    400: { value: "#60a5fa" },
    500: { value: "#3b82f6" },
    600: { value: "#2563eb" },
    700: { value: "#173da6" },
    800: { value: "#1a3478" },
    900: { value: "#14204a" },
    950: { value: "#0c142e" }
  },
  cyan: {
    50: { value: "#ecfeff" },
    100: { value: "#cffafe" },
    200: { value: "#a5f3fc" },
    300: { value: "#67e8f9" },
    400: { value: "#22d3ee" },
    500: { value: "#06b6d4" },
    600: { value: "#0891b2" },
    700: { value: "#0c5c72" },
    800: { value: "#134152" },
    900: { value: "#072a38" },
    950: { value: "#051b24" }
  },
  purple: {
    50: { value: "#faf5ff" },
    100: { value: "#f3e8ff" },
    200: { value: "#e9d5ff" },
    300: { value: "#d8b4fe" },
    400: { value: "#c084fc" },
    500: { value: "#a855f7" },
    600: { value: "#9333ea" },
    700: { value: "#641ba3" },
    800: { value: "#4a1772" },
    900: { value: "#2f0553" },
    950: { value: "#1a032e" }
  },
  pink: {
    50: { value: "#fdf2f8" },
    100: { value: "#fce7f3" },
    200: { value: "#fbcfe8" },
    300: { value: "#f9a8d4" },
    400: { value: "#f472b6" },
    500: { value: "#ec4899" },
    600: { value: "#db2777" },
    700: { value: "#a41752" },
    800: { value: "#6d0e34" },
    900: { value: "#45061f" },
    950: { value: "#2c0514" }
  }
});
const cursor = defineTokens.cursor({
  button: { value: "pointer" },
  checkbox: { value: "default" },
  disabled: { value: "not-allowed" },
  menuitem: { value: "default" },
  option: { value: "default" },
  radio: { value: "default" },
  slider: { value: "default" },
  switch: { value: "pointer" }
});
const durations = defineTokens.durations({
  fastest: { value: "50ms" },
  faster: { value: "100ms" },
  fast: { value: "150ms" },
  moderate: { value: "200ms" },
  slow: { value: "300ms" },
  slower: { value: "400ms" },
  slowest: { value: "500ms" }
});
const easings = defineTokens.easings({
  "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
  "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
  "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
  "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
});
const fontSizes = defineTokens.fontSizes({
  "2xs": { value: "0.625rem" },
  xs: { value: "0.75rem" },
  sm: { value: "0.875rem" },
  md: { value: "1rem" },
  lg: { value: "1.125rem" },
  xl: { value: "1.25rem" },
  "2xl": { value: "1.5rem" },
  "3xl": { value: "1.875rem" },
  "4xl": { value: "2.25rem" },
  "5xl": { value: "3rem" },
  "6xl": { value: "3.75rem" },
  "7xl": { value: "4.5rem" },
  "8xl": { value: "6rem" },
  "9xl": { value: "8rem" }
});
const fontWeights = defineTokens.fontWeights({
  thin: { value: "100" },
  extralight: { value: "200" },
  light: { value: "300" },
  normal: { value: "400" },
  medium: { value: "500" },
  semibold: { value: "600" },
  bold: { value: "700" },
  extrabold: { value: "800" },
  black: { value: "900" }
});
const fallback = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
const fonts = defineTokens.fonts({
  heading: {
    value: `Inter, ${fallback}`
  },
  body: {
    value: `Inter, ${fallback}`
  },
  mono: {
    value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  }
});
const keyframes = defineKeyframes({
  spin: {
    "0%": { transform: "rotate(0deg)" },
    "100%": { transform: "rotate(360deg)" }
  },
  pulse: {
    "50%": { opacity: "0.5" }
  },
  ping: {
    "75%, 100%": {
      transform: "scale(2)",
      opacity: "0"
    }
  },
  bounce: {
    "0%, 100%": {
      transform: "translateY(-25%)",
      animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
    },
    "50%": {
      transform: "none",
      animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
    }
  },
  "bg-position": {
    from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
    to: { backgroundPosition: "var(--animate-to, 0) 0" }
  },
  position: {
    from: {
      insetInlineStart: "var(--animate-from-x)",
      insetBlockStart: "var(--animate-from-y)"
    },
    to: {
      insetInlineStart: "var(--animate-to-x)",
      insetBlockStart: "var(--animate-to-y)"
    }
  },
  "circular-progress": {
    "0%": {
      strokeDasharray: "1, 400",
      strokeDashoffset: "0"
    },
    "50%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-100%"
    },
    "100%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-260%"
    }
  },
  // collapse
  "expand-height": {
    from: { height: "0" },
    to: { height: "var(--height)" }
  },
  "collapse-height": {
    from: { height: "var(--height)" },
    to: { height: "0" }
  },
  "expand-width": {
    from: { width: "0" },
    to: { width: "var(--width)" }
  },
  "collapse-width": {
    from: { height: "var(--width)" },
    to: { height: "0" }
  },
  // fade
  "fade-in": {
    from: { opacity: 0 },
    to: { opacity: 1 }
  },
  "fade-out": {
    from: { opacity: 1 },
    to: { opacity: 0 }
  },
  // slide from (full)
  "slide-from-left-full": {
    from: { translate: "-100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-right-full": {
    from: { translate: "100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-top-full": {
    from: { translate: "0 -100%" },
    to: { translate: "0 0" }
  },
  "slide-from-bottom-full": {
    from: { translate: "0 100%" },
    to: { translate: "0 0" }
  },
  // slide to (full)
  "slide-to-left-full": {
    from: { translate: "0 0" },
    to: { translate: "-100% 0" }
  },
  "slide-to-right-full": {
    from: { translate: "0 0" },
    to: { translate: "100% 0" }
  },
  "slide-to-top-full": {
    from: { translate: "0 0" },
    to: { translate: "0 -100%" }
  },
  "slide-to-bottom-full": {
    from: { translate: "0 0" },
    to: { translate: "0 100%" }
  },
  // slide from
  "slide-from-top": {
    "0%": { translate: "0 -0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-bottom": {
    "0%": { translate: "0 0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-left": {
    "0%": { translate: "-0.5rem 0" },
    to: { translate: "0" }
  },
  "slide-from-right": {
    "0%": { translate: "0.5rem 0" },
    to: { translate: "0" }
  },
  // slide to
  "slide-to-top": {
    "0%": { translate: "0" },
    to: { translate: "0 -0.5rem" }
  },
  "slide-to-bottom": {
    "0%": { translate: "0" },
    to: { translate: "0 0.5rem" }
  },
  "slide-to-left": {
    "0%": { translate: "0" },
    to: { translate: "-0.5rem 0" }
  },
  "slide-to-right": {
    "0%": { translate: "0" },
    to: { translate: "0.5rem 0" }
  },
  // scale
  "scale-in": {
    from: { scale: "0.95" },
    to: { scale: "1" }
  },
  "scale-out": {
    from: { scale: "1" },
    to: { scale: "0.95" }
  }
});
const letterSpacings = defineTokens.letterSpacings({
  tighter: { value: "-0.05em" },
  tight: { value: "-0.025em" },
  wide: { value: "0.025em" },
  wider: { value: "0.05em" },
  widest: { value: "0.1em" }
});
const lineHeights = defineTokens.lineHeights({
  shorter: { value: 1.25 },
  short: { value: 1.375 },
  moderate: { value: 1.5 },
  tall: { value: 1.625 },
  taller: { value: 2 }
});
const radii = defineTokens.radii({
  none: { value: "0" },
  "2xs": { value: "0.0625rem" },
  xs: { value: "0.125rem" },
  sm: { value: "0.25rem" },
  md: { value: "0.375rem" },
  lg: { value: "0.5rem" },
  xl: { value: "0.75rem" },
  "2xl": { value: "1rem" },
  "3xl": { value: "1.5rem" },
  "4xl": { value: "2rem" },
  full: { value: "9999px" }
});
const spacing = defineTokens.spacing({
  0.5: { value: "0.125rem" },
  1: { value: "0.25rem" },
  1.5: { value: "0.375rem" },
  2: { value: "0.5rem" },
  2.5: { value: "0.625rem" },
  3: { value: "0.75rem" },
  3.5: { value: "0.875rem" },
  4: { value: "1rem" },
  4.5: { value: "1.125rem" },
  5: { value: "1.25rem" },
  6: { value: "1.5rem" },
  7: { value: "1.75rem" },
  8: { value: "2rem" },
  9: { value: "2.25rem" },
  10: { value: "2.5rem" },
  11: { value: "2.75rem" },
  12: { value: "3rem" },
  14: { value: "3.5rem" },
  16: { value: "4rem" },
  20: { value: "5rem" },
  24: { value: "6rem" },
  28: { value: "7rem" },
  32: { value: "8rem" },
  36: { value: "9rem" },
  40: { value: "10rem" },
  44: { value: "11rem" },
  48: { value: "12rem" },
  52: { value: "13rem" },
  56: { value: "14rem" },
  60: { value: "15rem" },
  64: { value: "16rem" },
  72: { value: "18rem" },
  80: { value: "20rem" },
  96: { value: "24rem" }
});
const largeSizes = defineTokens.sizes({
  "3xs": { value: "14rem" },
  "2xs": { value: "16rem" },
  xs: { value: "20rem" },
  sm: { value: "24rem" },
  md: { value: "28rem" },
  lg: { value: "32rem" },
  xl: { value: "36rem" },
  "2xl": { value: "42rem" },
  "3xl": { value: "48rem" },
  "4xl": { value: "56rem" },
  "5xl": { value: "64rem" },
  "6xl": { value: "72rem" },
  "7xl": { value: "80rem" },
  "8xl": { value: "90rem" }
});
const namedSizes = defineTokens.sizes({
  max: { value: "max-content" },
  min: { value: "min-content" },
  fit: { value: "fit-content" },
  prose: { value: "60ch" },
  full: { value: "100%" },
  dvh: { value: "100dvh" },
  svh: { value: "100svh" },
  lvh: { value: "100lvh" },
  dvw: { value: "100dvw" },
  svw: { value: "100svw" },
  lvw: { value: "100lvw" },
  vw: { value: "100vw" },
  vh: { value: "100vh" }
});
const fractionalSizes = defineTokens.sizes({
  "1/2": { value: "50%" },
  "1/3": { value: "33.333333%" },
  "2/3": { value: "66.666667%" },
  "1/4": { value: "25%" },
  "3/4": { value: "75%" },
  "1/5": { value: "20%" },
  "2/5": { value: "40%" },
  "3/5": { value: "60%" },
  "4/5": { value: "80%" },
  "1/6": { value: "16.666667%" },
  "2/6": { value: "33.333333%" },
  "3/6": { value: "50%" },
  "4/6": { value: "66.666667%" },
  "5/6": { value: "83.333333%" },
  "1/12": { value: "8.333333%" },
  "2/12": { value: "16.666667%" },
  "3/12": { value: "25%" },
  "4/12": { value: "33.333333%" },
  "5/12": { value: "41.666667%" },
  "6/12": { value: "50%" },
  "7/12": { value: "58.333333%" },
  "8/12": { value: "66.666667%" },
  "9/12": { value: "75%" },
  "10/12": { value: "83.333333%" },
  "11/12": { value: "91.666667%" }
});
const sizes = defineTokens.sizes({
  ...largeSizes,
  ...spacing,
  ...fractionalSizes,
  ...namedSizes
});
const zIndices = defineTokens.zIndex({
  hide: { value: -1 },
  base: { value: 0 },
  docked: { value: 10 },
  dropdown: { value: 1e3 },
  sticky: { value: 1100 },
  banner: { value: 1200 },
  overlay: { value: 1300 },
  modal: { value: 1400 },
  popover: { value: 1500 },
  skipNav: { value: 1600 },
  toast: { value: 1700 },
  tooltip: { value: 1800 },
  max: { value: 2147483647 }
});
const defaultThemeConfig = defineConfig({
  preflight: true,
  cssVarsPrefix: "chakra",
  cssVarsRoot: ":where(html, .chakra-theme)",
  globalCss,
  theme: {
    breakpoints,
    keyframes,
    tokens: {
      aspectRatios,
      animations,
      blurs,
      borders,
      colors,
      durations,
      easings,
      fonts,
      fontSizes,
      fontWeights,
      letterSpacings,
      lineHeights,
      radii,
      spacing,
      sizes,
      zIndex: zIndices,
      cursor
    },
    semanticTokens: {
      colors: semanticColors,
      shadows: semanticShadows,
      radii: semanticRadii
    },
    recipes,
    slotRecipes,
    textStyles,
    layerStyles,
    animationStyles
  }
});
const defaultConfig = mergeConfigs(defaultBaseConfig, defaultThemeConfig);
const defaultSystem = createSystem(defaultConfig);
const EMPTY_STYLES = Object.freeze({});
const EMPTY_SLOT_STYLES = Object.freeze(
  {}
);
function useRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return reactExports.useMemo(() => {
    const recipe = recipeProp || (key != null ? sys.getRecipe(key) : {});
    return sys.cva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}
const upperFirst$1 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createRecipeContext(options) {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst$1(
    recipeKey || recipeConfig.className || "Component"
  );
  const [PropsProvider2, usePropsContext] = createContext({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`
  });
  const withContext2 = (Component, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = reactExports.forwardRef((inProps, ref2) => {
      const props = mergeProps$1(usePropsContext(), inProps);
      const { unstyled, ...otherProps } = props;
      const fallbackRecipe = props.recipe || recipeConfig;
      const recipe = useRecipe({ key: recipeKey, recipe: fallbackRecipe });
      const [variantProps, localProps] = recipe.splitVariantProps(otherProps);
      const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SuperComponent,
        {
          ...localProps,
          ref: ref2,
          css: [styles, props.css],
          className: cx(recipe.className, props.className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    withContext: withContext2,
    PropsProvider: PropsProvider2,
    usePropsContext
  };
}
function useSlotRecipe(options) {
  const { key, recipe: recipeProp } = options;
  const sys = useChakraContext();
  return reactExports.useMemo(() => {
    const recipe = recipeProp || (key != null ? sys.getSlotRecipe(key) : {});
    return sys.sva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}
const upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const createSlotRecipeContext = (options) => {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [StylesProvider2, useStyles] = createContext({
    name: `${contextName}StylesContext`,
    errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `
  });
  const [ClassNamesProvider2, useClassNames] = createContext({
    name: `${contextName}ClassNameContext`,
    errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `,
    strict: false
  });
  const [PropsProvider2, usePropsContext] = createContext({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`,
    defaultValue: {}
  });
  function useRecipeResult2(props) {
    const { unstyled, ...restProps } = props;
    const slotRecipe = useSlotRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = slotRecipe.splitVariantProps(restProps);
    const styles = unstyled ? EMPTY_SLOT_STYLES : slotRecipe(variantProps);
    return {
      styles,
      classNames: slotRecipe.classNameMap,
      props: otherProps
    };
  }
  function withRootProvider2(Component, options2 = {}) {
    const { defaultProps } = options2;
    const StyledComponent = (inProps) => {
      const props = mergeProps$1(defaultProps, usePropsContext(), inProps);
      const { styles, classNames, props: rootProps } = useRecipeResult2(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StylesProvider2, { value: styles, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClassNamesProvider2, { value: classNames, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...rootProps }) }) });
    };
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  }
  const withProvider2 = (Component, slot, options2) => {
    const { defaultProps, ...restOptions } = options2 ?? {};
    const SuperComponent = chakra(Component, {}, restOptions);
    const StyledComponent = reactExports.forwardRef((inProps, ref2) => {
      var _a2;
      const props = mergeProps$1(defaultProps ?? {}, usePropsContext(), inProps);
      const { styles, props: rootProps, classNames } = useRecipeResult2(props);
      const className = classNames[slot];
      const element = /* @__PURE__ */ jsxRuntimeExports.jsx(StylesProvider2, { value: styles, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClassNamesProvider2, { value: classNames, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SuperComponent,
        {
          ref: ref2,
          ...rootProps,
          css: [styles[slot], props.css],
          className: cx(props.className, className)
        }
      ) }) });
      return ((_a2 = options2 == null ? void 0 : options2.wrapElement) == null ? void 0 : _a2.call(options2, element, props)) ?? element;
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  const withContext2 = (Component, slot, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = reactExports.forwardRef((props, ref2) => {
      const styles = useStyles();
      const classNames = useClassNames();
      const className = classNames == null ? void 0 : classNames[slot];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SuperComponent,
        {
          ...props,
          css: [slot ? styles[slot] : void 0, props.css],
          ref: ref2,
          className: cx(props.className, className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    StylesProvider: StylesProvider2,
    ClassNamesProvider: ClassNamesProvider2,
    PropsProvider: PropsProvider2,
    usePropsContext,
    useRecipeResult: useRecipeResult2,
    withProvider: withProvider2,
    withContext: withContext2,
    withRootProvider: withRootProvider2,
    useStyles,
    useClassNames
  };
};
const CheckCircleIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11.0026 16L6.75999 11.7574L8.17421 10.3431L11.0026 13.1716L16.6595 7.51472L18.0737 8.92893L11.0026 16Z" })
  }
);
const WarningIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" })
  }
);
const CloseIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z"
  }
) });
const { PropsProvider: PropsProvider$g, withContext: withContext$i } = createRecipeContext({
  key: "badge"
});
const Badge = withContext$i("span");
const Box = chakra("div");
Box.displayName = "Box";
const Span = chakra("span");
const { withContext: withContext$h, PropsProvider: PropsProvider$f } = createRecipeContext({
  key: "button"
});
const Button$1 = withContext$h("button", {
  defaultProps: { type: "button" }
});
const IconButton = reactExports.forwardRef(
  function IconButton2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$1,
      {
        px: "0",
        py: "0",
        _icon: { fontSize: "1.2em" },
        ref: ref2,
        ...props
      }
    );
  }
);
const {
  withProvider: withProvider$4,
  withContext: withContext$g,
  useStyles: useCardStyles,
  PropsProvider: PropsProvider$e
} = createSlotRecipeContext({ key: "card" });
const CardRoot = withProvider$4(
  "div",
  "root"
);
const CardBody = withContext$g(
  "div",
  "body"
);
withContext$g(
  "div",
  "header"
);
withContext$g(
  "div",
  "footer"
);
const CardTitle = withContext$g(
  "h3",
  "title"
);
const CardDescription = withContext$g("p", "description");
const AbsoluteCenter = chakra("div", {
  base: {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    axis: {
      horizontal: {
        insetStart: "50%",
        transform: "translateX(-50%)"
      },
      vertical: {
        top: "50%",
        transform: "translateY(-50%)"
      },
      both: {
        insetStart: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)"
      }
    }
  },
  defaultVariants: {
    axis: "both"
  }
});
AbsoluteCenter.displayName = "AbsoluteCenter";
const dataAttr = (condition) => condition ? "" : void 0;
const { withContext: withContext$f, PropsProvider: PropsProvider$d } = createRecipeContext({
  key: "code"
});
const Code = withContext$f("code");
const {
  withProvider: withProvider$3,
  withContext: withContext$e,
  useStyles: useCollapsibleStyles,
  PropsProvider: PropsProvider$c
} = createSlotRecipeContext({ key: "collapsible" });
withProvider$3(CollapsibleRootProvider, "root", { forwardAsChild: true });
const CollapsibleRoot = withProvider$3(CollapsibleRoot$1, "root", { forwardAsChild: true });
withContext$e(CollapsibleTrigger, "trigger", { forwardAsChild: true });
const CollapsibleContent = withContext$e(CollapsibleContent$1, "content", { forwardAsChild: true });
const { withContext: withContext$d, PropsProvider: PropsProvider$b } = createRecipeContext({
  key: "container"
});
const Container = withContext$d("div");
const { withContext: withContext$c } = createRecipeContext({ key: "icon" });
const Icon$1 = withContext$c("svg", {
  defaultProps: {
    focusable: false,
    asChild: true,
    "aria-hidden": true
  }
});
const Flex = reactExports.forwardRef(
  function Flex2(props, ref2) {
    const {
      direction,
      align,
      justify,
      wrap: wrap2,
      basis,
      grow,
      shrink,
      inline,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref: ref2,
        ...rest,
        css: {
          display: inline ? "inline-flex" : "flex",
          flexDirection: direction,
          alignItems: align,
          justifyContent: justify,
          flexWrap: wrap2,
          flexBasis: basis,
          flexGrow: grow,
          flexShrink: shrink,
          ...props.css
        }
      }
    );
  }
);
const StyledGroup = chakra("div", {
  base: {
    display: "inline-flex",
    gap: "0.5rem",
    isolation: "isolate",
    position: "relative",
    "& [data-group-item]": {
      _focusVisible: {
        zIndex: 1
      }
    }
  },
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row"
      },
      vertical: {
        flexDirection: "column"
      }
    },
    attached: {
      true: {
        gap: "0!"
      }
    },
    grow: {
      true: {
        display: "flex",
        "& > *": {
          flex: 1
        }
      }
    },
    stacking: {
      "first-on-top": {
        "& > [data-group-item]": {
          zIndex: "calc(var(--group-count) - var(--group-index))"
        }
      },
      "last-on-top": {
        "& > [data-group-item]": {
          zIndex: "var(--group-index)"
        }
      }
    }
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderEndRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-last]": {
          borderStartRadius: "0!"
        }
      }
    },
    {
      orientation: "vertical",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderBottomRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-last]": {
          borderTopRadius: "0!"
        }
      }
    }
  ],
  defaultVariants: {
    orientation: "horizontal"
  }
});
const Group = reactExports.memo(
  reactExports.forwardRef(function Group2(props, ref2) {
    const {
      align = "center",
      justify = "flex-start",
      children,
      wrap: wrap2,
      ...rest
    } = props;
    const count = reactExports.Children.count(children);
    const _children = reactExports.useMemo(() => {
      const childArray = reactExports.Children.toArray(children).filter(
        reactExports.isValidElement
      );
      return childArray.map((child, index) => {
        const childProps = child.props;
        return reactExports.cloneElement(child, {
          ...childProps,
          "data-group-item": "",
          "data-first": dataAttr(index === 0),
          "data-last": dataAttr(index === count - 1),
          "data-between": dataAttr(index > 0 && index < count - 1),
          style: {
            "--group-count": count,
            "--group-index": index,
            ...(childProps == null ? void 0 : childProps.style) ?? {}
          }
        });
      });
    }, [children, count]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      StyledGroup,
      {
        ref: ref2,
        alignItems: align,
        justifyContent: justify,
        flexWrap: wrap2,
        ...rest,
        children: _children
      }
    );
  })
);
const Image = reactExports.forwardRef(
  function Image2(props, ref2) {
    const { align, fit = "cover", ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.img,
      {
        ref: ref2,
        objectFit: fit,
        objectPosition: align,
        className: cx("chakra-image", props.className),
        ...rest
      }
    );
  }
);
const { withContext: withContext$b, PropsProvider: PropsProvider$a } = createRecipeContext({
  key: "input"
});
const Input = withContext$b(FieldInput);
const InputElement = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    zIndex: 2,
    color: "fg.subtle",
    height: "full",
    fontSize: "sm",
    px: "3"
  },
  variants: {
    placement: {
      start: {
        insetInlineStart: "0"
      },
      end: {
        insetInlineEnd: "0"
      }
    }
  }
});
const { withContext: withContext$a, PropsProvider: PropsProvider$9 } = createRecipeContext({
  key: "link"
});
const Link = withContext$a("a");
const {
  withProvider: withProvider$2,
  withContext: withContext$9,
  useStyles: useListStyles,
  PropsProvider: PropsProvider$8
} = createSlotRecipeContext({ key: "list" });
const ListRoot = withProvider$2(
  "ul",
  "root",
  { defaultProps: { role: "list" } }
);
const ListItem = withContext$9("li", "item");
const ListIndicator = withContext$9(
  "span",
  "indicator"
);
const {
  withRootProvider: withRootProvider$1,
  withContext: withContext$8,
  useStyles: usePopoverStyles,
  PropsProvider: PropsProvider$7
} = createSlotRecipeContext({ key: "popover" });
withRootProvider$1(
  PopoverRootProvider
);
const PopoverRoot$1 = withRootProvider$1(PopoverRoot$2);
const PopoverTrigger$1 = withContext$8(PopoverTrigger$2, "trigger", { forwardAsChild: true });
const PopoverPositioner = withContext$8(PopoverPositioner$1, "positioner", { forwardAsChild: true });
const PopoverContent$1 = withContext$8(
  PopoverContent$2,
  "content",
  { forwardAsChild: true }
);
const PopoverArrow = withContext$8(
  PopoverArrow$1,
  "arrow",
  { forwardAsChild: true }
);
const PopoverArrowTip = withContext$8(PopoverArrowTip$1, "arrowTip", { forwardAsChild: true });
const PopoverCloseTrigger = withContext$8(PopoverCloseTrigger$1, "closeTrigger", { forwardAsChild: true });
withContext$8(PopoverIndicator, "indicator", { forwardAsChild: true });
withContext$8(
  PopoverTitle,
  "title",
  { forwardAsChild: true }
);
withContext$8(PopoverDescription, "description", { forwardAsChild: true });
withContext$8(
  "footer",
  "footer"
);
withContext$8(
  "header",
  "header"
);
const PopoverBody$1 = withContext$8(
  "div",
  "body"
);
withContext$8(
  PopoverAnchor,
  void 0,
  { forwardAsChild: true }
);
const Portal = (props) => {
  var _a2;
  const { children, disabled } = props;
  const [container, setContainer] = reactExports.useState((_a2 = props.container) == null ? void 0 : _a2.current);
  const isServer = reactExports.useSyncExternalStore(
    subscribe,
    () => false,
    () => true
  );
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  reactExports.useEffect(() => {
    setContainer(() => {
      var _a3;
      return (_a3 = props.container) == null ? void 0 : _a3.current;
    });
  }, [props.container]);
  if (isServer || disabled) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  const mountNode = container ?? getPortalNode(getRootNode2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: reactExports.Children.map(children, (child) => reactDomExports.createPortal(child, mountNode)) });
};
const getPortalNode = (cb2) => {
  const node2 = cb2 == null ? void 0 : cb2();
  const rootNode = node2.getRootNode();
  if (isShadowRoot$1(rootNode)) return rootNode;
  return getDocument(node2).body;
};
const subscribe = () => () => {
};
const {
  withProvider: withProvider$1,
  withContext: withContext$7,
  useStyles: useProgressStyles,
  PropsProvider: PropsProvider$6
} = createSlotRecipeContext({ key: "progress" });
withProvider$1(ProgressRootProvider, "root", { forwardAsChild: true });
const ProgressRoot = withProvider$1(
  ProgressRoot$1,
  "root"
);
const ProgressLabel = withContext$7(
  ProgressLabel$1,
  "label",
  { forwardAsChild: true }
);
const ProgressTrack = withContext$7(
  ProgressTrack$1,
  "track",
  { forwardAsChild: true }
);
const ProgressRange = withContext$7(
  ProgressRange$1,
  "range",
  { forwardAsChild: true }
);
const ProgressValueText = withContext$7(ProgressValueText$1, "valueText", { forwardAsChild: true });
const { withContext: withContext$6, PropsProvider: PropsProvider$5 } = createRecipeContext({
  key: "separator"
});
const Separator = withContext$6("span", {
  defaultProps: { role: "separator" }
});
const { withContext: withContext$5, PropsProvider: PropsProvider$4 } = createRecipeContext({
  key: "spinner"
});
const Spinner = withContext$5("span");
function getSeparatorStyles(options) {
  const { gap, direction } = options;
  const styles = {
    column: {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    "column-reverse": {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    row: {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    },
    "row-reverse": {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    }
  };
  return {
    "&": mapObject(direction, (value) => styles[value])
  };
}
function getValidChildren(children) {
  return reactExports.Children.toArray(children).filter(
    (child) => reactExports.isValidElement(child)
  );
}
const Stack = reactExports.forwardRef(
  function Stack2(props, ref2) {
    const {
      direction = "column",
      align,
      justify,
      gap = "0.5rem",
      wrap: wrap2,
      children,
      separator,
      className,
      ...rest
    } = props;
    const separatorStyle = reactExports.useMemo(
      () => getSeparatorStyles({ gap, direction }),
      [gap, direction]
    );
    const clones = reactExports.useMemo(() => {
      if (!separator) return children;
      return getValidChildren(children).map((child, index, arr) => {
        const key = typeof child.key !== "undefined" ? child.key : index;
        const sep = reactExports.cloneElement(separator, {
          css: [separatorStyle, separator.props.css]
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
          child,
          index === arr.length - 1 ? null : sep
        ] }, key);
      });
    }, [children, separator, separatorStyle]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref: ref2,
        display: "flex",
        alignItems: align,
        justifyContent: justify,
        flexDirection: direction,
        flexWrap: wrap2,
        gap: separator ? void 0 : gap,
        className: cx("chakra-stack", className),
        ...rest,
        children: clones
      }
    );
  }
);
const HStack = reactExports.forwardRef(
  function HStack2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { align: "center", ...props, direction: "row", ref: ref2 });
  }
);
const VStack = reactExports.forwardRef(
  function VStack2(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { align: "center", ...props, direction: "column", ref: ref2 });
  }
);
const {
  StylesProvider,
  ClassNamesProvider,
  useRecipeResult,
  withContext: withContext$4,
  useStyles: useTableStyles,
  PropsProvider: PropsProvider$3
} = createSlotRecipeContext({ key: "table" });
const TableRoot = reactExports.forwardRef(
  function TableRoot2({ native, ...props }, ref2) {
    const { styles, props: rootProps, classNames } = useRecipeResult(props);
    const rootCss = reactExports.useMemo(() => {
      if (!native) return styles.root;
      return {
        ...styles.root,
        "& thead": styles.header,
        "& tbody": styles.body,
        "& tfoot": styles.footer,
        "& thead th": styles.columnHeader,
        "& tr": styles.row,
        "& td": styles.cell,
        "& caption": styles.caption
      };
    }, [styles, native]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClassNamesProvider, { value: classNames, children: /* @__PURE__ */ jsxRuntimeExports.jsx(StylesProvider, { value: styles, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.table,
      {
        ref: ref2,
        ...rootProps,
        css: [rootCss, props.css],
        className: cx(classNames == null ? void 0 : classNames["root"], props.className)
      }
    ) }) });
  }
);
const TableRow = withContext$4(
  "tr",
  "row"
);
chakra("div", {
  base: {
    display: "block",
    whiteSpace: "nowrap",
    WebkitOverflowScrolling: "touch",
    overflow: "auto",
    maxWidth: "100%"
  }
});
withContext$4("thead", "header");
withContext$4("tfoot", "footer");
withContext$4("th", "columnHeader");
const TableCell = withContext$4(
  "td",
  "cell"
);
withContext$4("caption", "caption", {
  defaultProps: {
    captionSide: "bottom"
  }
});
const TableBody = withContext$4(
  "tbody",
  "body"
);
withContext$4("colgroup");
withContext$4(
  "col"
);
var anatomy = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts = anatomy.build();
var dom = createScope({
  getRegionId: (placement) => `toast-group:${placement}`,
  getRegionEl: (ctx, placement) => dom.getById(ctx, `toast-group:${placement}`),
  getRootId: (ctx) => `toast:${ctx.id}`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTitleId: (ctx) => `toast:${ctx.id}:title`,
  getDescriptionId: (ctx) => `toast:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => `toast${ctx.id}:close`
});
function getToastsByPlacement(toasts, placement) {
  return toasts.filter((toast) => toast.state.context.placement === placement);
}
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;
}
function getGroupPlacementStyle(ctx, placement) {
  var _a2;
  const offset2 = ctx.offsets;
  const computedOffset = typeof offset2 === "string" ? { left: offset2, right: offset2, bottom: offset2, top: offset2 } : offset2;
  const rtl = ctx.dir === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles = {
    position: "fixed",
    pointerEvents: ctx.count > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${ctx.gap}px`,
    "--first-height": `${((_a2 = ctx.heights[0]) == null ? void 0 : _a2.height) || 0}px`,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  styles.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset22 = computedOffset.top;
    styles.top = `max(env(safe-area-inset-top, 0px), ${offset22})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset22 = computedOffset.bottom;
    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset22})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset22 = computedOffset.right;
    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset22})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset22 = computedOffset.left;
    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset22})`;
  }
  return styles;
}
function getPlacementStyle(ctx, visible) {
  const [side] = ctx.placement.split("-");
  const sibling = !ctx.frontmost;
  const overlap = !ctx.stacked;
  const styles = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${ctx.removeDelay}ms`,
    "--duration": `${ctx.type === "loading" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,
    "--initial-height": `${ctx.height}px`,
    "--offset": `${ctx.offset}px`,
    "--index": ctx.index,
    "--z-index": ctx.zIndex,
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (side === "top") {
    assign2({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign2({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (ctx.mounted) {
    assign2({
      "--y": "0",
      "--opacity": "1"
    });
    if (ctx.stacked) {
      assign2({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign2({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling && overlap) {
    assign2({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign2({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling && ctx.stacked && !visible) {
    assign2({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (ctx.frontmost && !visible) {
    assign2({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles;
}
function getGhostBeforeStyle(ctx, visible) {
  const styles = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (ctx.frontmost && !visible) {
    assign2({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles;
}
function getGhostAfterStyle(_ctx, _visible) {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(serviceOrState, send, normalize2) {
  function getState() {
    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState;
    return result;
  }
  function getToastsByPlacementImpl(placement) {
    return getToastsByPlacement(getState().context.toasts, placement);
  }
  function isVisible2(id2) {
    const toasts = getState().context.toasts;
    if (!toasts.length) return false;
    return !!toasts.find((toast) => toast.id == id2);
  }
  function create(options) {
    const uid = `toast:${uuid()}`;
    const id2 = options.id ? options.id : uid;
    if (isVisible2(id2)) return id2;
    send({ type: "ADD_TOAST", toast: { ...options, id: id2 } });
    return id2;
  }
  function update(id2, options) {
    if (!isVisible2(id2)) return id2;
    send({ type: "UPDATE_TOAST", id: id2, toast: options });
    return id2;
  }
  function upsert(options) {
    const { id: id2 } = options;
    const visible = id2 ? isVisible2(id2) : false;
    if (visible && id2 != null) {
      return update(id2, options);
    } else {
      return create(options);
    }
  }
  function dismiss(id2) {
    if (id2 == null) {
      send("DISMISS_ALL");
    } else if (isVisible2(id2)) {
      send({ type: "DISMISS_TOAST", id: id2 });
    }
  }
  return {
    getCount() {
      return getState().context.count;
    },
    getPlacements() {
      const toasts = getState().context.toasts;
      const placements = toasts.map((toast) => toast.state.context.placement);
      return Array.from(new Set(placements));
    },
    getToastsByPlacement: getToastsByPlacementImpl,
    isVisible: isVisible2,
    create,
    update,
    upsert,
    dismiss,
    remove(id2) {
      if (id2 == null) {
        send("REMOVE_ALL");
      } else if (isVisible2(id2)) {
        send({ type: "REMOVE_TOAST", id: id2 });
      }
    },
    dismissByPlacement(placement) {
      const toasts = getToastsByPlacementImpl(placement);
      toasts.forEach((toast) => dismiss(toast.id));
    },
    loading(options) {
      return upsert({ ...options, type: "loading" });
    },
    success(options) {
      return upsert({ ...options, type: "success" });
    },
    error(options) {
      return upsert({ ...options, type: "error" });
    },
    promise(promise, options, shared = {}) {
      const id2 = upsert({ ...shared, ...options.loading, type: "loading" });
      runIfFn(promise).then((response) => {
        const successOptions = runIfFn(options.success, response);
        upsert({ ...shared, ...successOptions, id: id2, type: "success" });
      }).catch((error) => {
        const errorOptions = runIfFn(options.error, error);
        upsert({ ...shared, ...errorOptions, id: id2, type: "error" });
      }).finally(() => {
        var _a2;
        (_a2 = options.finally) == null ? void 0 : _a2.call(options);
      });
      return id2;
    },
    pause(id2) {
      if (id2 == null) {
        send("PAUSE_ALL");
      } else if (isVisible2(id2)) {
        send({ type: "PAUSE_TOAST", id: id2 });
      }
    },
    resume(id2) {
      if (id2 == null) {
        send("RESUME_ALL");
      } else if (isVisible2(id2)) {
        send({ type: "RESUME_TOAST", id: id2 });
      }
    },
    getGroupProps(options) {
      const { placement, label = "Notifications" } = options;
      const state = getState();
      const hotkeyLabel = state.context.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const [side, align = "center"] = placement.split("-");
      return normalize2.element({
        ...parts.group.attrs,
        dir: state.context.dir,
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: dom.getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(state.context, placement),
        onMouseMove() {
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (state.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {
            send({ type: "REGION.BLUR" });
          }
        }
      });
    },
    subscribe(fn) {
      const state = getState();
      return subscribe$1(state.context.toasts, () => {
        const toasts = getToastsByPlacementImpl(state.context.placement);
        const contexts = toasts.map((toast) => toast.getState().context);
        fn(contexts);
      });
    }
  };
}
var { not, and, or } = guards;
function createToastMachine(options) {
  const { type = "info", duration, id: id2 = "1", placement = "bottom", removeDelay = 200, ...restProps } = options;
  const ctx = compact$1(restProps);
  const computedDuration = getToastDuration(duration, type);
  return createMachine(
    {
      id: id2,
      context: {
        id: id2,
        type,
        remaining: computedDuration,
        duration: computedDuration,
        removeDelay,
        createdAt: Date.now(),
        placement,
        ...ctx,
        height: 0,
        offset: 0,
        frontmost: false,
        mounted: false,
        index: -1,
        zIndex: 0
      },
      initial: type === "loading" ? "visible:persist" : "visible",
      on: {
        UPDATE: [
          {
            guard: and("hasTypeChanged", "isChangingToLoading"),
            target: "visible:persist",
            actions: ["setContext"]
          },
          {
            guard: or("hasDurationChanged", "hasTypeChanged"),
            target: "visible:updating",
            actions: ["setContext"]
          },
          {
            actions: ["setContext"]
          }
        ],
        MEASURE: {
          actions: ["measureHeight"]
        }
      },
      entry: ["invokeOnVisible"],
      activities: ["trackHeight"],
      states: {
        "visible:updating": {
          tags: ["visible", "updating"],
          after: {
            0: "visible"
          }
        },
        "visible:persist": {
          tags: ["visible", "paused"],
          on: {
            RESUME: {
              guard: not("isLoadingType"),
              target: "visible",
              actions: ["setCreatedAt"]
            },
            DISMISS: "dismissing"
          }
        },
        visible: {
          tags: ["visible"],
          after: {
            VISIBLE_DURATION: "dismissing"
          },
          on: {
            DISMISS: "dismissing",
            PAUSE: {
              target: "visible:persist",
              actions: "setRemainingDuration"
            }
          }
        },
        dismissing: {
          entry: "invokeOnDismiss",
          after: {
            REMOVE_DELAY: {
              target: "unmounted",
              actions: "notifyParentToRemove"
            }
          }
        },
        unmounted: {
          entry: "invokeOnUnmount",
          type: "final"
        }
      }
    },
    {
      activities: {
        trackHeight(ctx2, _evt, { self: self2 }) {
          let cleanup;
          raf$1(() => {
            const rootEl = dom.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const ghosts = queryAll(rootEl, "[data-ghost]");
            warn(
              ghosts.length !== 2,
              "[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements"
            );
            const syncHeight = () => {
              const originalHeight = rootEl.style.height;
              rootEl.style.height = "auto";
              const newHeight = rootEl.getBoundingClientRect().height;
              rootEl.style.height = originalHeight;
              ctx2.height = newHeight;
              self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
            };
            syncHeight();
            const win = dom.getWin(ctx2);
            const observer = new win.MutationObserver(syncHeight);
            observer.observe(rootEl, { childList: true, subtree: true, characterData: true });
            cleanup = () => observer.disconnect();
          });
          return () => cleanup == null ? void 0 : cleanup();
        }
      },
      guards: {
        isChangingToLoading: (_, evt) => {
          var _a2;
          return ((_a2 = evt.toast) == null ? void 0 : _a2.type) === "loading";
        },
        isLoadingType: (ctx2) => ctx2.type === "loading",
        hasTypeChanged: (ctx2, evt) => {
          var _a2;
          return ((_a2 = evt.toast) == null ? void 0 : _a2.type) != null && evt.toast.type !== ctx2.type;
        },
        hasDurationChanged: (ctx2, evt) => {
          var _a2;
          return ((_a2 = evt.toast) == null ? void 0 : _a2.duration) != null && evt.toast.duration !== ctx2.duration;
        }
      },
      delays: {
        VISIBLE_DURATION: (ctx2) => ctx2.remaining,
        REMOVE_DELAY: (ctx2) => ctx2.removeDelay
      },
      actions: {
        measureHeight(ctx2, _evt, { self: self2 }) {
          raf$1(() => {
            const rootEl = dom.getRootEl(ctx2);
            if (!rootEl) return;
            ctx2.mounted = true;
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const newHeight = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            ctx2.height = newHeight;
            self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
          });
        },
        setRemainingDuration(ctx2) {
          ctx2.remaining -= Date.now() - ctx2.createdAt;
        },
        setCreatedAt(ctx2) {
          ctx2.createdAt = Date.now();
        },
        notifyParentToRemove(_ctx, _evt, { self: self2 }) {
          self2.sendParent({ type: "REMOVE_TOAST", id: self2.id });
        },
        invokeOnDismiss(ctx2) {
          var _a2;
          (_a2 = ctx2.onStatusChange) == null ? void 0 : _a2.call(ctx2, { status: "dismissing" });
        },
        invokeOnUnmount(ctx2) {
          var _a2;
          (_a2 = ctx2.onStatusChange) == null ? void 0 : _a2.call(ctx2, { status: "unmounted" });
        },
        invokeOnVisible(ctx2) {
          var _a2;
          (_a2 = ctx2.onStatusChange) == null ? void 0 : _a2.call(ctx2, { status: "visible" });
        },
        setContext(ctx2, evt) {
          var _a2, _b2;
          const duration2 = (_a2 = evt.toast) == null ? void 0 : _a2.duration;
          const type2 = ((_b2 = evt.toast) == null ? void 0 : _b2.type) ?? ctx2.type;
          const computedDuration2 = getToastDuration(duration2, type2);
          Object.assign(ctx2, {
            ...evt.toast,
            duration: computedDuration2,
            remaining: computedDuration2
          });
        }
      }
    }
  );
}
function groupMachine(userContext) {
  const ctx = compact$1(userContext);
  return createMachine(
    {
      id: "toaster",
      initial: ctx.overlap ? "overlap" : "stack",
      context: {
        dir: "ltr",
        max: Number.MAX_SAFE_INTEGER,
        gap: 16,
        pauseOnPageIdle: false,
        hotkey: ["altKey", "KeyT"],
        offsets: "1rem",
        placement: "bottom",
        removeDelay: 200,
        ...ctx,
        toasts: [],
        lastFocusedEl: null,
        isFocusWithin: false,
        heights: []
      },
      computed: {
        count: (ctx2) => ctx2.toasts.length
      },
      activities: ["trackDocumentVisibility", "trackHotKeyPress"],
      watch: {
        toasts: ["collapsedIfEmpty", "setDismissableBranch"]
      },
      exit: ["removeToasts", "clearDismissableBranch", "clearLastFocusedEl"],
      on: {
        PAUSE_TOAST: {
          actions: ["pauseToast"]
        },
        PAUSE_ALL: {
          actions: ["pauseToasts"]
        },
        RESUME_TOAST: {
          actions: ["resumeToast"]
        },
        RESUME_ALL: {
          actions: ["resumeToasts"]
        },
        ADD_TOAST: {
          guard: "isWithinRange",
          actions: ["createToast", "syncToastIndex"]
        },
        UPDATE_TOAST: {
          actions: ["updateToast"]
        },
        DISMISS_TOAST: {
          actions: ["dismissToast"]
        },
        DISMISS_ALL: {
          actions: ["dismissToasts"]
        },
        REMOVE_TOAST: {
          actions: ["removeToast", "syncToastIndex", "syncToastOffset"]
        },
        REMOVE_ALL: {
          actions: ["removeToasts"]
        },
        UPDATE_HEIGHT: {
          actions: ["syncHeights", "syncToastOffset"]
        },
        "DOC.HOTKEY": {
          actions: ["focusRegionEl"]
        },
        "REGION.BLUR": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          },
          {
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          }
        ]
      },
      states: {
        stack: {
          entry: ["expandToasts"],
          on: {
            "REGION.POINTER_LEAVE": [
              {
                guard: "isOverlapping",
                target: "overlap",
                actions: ["resumeToasts"]
              },
              {
                actions: ["resumeToasts"]
              }
            ],
            "REGION.OVERLAP": {
              target: "overlap"
            },
            "REGION.FOCUS": {
              actions: ["setLastFocusedEl", "pauseToasts"]
            },
            "REGION.POINTER_ENTER": {
              actions: ["pauseToasts"]
            }
          }
        },
        overlap: {
          entry: ["collapseToasts"],
          on: {
            "REGION.STACK": {
              target: "stack"
            },
            "REGION.POINTER_ENTER": {
              target: "stack",
              actions: ["pauseToasts"]
            },
            "REGION.FOCUS": {
              target: "stack",
              actions: ["setLastFocusedEl", "pauseToasts"]
            }
          }
        }
      }
    },
    {
      guards: {
        isWithinRange: (ctx2) => ctx2.toasts.length < ctx2.max,
        isOverlapping: (ctx2) => !!ctx2.overlap
      },
      activities: {
        trackHotKeyPress(ctx2, _evt, { send }) {
          const handleKeyDown = (event) => {
            const isHotkeyPressed = ctx2.hotkey.every((key) => event[key] || event.code === key);
            if (!isHotkeyPressed) return;
            send({ type: "DOC.HOTKEY" });
          };
          return addDomEvent(document, "keydown", handleKeyDown, { capture: true });
        },
        trackDocumentVisibility(ctx2, _evt, { send }) {
          if (!ctx2.pauseOnPageIdle) return;
          const doc = dom.getDoc(ctx2);
          return addDomEvent(doc, "visibilitychange", () => {
            send(doc.visibilityState === "hidden" ? "PAUSE_ALL" : "RESUME_ALL");
          });
        }
      },
      actions: {
        setDismissableBranch(ctx2) {
          var _a2;
          const currentToasts = getToastsByPlacement(ctx2.toasts, ctx2.placement);
          const hasToasts = currentToasts.length > 0;
          if (!hasToasts) {
            (_a2 = ctx2._cleanup) == null ? void 0 : _a2.call(ctx2);
            return;
          }
          if (hasToasts && ctx2._cleanup) {
            return;
          }
          const groupEl = () => dom.getRegionEl(ctx2, ctx2.placement);
          ctx2._cleanup = trackDismissableBranch(groupEl, { defer: true });
        },
        clearDismissableBranch(ctx2) {
          var _a2;
          (_a2 = ctx2._cleanup) == null ? void 0 : _a2.call(ctx2);
        },
        focusRegionEl(ctx2) {
          queueMicrotask(() => {
            var _a2;
            (_a2 = dom.getRegionEl(ctx2, ctx2.placement)) == null ? void 0 : _a2.focus();
          });
        },
        expandToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = true;
          });
        },
        collapseToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = false;
          });
        },
        collapsedIfEmpty(ctx2, _evt, { send }) {
          if (!ctx2.overlap || ctx2.toasts.length > 1) return;
          send("REGION.OVERLAP");
        },
        pauseToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("PAUSE", evt.id);
        },
        pauseToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("PAUSE"));
        },
        resumeToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("RESUME", evt.id);
        },
        resumeToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("RESUME"));
        },
        measureToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("MEASURE"));
        },
        createToast(ctx2, evt, { self: self2, getState }) {
          const options = {
            placement: ctx2.placement,
            duration: ctx2.duration,
            removeDelay: ctx2.removeDelay,
            ...evt.toast,
            dir: ctx2.dir,
            getRootNode: ctx2.getRootNode,
            stacked: getState().matches("stack")
          };
          const toast = createToastMachine(options);
          const actor = self2.spawn(toast);
          ctx2.toasts = [actor, ...ctx2.toasts];
        },
        updateToast(_ctx, evt, { self: self2 }) {
          self2.sendChild({ type: "UPDATE", toast: evt.toast }, evt.id);
        },
        dismissToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("DISMISS", evt.id);
        },
        dismissToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("DISMISS"));
        },
        removeToast(ctx2, evt, { self: self2 }) {
          self2.stopChild(evt.id);
          ctx2.toasts = ctx2.toasts.filter((toast) => toast.id !== evt.id);
          ctx2.heights = ctx2.heights.filter((height) => height.id !== evt.id);
        },
        removeToasts(ctx2, _evt, { self: self2 }) {
          ctx2.toasts.forEach((toast) => self2.stopChild(toast.id));
          ctx2.toasts = [];
          ctx2.heights = [];
        },
        syncHeights(ctx2, evt) {
          const existing = ctx2.heights.find((height) => height.id === evt.id);
          if (existing) {
            existing.height = evt.height;
            existing.placement = evt.placement;
          } else {
            const newHeight = { id: evt.id, height: evt.height, placement: evt.placement };
            ctx2.heights = [newHeight, ...ctx2.heights];
          }
        },
        syncToastIndex(ctx2) {
          each(ctx2, (toast, index, toasts) => {
            toast.state.context.index = index;
            toast.state.context.frontmost = index === 0;
            toast.state.context.zIndex = toasts.length - index;
          });
        },
        syncToastOffset(ctx2, evt) {
          const placement = evt.placement ?? ctx2.placement;
          each({ ...ctx2, placement }, (toast) => {
            const heightIndex = Math.max(
              ctx2.heights.findIndex((height) => height.id === toast.id),
              0
            );
            const toastsHeightBefore = ctx2.heights.reduce((prev2, curr, reducerIndex) => {
              if (reducerIndex >= heightIndex) return prev2;
              return prev2 + curr.height;
            }, 0);
            toast.state.context.offset = heightIndex * ctx2.gap + toastsHeightBefore;
          });
        },
        setLastFocusedEl(ctx2, evt) {
          if (ctx2.isFocusWithin || !evt.target) return;
          ctx2.isFocusWithin = true;
          ctx2.lastFocusedEl = ref(evt.target);
        },
        restoreLastFocusedEl(ctx2) {
          ctx2.isFocusWithin = false;
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
        },
        clearLastFocusedEl(ctx2) {
          if (!ctx2.lastFocusedEl) return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
          ctx2.isFocusWithin = false;
        }
      }
    }
  );
}
function each(ctx, fn) {
  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement);
  currentToasts.forEach(fn);
}
function connect(state, send, normalize2) {
  const visible = state.hasTag("visible");
  const paused = state.hasTag("paused");
  const placement = state.context.placement;
  const type = state.context.type;
  const [side, align = "center"] = placement.split("-");
  return {
    type,
    title: state.context.title,
    description: state.context.description,
    placement,
    visible,
    paused,
    pause() {
      send("PAUSE");
    },
    resume() {
      send("RESUME");
    },
    dismiss() {
      send("DISMISS");
    },
    getRootProps() {
      return normalize2.element({
        ...parts.root.attrs,
        dir: state.context.dir,
        id: dom.getRootId(state.context),
        "data-state": visible ? "open" : "closed",
        "data-type": type,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr$1(state.context.mounted),
        "data-paused": dataAttr$1(paused),
        "data-first": dataAttr$1(state.context.frontmost),
        "data-sibling": dataAttr$1(!state.context.frontmost),
        "data-stack": dataAttr$1(state.context.stacked),
        "data-overlap": dataAttr$1(!state.context.stacked),
        role: "status",
        "aria-atomic": "true",
        "aria-describedby": state.context.description ? dom.getDescriptionId(state.context) : void 0,
        "aria-labelledby": state.context.title ? dom.getTitleId(state.context) : void 0,
        tabIndex: 0,
        style: getPlacementStyle(state.context, visible),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key == "Escape") {
            send("DISMISS");
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize2.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(state.context, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize2.element({
        "data-ghost": "after",
        style: getGhostAfterStyle()
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts.title.attrs,
        id: dom.getTitleId(state.context)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts.description.attrs,
        id: dom.getDescriptionId(state.context)
      });
    },
    getActionTriggerProps() {
      return normalize2.button({
        ...parts.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          var _a2, _b2;
          if (event.defaultPrevented) return;
          (_b2 = (_a2 = state.context.action) == null ? void 0 : _a2.onClick) == null ? void 0 : _b2.call(_a2);
          send("DISMISS");
        }
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        id: dom.getCloseTriggerId(state.context),
        ...parts.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("DISMISS");
        }
      });
    }
  };
}
var group = {
  connect: groupConnect,
  machine: groupMachine
};
const createToaster = (props) => {
  const machine2 = group.machine({ id: "1", ...props });
  const api = group.connect(machine2, machine2.send, normalizeProps);
  return { ...api, machine: machine2 };
};
const [ToastProvider, useToastContext] = createContext$1({
  name: "ToastContext",
  hookName: "useToastContext",
  providerName: "<ToastProvider />"
});
const ToastActionTrigger$1 = reactExports.forwardRef(
  (props, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps(toast.getActionTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastActionTrigger$1.displayName = "ToastActionTrigger";
const ToastCloseTrigger$1 = reactExports.forwardRef(
  (props, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps(toast.getCloseTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastCloseTrigger$1.displayName = "ToastCloseTrigger";
const ToastDescription$1 = reactExports.forwardRef((props, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getDescriptionProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
ToastDescription$1.displayName = "ToastDescription";
const ToastRoot$1 = reactExports.forwardRef((props, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getRootProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...mergedProps, ref: ref2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...toast.getGhostBeforeProps() }),
    props.children,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...toast.getGhostAfterProps() })
  ] });
});
ToastRoot$1.displayName = "ToastRoot";
const ToastTitle$1 = reactExports.forwardRef((props, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getTitleProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2 });
});
ToastTitle$1.displayName = "ToastTitle";
const Toaster$2 = reactExports.forwardRef((props, ref2) => {
  const { toaster: toaster2, children, ...rest } = props;
  const [state, send] = useMachine(toaster2.machine);
  const placement = state.context.placement;
  const api = group.connect(state, send, normalizeProps);
  const toasts = api.getToastsByPlacement(placement);
  const mergedProps = mergeProps(api.getGroupProps({ placement }), rest);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: ref2, children: toasts.map((toast2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ToastActor, { value: toast2, children: (ctx) => children(ctx) }, toast2.id)) });
});
Toaster$2.displayName = "Toaster";
const ToastActor = (props) => {
  const [state, send] = useActor(props.value);
  const api = connect(state, send, normalizeProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastProvider, { value: api, children: props.children(state.context) });
};
const {
  withProvider,
  withContext: withContext$3,
  useStyles: useToastStyles
} = createSlotRecipeContext({ key: "toast" });
const Toaster$1 = chakra(
  Toaster$2,
  {},
  { forwardAsChild: true }
);
const ToastRoot = withProvider(
  ToastRoot$1,
  "root",
  { forwardAsChild: true }
);
const ToastCloseTrigger = withContext$3(ToastCloseTrigger$1, "closeTrigger", {
  forwardAsChild: true,
  defaultProps: {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {})
  }
});
const ToastTitle = withContext$3(
  ToastTitle$1,
  "title",
  { forwardAsChild: true }
);
const ToastDescription = withContext$3(ToastDescription$1, "description", { forwardAsChild: true });
const ToastActionTrigger = withContext$3(ToastActionTrigger$1, "actionTrigger", { forwardAsChild: true });
const iconMap = {
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon
};
const ToastIndicator = reactExports.forwardRef(
  function ToastIndicator2(props, ref2) {
    const api = useToastContext();
    const styles = useToastStyles();
    const Component = iconMap[api.type];
    if (!Component) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ref: ref2, ...props, css: [styles.indicator, props.css] });
  }
);
const {
  withRootProvider,
  withContext: withContext$2,
  useStyles: useTooltipStyles,
  PropsProvider: PropsProvider$2
} = createSlotRecipeContext({ key: "tooltip" });
withRootProvider(
  TooltipRootProvider
);
const TooltipRoot = withRootProvider(TooltipRoot$1);
const TooltipTrigger = withContext$2(TooltipTrigger$1, "trigger", { forwardAsChild: true });
const TooltipPositioner = withContext$2(TooltipPositioner$1, "positioner", { forwardAsChild: true });
const TooltipContent = withContext$2(
  TooltipContent$1,
  "content",
  { forwardAsChild: true }
);
const TooltipArrow = withContext$2(
  TooltipArrow$1,
  "arrow",
  { forwardAsChild: true }
);
const TooltipArrowTip = withContext$2(TooltipArrowTip$1, "arrowTip", { forwardAsChild: true });
const { withContext: withContext$1, PropsProvider: PropsProvider$1 } = createRecipeContext({
  key: "heading"
});
const Heading = withContext$1("h2");
const { withContext, PropsProvider } = createRecipeContext({
  key: "text"
});
const Text = withContext("p");
const Em = chakra("em", {
  base: {
    fontStyle: "italic"
  }
});
const Strong = chakra("strong", {
  base: { fontWeight: "semibold" }
});
const ErrorBoundaryContext = reactExports.createContext(null);
const initialState = {
  didCatch: false,
  error: null
};
class ErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: true,
      error
    };
  }
  resetErrorBoundary() {
    const {
      error
    } = this.state;
    if (error !== null) {
      var _this$props$onReset, _this$props;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback: fallback2
    } = this.props;
    const {
      didCatch,
      error
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = reactExports.createElement(FallbackComponent, props);
      } else if (fallback2 !== void 0) {
        childToRender = fallback2;
      } else {
        throw error;
      }
    }
    return reactExports.createElement(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
}
function hasArrayChanged() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let b2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a.length !== b2.length || a.some((item2, index) => !Object.is(item2, b2[index]));
}
const RefreshContext = reactExports.createContext({
  // Re-render without invalidating our cached server function calls.
  rerenderCount: 0,
  // Re-render and go back to the server on everything.
  hardRefreshCount: 0,
  triggerHardRefresh: () => {
  }
});
const PWD_RE = /pwd:\s+"([0-9a-f]+)"/m;
let lastHash = null;
function getHashIfAvailable() {
  var _a2, _b2, _c2, _d2, _e2;
  if (lastHash)
    return lastHash;
  const current = (_e2 = (_d2 = (_c2 = (_b2 = (_a2 = window.parent.frames.mainpane) == null ? void 0 : _a2.document) == null ? void 0 : _b2.body) == null ? void 0 : _c2.innerHTML) == null ? void 0 : _d2.match(PWD_RE)) == null ? void 0 : _e2[1];
  if (current !== void 0) {
    lastHash = current;
  }
  return lastHash ?? "";
}
async function updateHashFromServer() {
  const response = await fetch("/api.php?what=status&for=tome-kolmafia");
  const apiObject = await response.json();
  const newHash = (apiObject == null ? void 0 : apiObject.pwd) ?? null;
  lastHash = newHash;
}
async function getHash() {
  const attempt = getHashIfAvailable();
  if (attempt === "") {
    await updateHashFromServer();
    return lastHash ?? "";
  } else {
    return attempt;
  }
}
let outstandingIdentifier = 0;
const outstandingCalls = /* @__PURE__ */ new Set();
const uniqueCalls = /* @__PURE__ */ new Map();
let globalErrorHandler = (error) => console.error(error);
function setGlobalErrorHandler(handler) {
  globalErrorHandler = handler;
}
async function apiCall(request, pwd = null, retry = true) {
  const identifier2 = outstandingIdentifier;
  outstandingIdentifier++;
  outstandingCalls.add(identifier2);
  for (const { name, args } of request.functions ?? []) {
    const key = `${name}(${JSON.stringify(args)})`;
    uniqueCalls.set(key, 1 + (uniqueCalls.get(key) ?? 0));
  }
  try {
    const response = await fetch("/KoLmafia/jsonApi", {
      method: "post",
      body: new URLSearchParams({
        body: JSON.stringify(request),
        pwd: pwd ?? getHashIfAvailable()
      }),
      headers: {
        // Mafia only accepts this format.
        "Content-Type": "application/x-www-form-urlencoded"
      }
    });
    if ([401, 500].includes(response.status) && retry) {
      await updateHashFromServer();
      return apiCall(request, getHashIfAvailable(), false);
    }
    if (response.status === 503 && retry) {
      const mainResponse = await fetch("/main.php");
      if (mainResponse.status < 400) {
        return apiCall(request, getHashIfAvailable(), false);
      }
    }
    const json = await response.json();
    if ("error" in json) {
      globalErrorHandler(json.error);
      return;
    }
    return json;
  } catch (error) {
    globalErrorHandler(error);
    return;
  } finally {
    outstandingCalls.delete(identifier2);
  }
}
async function batchFunction(functions) {
  const map = functions.map(({ name, args }) => name === "getProperty" && args.length === 1 && typeof args[0] === "string" ? "P" : "F");
  const apiFunctions = functions.filter((_, index) => map[index] === "F");
  const properties2 = functions.filter((_, index) => map[index] === "P").map(({ args }) => args[0]);
  const result = await apiCall({
    properties: properties2,
    functions: apiFunctions
  }, await getHash());
  if (!(result == null ? void 0 : result.functions) || !(result == null ? void 0 : result.properties)) {
    throw new Error(result && "error" in result && typeof result.error === "string" ? result.error : "No functions property in response.");
  } else if (result.functions.length !== apiFunctions.length) {
    throw new Error("Mismatched functions response.");
  } else if (result.properties.length !== properties2.length) {
    throw new Error("Mismatched properties result.");
  }
  const outFunctions = [];
  let functionsIdx = 0;
  let propertiesIdx = 0;
  for (let i = 0; i < map.length; i++) {
    if (map[i] === "P") {
      outFunctions.push(result.properties[propertiesIdx++]);
    } else if (map[i] === "F") {
      outFunctions.push(result.functions[functionsIdx++]);
    }
  }
  return outFunctions;
}
var DataLoader = /* @__PURE__ */ function() {
  function DataLoader2(batchLoadFn, options) {
    if (typeof batchLoadFn !== "function") {
      throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
    }
    this._batchLoadFn = batchLoadFn;
    this._maxBatchSize = getValidMaxBatchSize(options);
    this._batchScheduleFn = getValidBatchScheduleFn(options);
    this._cacheKeyFn = getValidCacheKeyFn(options);
    this._cacheMap = getValidCacheMap(options);
    this._batch = null;
    this.name = getValidName(options);
  }
  var _proto = DataLoader2.prototype;
  _proto.load = function load(key) {
    if (key === null || key === void 0) {
      throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
    }
    var batch = getCurrentBatch(this);
    var cacheMap = this._cacheMap;
    var cacheKey = this._cacheKeyFn(key);
    if (cacheMap) {
      var cachedPromise = cacheMap.get(cacheKey);
      if (cachedPromise) {
        var cacheHits = batch.cacheHits || (batch.cacheHits = []);
        return new Promise(function(resolve) {
          cacheHits.push(function() {
            resolve(cachedPromise);
          });
        });
      }
    }
    batch.keys.push(key);
    var promise = new Promise(function(resolve, reject) {
      batch.callbacks.push({
        resolve,
        reject
      });
    });
    if (cacheMap) {
      cacheMap.set(cacheKey, promise);
    }
    return promise;
  };
  _proto.loadMany = function loadMany(keys) {
    if (!isArrayLike(keys)) {
      throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
    }
    var loadPromises = [];
    for (var i = 0; i < keys.length; i++) {
      loadPromises.push(this.load(keys[i])["catch"](function(error) {
        return error;
      }));
    }
    return Promise.all(loadPromises);
  };
  _proto.clear = function clear2(key) {
    var cacheMap = this._cacheMap;
    if (cacheMap) {
      var cacheKey = this._cacheKeyFn(key);
      cacheMap["delete"](cacheKey);
    }
    return this;
  };
  _proto.clearAll = function clearAll() {
    var cacheMap = this._cacheMap;
    if (cacheMap) {
      cacheMap.clear();
    }
    return this;
  };
  _proto.prime = function prime(key, value) {
    var cacheMap = this._cacheMap;
    if (cacheMap) {
      var cacheKey = this._cacheKeyFn(key);
      if (cacheMap.get(cacheKey) === void 0) {
        var promise;
        if (value instanceof Error) {
          promise = Promise.reject(value);
          promise["catch"](function() {
          });
        } else {
          promise = Promise.resolve(value);
        }
        cacheMap.set(cacheKey, promise);
      }
    }
    return this;
  };
  return DataLoader2;
}();
var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
  if (!resolvedPromise) {
    resolvedPromise = Promise.resolve();
  }
  resolvedPromise.then(function() {
    process.nextTick(fn);
  });
} : typeof setImmediate === "function" ? function(fn) {
  setImmediate(fn);
} : function(fn) {
  setTimeout(fn);
};
var resolvedPromise;
function getCurrentBatch(loader) {
  var existingBatch = loader._batch;
  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
    return existingBatch;
  }
  var newBatch = {
    hasDispatched: false,
    keys: [],
    callbacks: []
  };
  loader._batch = newBatch;
  loader._batchScheduleFn(function() {
    dispatchBatch(loader, newBatch);
  });
  return newBatch;
}
function dispatchBatch(loader, batch) {
  batch.hasDispatched = true;
  if (batch.keys.length === 0) {
    resolveCacheHits(batch);
    return;
  }
  var batchPromise;
  try {
    batchPromise = loader._batchLoadFn(batch.keys);
  } catch (e2) {
    return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e2) + ".")));
  }
  if (!batchPromise || typeof batchPromise.then !== "function") {
    return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
  }
  batchPromise.then(function(values) {
    if (!isArrayLike(values)) {
      throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
    }
    if (values.length !== batch.keys.length) {
      throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
    }
    resolveCacheHits(batch);
    for (var i = 0; i < batch.callbacks.length; i++) {
      var value = values[i];
      if (value instanceof Error) {
        batch.callbacks[i].reject(value);
      } else {
        batch.callbacks[i].resolve(value);
      }
    }
  })["catch"](function(error) {
    failedDispatch(loader, batch, error);
  });
}
function failedDispatch(loader, batch, error) {
  resolveCacheHits(batch);
  for (var i = 0; i < batch.keys.length; i++) {
    loader.clear(batch.keys[i]);
    batch.callbacks[i].reject(error);
  }
}
function resolveCacheHits(batch) {
  if (batch.cacheHits) {
    for (var i = 0; i < batch.cacheHits.length; i++) {
      batch.cacheHits[i]();
    }
  }
}
function getValidMaxBatchSize(options) {
  var shouldBatch = !options || options.batch !== false;
  if (!shouldBatch) {
    return 1;
  }
  var maxBatchSize = options && options.maxBatchSize;
  if (maxBatchSize === void 0) {
    return Infinity;
  }
  if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
    throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
  }
  return maxBatchSize;
}
function getValidBatchScheduleFn(options) {
  var batchScheduleFn = options && options.batchScheduleFn;
  if (batchScheduleFn === void 0) {
    return enqueuePostPromiseJob;
  }
  if (typeof batchScheduleFn !== "function") {
    throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
  }
  return batchScheduleFn;
}
function getValidCacheKeyFn(options) {
  var cacheKeyFn = options && options.cacheKeyFn;
  if (cacheKeyFn === void 0) {
    return function(key) {
      return key;
    };
  }
  if (typeof cacheKeyFn !== "function") {
    throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
  }
  return cacheKeyFn;
}
function getValidCacheMap(options) {
  var shouldCache = !options || options.cache !== false;
  if (!shouldCache) {
    return null;
  }
  var cacheMap = options && options.cacheMap;
  if (cacheMap === void 0) {
    return /* @__PURE__ */ new Map();
  }
  if (cacheMap !== null) {
    var cacheFunctions = ["get", "set", "delete", "clear"];
    var missingFunctions = cacheFunctions.filter(function(fnName) {
      return cacheMap && typeof cacheMap[fnName] !== "function";
    });
    if (missingFunctions.length !== 0) {
      throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
    }
  }
  return cacheMap;
}
function getValidName(options) {
  if (options && options.name) {
    return options.name;
  }
  return null;
}
function isArrayLike(x2) {
  return typeof x2 === "object" && x2 !== null && typeof x2.length === "number" && (x2.length === 0 || x2.length > 0 && Object.prototype.hasOwnProperty.call(x2, x2.length - 1));
}
var dataloader = DataLoader;
const DataLoader$1 = /* @__PURE__ */ getDefaultExportFromCjs(dataloader);
const enumeratedTypePlural = {
  Bounty: "bounties",
  Class: "classes",
  Coinmaster: "coinmasters",
  Effect: "effects",
  Element: "elements",
  Familiar: "familiars",
  Item: "items",
  Location: "locations",
  Modifier: "modifiers",
  Monster: "monsters",
  Path: "paths",
  Phylum: "phyla",
  Servant: "servants",
  Skill: "skills",
  Slot: "slot",
  Stat: "stat",
  Thrall: "thralls",
  Vykea: "vykea"
};
function isEnumeratedTypeName(name) {
  return name in enumeratedTypePlural;
}
const numberTypeNames = [
  "Class",
  "Effect",
  "Familiar",
  "Item",
  "Location",
  "Monster",
  "Path",
  "Servant",
  "Skill",
  "Thrall"
];
function isNumberTypeName(name) {
  return numberTypeNames.includes(name);
}
function isIdentified(o) {
  if (typeof o !== "object" || o === null)
    return false;
  return "objectType" in o && typeof o.objectType === "string" && isEnumeratedTypeName(o.objectType) && "identifierString" in o && typeof o.identifierString === "string" && (!isNumberTypeName(o.objectType) || "identifierNumber" in o && typeof o.identifierNumber === "number");
}
function makePlaceholder(objectType, identifier2) {
  return {
    objectType,
    [typeof identifier2 === "number" ? "identifierNumber" : "identifierString"]: identifier2
  };
}
function isPlaceholder(o) {
  if (typeof o !== "object" || o === null)
    return false;
  return "objectType" in o && typeof o.objectType === "string" && (isNumberTypeName(o.objectType) ? "identifierNumber" in o && typeof o.identifierNumber === "number" || "identifierString" in o && typeof o.identifierString === "string" : "identifierString" in o && typeof o.identifierString === "string");
}
function isNumberPlaceholder(o) {
  return isPlaceholder(o) && isNumberTypeName(o.objectType);
}
let remoteCallFunction = (name, args, default_) => {
  return default_;
};
function setRemoteCallFunction(remoteCall2) {
  remoteCallFunction = remoteCall2;
}
class MafiaClass {
  constructor(values) {
    __publicField(this, "objectType");
    __publicField(this, "identifierString");
    __publicField(this, "identifierNumber");
    this.objectType = values.objectType;
    this.identifierString = values.identifierString;
    this.identifierNumber = values.identifierNumber;
  }
  toString() {
    return this.identifierString;
  }
  static replaceValues(obj, values) {
    Object.assign(obj, values);
  }
  static get(idOrArray) {
    const ids = Array.isArray(idOrArray) ? idOrArray : [idOrArray];
    const results = ids.map((id2) => {
      if (id2 === "" || id2 === void 0 || id2 === null || typeof id2 === "string" && id2.toLowerCase() === "none") {
        return this.none;
      }
      const placeholder = makePlaceholder(this.staticType, id2);
      const default_ = "identifierNumber" in placeholder ? {
        ...this.none,
        ...placeholder,
        identifierString: `${placeholder.identifierNumber}`
      } : {
        ...this.none,
        ...placeholder,
        identifierNumber: -1
      };
      return remoteCallFunction("identity", [placeholder], default_);
    });
    return Array.isArray(idOrArray) ? results : results[0];
  }
  static all() {
    return [];
  }
}
__publicField(MafiaClass, "staticType");
const _Effect = class _Effect extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Default */
    __publicField(this, "default");
    /**
     * Note */
    __publicField(this, "note");
    /**
     * All */
    __publicField(this, "all");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Descid */
    __publicField(this, "descid");
    /**
     * Candy tier */
    __publicField(this, "candyTier");
    /**
     * Quality */
    __publicField(this, "quality");
    /**
     * Attributes */
    __publicField(this, "attributes");
    /**
     * Song */
    __publicField(this, "song");
    _Effect.replaceValues(this, values);
  }
};
__publicField(_Effect, "staticType", "Effect");
__publicField(_Effect, "none", new _Effect({
  objectType: "Effect",
  identifierString: "none",
  identifierNumber: -1,
  id: 0,
  name: "",
  default: "",
  note: "",
  all: [],
  image: "",
  descid: "",
  candyTier: 0,
  quality: "",
  attributes: "",
  song: false
}));
let Effect = _Effect;
let Element$1 = (_T = class extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Image */
    __publicField(this, "image");
    _T.replaceValues(this, values);
  }
}, __publicField(_T, "staticType", "Element"), __publicField(_T, "none", new _T({
  objectType: "Element",
  identifierString: "none",
  identifierNumber: void 0,
  image: ""
})), _T);
const _Location = class _Location extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Nocombats */
    __publicField(this, "nocombats");
    /**
     * Combat percent */
    __publicField(this, "combatPercent");
    /**
     * Zone */
    __publicField(this, "zone");
    /**
     * Parent */
    __publicField(this, "parent");
    /**
     * Parentdesc */
    __publicField(this, "parentdesc");
    /**
     * Root */
    __publicField(this, "root");
    /**
     * Difficulty level */
    __publicField(this, "difficultyLevel");
    /**
     * Environment */
    __publicField(this, "environment");
    /**
     * Fire level */
    __publicField(this, "fireLevel");
    /**
     * Bounty */
    __publicField(this, "bounty");
    /**
     * Combat queue */
    __publicField(this, "combatQueue");
    /**
     * Noncombat queue */
    __publicField(this, "noncombatQueue");
    /**
     * Turns spent */
    __publicField(this, "turnsSpent");
    /**
     * Last noncombat turns spent */
    __publicField(this, "lastNoncombatTurnsSpent");
    /**
     * Force noncombat */
    __publicField(this, "forceNoncombat");
    /**
     * Kisses */
    __publicField(this, "kisses");
    /**
     * Recommended stat */
    __publicField(this, "recommendedStat");
    /**
     * Poison */
    __publicField(this, "poison");
    /**
     * Water level */
    __publicField(this, "waterLevel");
    /**
     * Wanderers */
    __publicField(this, "wanderers");
    /**
     * Pledge allegiance */
    __publicField(this, "pledgeAllegiance");
    _Location.replaceValues(this, values);
  }
};
__publicField(_Location, "staticType", "Location");
__publicField(_Location, "none", new _Location({
  objectType: "Location",
  identifierString: "none",
  identifierNumber: 0,
  id: 0,
  nocombats: false,
  combatPercent: 0,
  zone: "",
  parent: "",
  parentdesc: "",
  root: "",
  difficultyLevel: "",
  environment: "none",
  fireLevel: 0,
  bounty: {},
  combatQueue: "",
  noncombatQueue: "",
  turnsSpent: 0,
  lastNoncombatTurnsSpent: 0,
  forceNoncombat: 0,
  kisses: 0,
  recommendedStat: 0,
  poison: 0,
  waterLevel: 0,
  wanderers: false,
  pledgeAllegiance: ""
}));
let Location = _Location;
const _Modifier = class _Modifier extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Type */
    __publicField(this, "type");
    _Modifier.replaceValues(this, values);
  }
};
__publicField(_Modifier, "staticType", "Modifier");
__publicField(_Modifier, "none", new _Modifier({
  objectType: "Modifier",
  identifierString: "none",
  identifierNumber: void 0,
  name: "",
  type: "none"
}));
let Modifier = _Modifier;
const _Path = class _Path extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Avatar */
    __publicField(this, "avatar");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Points */
    __publicField(this, "points");
    /**
     * Familiars */
    __publicField(this, "familiars");
    _Path.replaceValues(this, values);
  }
};
__publicField(_Path, "staticType", "Path");
__publicField(_Path, "none", new _Path({
  objectType: "Path",
  identifierString: "none",
  identifierNumber: -1,
  id: 0,
  name: "",
  avatar: false,
  image: "",
  points: 0,
  familiars: false
}));
let Path = _Path;
const _Phylum = class _Phylum extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Image */
    __publicField(this, "image");
    _Phylum.replaceValues(this, values);
  }
};
__publicField(_Phylum, "staticType", "Phylum");
__publicField(_Phylum, "none", new _Phylum({
  objectType: "Phylum",
  identifierString: "none",
  identifierNumber: void 0,
  image: ""
}));
let Phylum = _Phylum;
const _Servant = class _Servant extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Level */
    __publicField(this, "level");
    /**
     * Experience */
    __publicField(this, "experience");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Level1 ability */
    __publicField(this, "level1Ability");
    /**
     * Level7 ability */
    __publicField(this, "level7Ability");
    /**
     * Level14 ability */
    __publicField(this, "level14Ability");
    /**
     * Level21 ability */
    __publicField(this, "level21Ability");
    _Servant.replaceValues(this, values);
  }
};
__publicField(_Servant, "staticType", "Servant");
__publicField(_Servant, "none", new _Servant({
  objectType: "Servant",
  identifierString: "none",
  identifierNumber: -1,
  id: 0,
  name: "",
  level: 0,
  experience: 0,
  image: "",
  level1Ability: "",
  level7Ability: "",
  level14Ability: "",
  level21Ability: ""
}));
let Servant = _Servant;
const _Slot = class _Slot extends MafiaClass {
  constructor(values) {
    super(values);
    _Slot.replaceValues(this, values);
  }
};
__publicField(_Slot, "staticType", "Slot");
__publicField(_Slot, "none", new _Slot({
  objectType: "Slot",
  identifierString: "none",
  identifierNumber: void 0
}));
let Slot = _Slot;
const _Stat = class _Stat extends MafiaClass {
  constructor(values) {
    super(values);
    _Stat.replaceValues(this, values);
  }
};
__publicField(_Stat, "staticType", "Stat");
__publicField(_Stat, "none", new _Stat({
  objectType: "Stat",
  identifierString: "none",
  identifierNumber: void 0
}));
let Stat = _Stat;
const _Class = class _Class extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Primestat */
    __publicField(this, "primestat");
    /**
     * Path */
    __publicField(this, "path");
    _Class.replaceValues(this, values);
  }
};
__publicField(_Class, "staticType", "Class");
__publicField(_Class, "none", new _Class({
  objectType: "Class",
  identifierString: "none",
  identifierNumber: -1,
  id: 0,
  primestat: Stat.none,
  path: Path.none
}));
let Class = _Class;
const _Monster = class _Monster extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Article */
    __publicField(this, "article");
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Base hp */
    __publicField(this, "baseHp");
    /**
     * Base attack */
    __publicField(this, "baseAttack");
    /**
     * Base defense */
    __publicField(this, "baseDefense");
    /**
     * Raw hp */
    __publicField(this, "rawHp");
    /**
     * Raw attack */
    __publicField(this, "rawAttack");
    /**
     * Raw defense */
    __publicField(this, "rawDefense");
    /**
     * Base initiative */
    __publicField(this, "baseInitiative");
    /**
     * Raw initiative */
    __publicField(this, "rawInitiative");
    /**
     * Attack element */
    __publicField(this, "attackElement");
    /**
     * Attack elements */
    __publicField(this, "attackElements");
    /**
     * Defense element */
    __publicField(this, "defenseElement");
    /**
     * Physical resistance */
    __publicField(this, "physicalResistance");
    /**
     * Elemental resistance */
    __publicField(this, "elementalResistance");
    /**
     * Min meat */
    __publicField(this, "minMeat");
    /**
     * Max meat */
    __publicField(this, "maxMeat");
    /**
     * Min sprinkles */
    __publicField(this, "minSprinkles");
    /**
     * Max sprinkles */
    __publicField(this, "maxSprinkles");
    /**
     * Base mainstat exp */
    __publicField(this, "baseMainstatExp");
    /**
     * Group */
    __publicField(this, "group");
    /**
     * Phylum */
    __publicField(this, "phylum");
    /**
     * Poison */
    __publicField(this, "poison");
    /**
     * Boss */
    __publicField(this, "boss");
    /**
     * Copyable */
    __publicField(this, "copyable");
    /**
     * Wishable */
    __publicField(this, "wishable");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Images */
    __publicField(this, "images");
    /**
     * Sub types */
    __publicField(this, "subTypes");
    /**
     * Random modifiers */
    __publicField(this, "randomModifiers");
    /**
     * Manuel name */
    __publicField(this, "manuelName");
    /**
     * Wiki name */
    __publicField(this, "wikiName");
    /**
     * Attributes */
    __publicField(this, "attributes");
    /**
     * Fact type */
    __publicField(this, "factType");
    /**
     * Fact */
    __publicField(this, "fact");
    /**
     * Parts */
    __publicField(this, "parts");
    _Monster.replaceValues(this, values);
  }
};
__publicField(_Monster, "staticType", "Monster");
__publicField(_Monster, "none", new _Monster({
  objectType: "Monster",
  identifierString: "none",
  identifierNumber: 0,
  name: "",
  article: "",
  id: 0,
  baseHp: 0,
  baseAttack: 0,
  baseDefense: 0,
  rawHp: 0,
  rawAttack: 0,
  rawDefense: 0,
  baseInitiative: 0,
  rawInitiative: 0,
  attackElement: Element$1.none,
  attackElements: [],
  defenseElement: Element$1.none,
  physicalResistance: 0,
  elementalResistance: 0,
  minMeat: 0,
  maxMeat: 0,
  minSprinkles: 0,
  maxSprinkles: 0,
  baseMainstatExp: 0,
  group: 0,
  phylum: Phylum.none,
  poison: Effect.none,
  boss: false,
  copyable: false,
  wishable: false,
  image: "",
  images: [],
  subTypes: [],
  randomModifiers: [],
  manuelName: "",
  wikiName: "",
  attributes: "",
  factType: "",
  fact: "",
  parts: []
}));
let Monster = _Monster;
const _Bounty = class _Bounty extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Plural */
    __publicField(this, "plural");
    /**
     * Type */
    __publicField(this, "type");
    /**
     * Kol internal type */
    __publicField(this, "kolInternalType");
    /**
     * Number */
    __publicField(this, "number");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Monster */
    __publicField(this, "monster");
    /**
     * Location */
    __publicField(this, "location");
    _Bounty.replaceValues(this, values);
  }
};
__publicField(_Bounty, "staticType", "Bounty");
__publicField(_Bounty, "none", new _Bounty({
  objectType: "Bounty",
  identifierString: "none",
  identifierNumber: void 0,
  plural: "",
  type: "",
  kolInternalType: "",
  number: 0,
  image: "",
  monster: Monster.none,
  location: Location.none
}));
let Bounty = _Bounty;
const _Skill = class _Skill extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Type */
    __publicField(this, "type");
    /**
     * Level */
    __publicField(this, "level");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Traincost */
    __publicField(this, "traincost");
    /**
     * Class */
    __publicField(this, "class");
    /**
     * Libram */
    __publicField(this, "libram");
    /**
     * Passive */
    __publicField(this, "passive");
    /**
     * Buff */
    __publicField(this, "buff");
    /**
     * Combat */
    __publicField(this, "combat");
    /**
     * Song */
    __publicField(this, "song");
    /**
     * Expression */
    __publicField(this, "expression");
    /**
     * Walk */
    __publicField(this, "walk");
    /**
     * Summon */
    __publicField(this, "summon");
    /**
     * Permable */
    __publicField(this, "permable");
    /**
     * Dailylimit */
    __publicField(this, "dailylimit");
    /**
     * Dailylimitpref */
    __publicField(this, "dailylimitpref");
    /**
     * Timescast */
    __publicField(this, "timescast");
    _Skill.replaceValues(this, values);
  }
};
__publicField(_Skill, "staticType", "Skill");
__publicField(_Skill, "none", new _Skill({
  objectType: "Skill",
  identifierString: "none",
  identifierNumber: -1,
  id: 0,
  name: "",
  type: "",
  level: 0,
  image: "",
  traincost: 0,
  class: Class.none,
  libram: false,
  passive: false,
  buff: false,
  combat: false,
  song: false,
  expression: false,
  walk: false,
  summon: false,
  permable: false,
  dailylimit: 0,
  dailylimitpref: "",
  timescast: 0
}));
let Skill = _Skill;
const _Item = class _Item extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Plural */
    __publicField(this, "plural");
    /**
     * Descid */
    __publicField(this, "descid");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Smallimage */
    __publicField(this, "smallimage");
    /**
     * Levelreq */
    __publicField(this, "levelreq");
    /**
     * Quality */
    __publicField(this, "quality");
    /**
     * Adventures */
    __publicField(this, "adventures");
    /**
     * Muscle */
    __publicField(this, "muscle");
    /**
     * Mysticality */
    __publicField(this, "mysticality");
    /**
     * Moxie */
    __publicField(this, "moxie");
    /**
     * Fullness */
    __publicField(this, "fullness");
    /**
     * Inebriety */
    __publicField(this, "inebriety");
    /**
     * Spleen */
    __publicField(this, "spleen");
    /**
     * Minhp */
    __publicField(this, "minhp");
    /**
     * Maxhp */
    __publicField(this, "maxhp");
    /**
     * Minmp */
    __publicField(this, "minmp");
    /**
     * Maxmp */
    __publicField(this, "maxmp");
    /**
     * Dailyusesleft */
    __publicField(this, "dailyusesleft");
    /**
     * Notes */
    __publicField(this, "notes");
    /**
     * Quest */
    __publicField(this, "quest");
    /**
     * Gift */
    __publicField(this, "gift");
    /**
     * Tradeable */
    __publicField(this, "tradeable");
    /**
     * Discardable */
    __publicField(this, "discardable");
    /**
     * Combat */
    __publicField(this, "combat");
    /**
     * Combat reusable */
    __publicField(this, "combatReusable");
    /**
     * Usable */
    __publicField(this, "usable");
    /**
     * Reusable */
    __publicField(this, "reusable");
    /**
     * Multi */
    __publicField(this, "multi");
    /**
     * Fancy */
    __publicField(this, "fancy");
    /**
     * Pasteable */
    __publicField(this, "pasteable");
    /**
     * Smithable */
    __publicField(this, "smithable");
    /**
     * Cookable */
    __publicField(this, "cookable");
    /**
     * Mixable */
    __publicField(this, "mixable");
    /**
     * Candy */
    __publicField(this, "candy");
    /**
     * Candy type */
    __publicField(this, "candyType");
    /**
     * Chocolate */
    __publicField(this, "chocolate");
    /**
     * Potion */
    __publicField(this, "potion");
    /**
     * Seller */
    __publicField(this, "seller");
    /**
     * Buyer */
    __publicField(this, "buyer");
    /**
     * Name length */
    __publicField(this, "nameLength");
    /**
     * Noob skill */
    __publicField(this, "noobSkill");
    /**
     * Tcrs name */
    __publicField(this, "tcrsName");
    /**
     * Skill */
    __publicField(this, "skill");
    /**
     * Recipe */
    __publicField(this, "recipe");
    _Item.replaceValues(this, values);
  }
};
__publicField(_Item, "staticType", "Item");
__publicField(_Item, "none", new _Item({
  objectType: "Item",
  identifierString: "none",
  identifierNumber: -1,
  id: 0,
  name: "",
  plural: "",
  descid: "",
  image: "",
  smallimage: "",
  levelreq: 0,
  quality: "",
  adventures: "",
  muscle: "",
  mysticality: "",
  moxie: "",
  fullness: 0,
  inebriety: 0,
  spleen: 0,
  minhp: 0,
  maxhp: 0,
  minmp: 0,
  maxmp: 0,
  dailyusesleft: 0,
  notes: "",
  quest: false,
  gift: false,
  tradeable: false,
  discardable: false,
  combat: false,
  combatReusable: false,
  usable: false,
  reusable: false,
  multi: false,
  fancy: false,
  pasteable: false,
  smithable: false,
  cookable: false,
  mixable: false,
  candy: false,
  candyType: "",
  chocolate: false,
  potion: false,
  seller: {},
  buyer: {},
  nameLength: 0,
  noobSkill: Skill.none,
  tcrsName: "",
  skill: Skill.none,
  recipe: {}
}));
let Item = _Item;
const _Thrall = class _Thrall extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Level */
    __publicField(this, "level");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Tinyimage */
    __publicField(this, "tinyimage");
    /**
     * Skill */
    __publicField(this, "skill");
    /**
     * Current modifiers */
    __publicField(this, "currentModifiers");
    _Thrall.replaceValues(this, values);
  }
};
__publicField(_Thrall, "staticType", "Thrall");
__publicField(_Thrall, "none", new _Thrall({
  objectType: "Thrall",
  identifierString: "none",
  identifierNumber: -1,
  id: 0,
  name: "",
  level: 0,
  image: "",
  tinyimage: "",
  skill: Skill.none,
  currentModifiers: ""
}));
let Thrall = _Thrall;
const _Coinmaster = class _Coinmaster extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Token */
    __publicField(this, "token");
    /**
     * Item */
    __publicField(this, "item");
    /**
     * Property */
    __publicField(this, "property");
    /**
     * Available tokens */
    __publicField(this, "availableTokens");
    /**
     * Buys */
    __publicField(this, "buys");
    /**
     * Sells */
    __publicField(this, "sells");
    /**
     * Nickname */
    __publicField(this, "nickname");
    /**
     * Shopid */
    __publicField(this, "shopid");
    _Coinmaster.replaceValues(this, values);
  }
};
__publicField(_Coinmaster, "staticType", "Coinmaster");
__publicField(_Coinmaster, "none", new _Coinmaster({
  objectType: "Coinmaster",
  identifierString: "none",
  identifierNumber: void 0,
  token: "",
  item: Item.none,
  property: "",
  availableTokens: 0,
  buys: false,
  sells: false,
  nickname: "",
  shopid: ""
}));
let Coinmaster = _Coinmaster;
const _Familiar = class _Familiar extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Hatchling */
    __publicField(this, "hatchling");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Owner */
    __publicField(this, "owner");
    /**
     * Owner id */
    __publicField(this, "ownerId");
    /**
     * Experience */
    __publicField(this, "experience");
    /**
     * Charges */
    __publicField(this, "charges");
    /**
     * Drop name */
    __publicField(this, "dropName");
    /**
     * Drop item */
    __publicField(this, "dropItem");
    /**
     * Drops today */
    __publicField(this, "dropsToday");
    /**
     * Drops limit */
    __publicField(this, "dropsLimit");
    /**
     * Fights today */
    __publicField(this, "fightsToday");
    /**
     * Fights limit */
    __publicField(this, "fightsLimit");
    /**
     * Combat */
    __publicField(this, "combat");
    /**
     * Physical damage */
    __publicField(this, "physicalDamage");
    /**
     * Elemental damage */
    __publicField(this, "elementalDamage");
    /**
     * Block */
    __publicField(this, "block");
    /**
     * Delevel */
    __publicField(this, "delevel");
    /**
     * Hp during combat */
    __publicField(this, "hpDuringCombat");
    /**
     * Mp during combat */
    __publicField(this, "mpDuringCombat");
    /**
     * Other action during combat */
    __publicField(this, "otherActionDuringCombat");
    /**
     * Hp after combat */
    __publicField(this, "hpAfterCombat");
    /**
     * Mp after combat */
    __publicField(this, "mpAfterCombat");
    /**
     * Other action after combat */
    __publicField(this, "otherActionAfterCombat");
    /**
     * Passive */
    __publicField(this, "passive");
    /**
     * Underwater */
    __publicField(this, "underwater");
    /**
     * Variable */
    __publicField(this, "variable");
    /**
     * Feasted */
    __publicField(this, "feasted");
    /**
     * Attributes */
    __publicField(this, "attributes");
    /**
     * Poke level */
    __publicField(this, "pokeLevel");
    /**
     * Poke level 2 power */
    __publicField(this, "pokeLevel2Power");
    /**
     * Poke level 2 hp */
    __publicField(this, "pokeLevel2Hp");
    /**
     * Poke level 3 power */
    __publicField(this, "pokeLevel3Power");
    /**
     * Poke level 3 hp */
    __publicField(this, "pokeLevel3Hp");
    /**
     * Poke level 4 power */
    __publicField(this, "pokeLevel4Power");
    /**
     * Poke level 4 hp */
    __publicField(this, "pokeLevel4Hp");
    /**
     * Poke move 1 */
    __publicField(this, "pokeMove1");
    /**
     * Poke move 2 */
    __publicField(this, "pokeMove2");
    /**
     * Poke move 3 */
    __publicField(this, "pokeMove3");
    /**
     * Poke attribute */
    __publicField(this, "pokeAttribute");
    /**
     * Soup weight */
    __publicField(this, "soupWeight");
    /**
     * Soup attributes */
    __publicField(this, "soupAttributes");
    _Familiar.replaceValues(this, values);
  }
};
__publicField(_Familiar, "staticType", "Familiar");
__publicField(_Familiar, "none", new _Familiar({
  objectType: "Familiar",
  identifierString: "none",
  identifierNumber: -1,
  id: 0,
  hatchling: Item.none,
  image: "",
  name: "",
  owner: "",
  ownerId: 0,
  experience: 0,
  charges: 0,
  dropName: "",
  dropItem: Item.none,
  dropsToday: 0,
  dropsLimit: 0,
  fightsToday: 0,
  fightsLimit: 0,
  combat: false,
  physicalDamage: false,
  elementalDamage: false,
  block: false,
  delevel: false,
  hpDuringCombat: false,
  mpDuringCombat: false,
  otherActionDuringCombat: false,
  hpAfterCombat: false,
  mpAfterCombat: false,
  otherActionAfterCombat: false,
  passive: false,
  underwater: false,
  variable: false,
  feasted: false,
  attributes: "",
  pokeLevel: 0,
  pokeLevel2Power: 0,
  pokeLevel2Hp: 0,
  pokeLevel3Power: 0,
  pokeLevel3Hp: 0,
  pokeLevel4Power: 0,
  pokeLevel4Hp: 0,
  pokeMove1: "",
  pokeMove2: "",
  pokeMove3: "",
  pokeAttribute: "",
  soupWeight: 0,
  soupAttributes: []
}));
let Familiar = _Familiar;
const _Vykea = class _Vykea extends MafiaClass {
  constructor(values) {
    super(values);
    /**
     * Id */
    __publicField(this, "id");
    /**
     * Name */
    __publicField(this, "name");
    /**
     * Type */
    __publicField(this, "type");
    /**
     * Rune */
    __publicField(this, "rune");
    /**
     * Level */
    __publicField(this, "level");
    /**
     * Image */
    __publicField(this, "image");
    /**
     * Modifiers */
    __publicField(this, "modifiers");
    /**
     * Attack element */
    __publicField(this, "attackElement");
    _Vykea.replaceValues(this, values);
  }
};
__publicField(_Vykea, "staticType", "Vykea");
__publicField(_Vykea, "none", new _Vykea({
  objectType: "Vykea",
  identifierString: "none",
  identifierNumber: void 0,
  id: 0,
  name: "",
  type: 0,
  rune: Item.none,
  level: 0,
  image: "",
  modifiers: "",
  attackElement: Element$1.none
}));
let Vykea = _Vykea;
const enumeratedTypes = {
  Bounty,
  Class,
  Coinmaster,
  Effect,
  Element: Element$1,
  Familiar,
  Item,
  Location,
  Modifier,
  Monster,
  Path,
  Phylum,
  Servant,
  Skill,
  Slot,
  Stat,
  Thrall,
  Vykea
};
function abort(...args) {
  throw remoteCallFunction("abort", args, void 0);
}
function appearanceRates(...args) {
  return remoteCallFunction("appearanceRates", args, {});
}
function availableAmount(...args) {
  return remoteCallFunction("availableAmount", args, 0);
}
function booleanModifier(...args) {
  return remoteCallFunction("booleanModifier", args, false);
}
function canAdventure(...args) {
  return remoteCallFunction("canAdventure", args, false);
}
function canEquip(...args) {
  return remoteCallFunction("canEquip", args, false);
}
function canInteract(...args) {
  return remoteCallFunction("canInteract", args, false);
}
function combatRateModifier(...args) {
  return remoteCallFunction("combatRateModifier", args, 0);
}
function effectModifier(...args) {
  return remoteCallFunction("effectModifier", args, Effect.none);
}
function elementalResistance(...args) {
  return remoteCallFunction("elementalResistance", args, 0);
}
function equippedAmount(...args) {
  return remoteCallFunction("equippedAmount", args, 0);
}
function equippedItem(...args) {
  return remoteCallFunction("equippedItem", args, Item.none);
}
function familiarEquippedEquipment(...args) {
  return remoteCallFunction("familiarEquippedEquipment", args, Item.none);
}
function familiarWeight(...args) {
  return remoteCallFunction("familiarWeight", args, 0);
}
function fullnessLimit(...args) {
  return remoteCallFunction("fullnessLimit", args, 0);
}
function getCampground(...args) {
  return remoteCallFunction("getCampground", args, {});
}
function getClanName(...args) {
  return remoteCallFunction("getClanName", args, "");
}
function getCounter(...args) {
  return remoteCallFunction("getCounter", args, 0);
}
function getDwelling(...args) {
  return remoteCallFunction("getDwelling", args, Item.none);
}
function getFuel(...args) {
  return remoteCallFunction("getFuel", args, 0);
}
function getIngredients(...args) {
  return remoteCallFunction("getIngredients", args, {});
}
function getMonsters(...args) {
  return remoteCallFunction("getMonsters", args, []);
}
function getProperty(...args) {
  return remoteCallFunction("getProperty", args, "");
}
function getWorkshed(...args) {
  return remoteCallFunction("getWorkshed", args, Item.none);
}
function haveEffect(...args) {
  return remoteCallFunction("haveEffect", args, 0);
}
function haveEquipped(...args) {
  return remoteCallFunction("haveEquipped", args, false);
}
function haveFamiliar(...args) {
  return remoteCallFunction("haveFamiliar", args, false);
}
function haveOutfit(...args) {
  return remoteCallFunction("haveOutfit", args, false);
}
function haveServant(...args) {
  return remoteCallFunction("haveServant", args, false);
}
function haveSkill(...args) {
  return remoteCallFunction("haveSkill", args, false);
}
function hiddenTempleUnlocked(...args) {
  return remoteCallFunction("hiddenTempleUnlocked", args, false);
}
function holiday(...args) {
  return remoteCallFunction("holiday", args, "");
}
function inBadMoon(...args) {
  return remoteCallFunction("inBadMoon", args, false);
}
function inHardcore(...args) {
  return remoteCallFunction("inHardcore", args, false);
}
function inebrietyLimit(...args) {
  return remoteCallFunction("inebrietyLimit", args, 0);
}
function initiativeModifier(...args) {
  return remoteCallFunction("initiativeModifier", args, 0);
}
function isBanished(...args) {
  return remoteCallFunction("isBanished", args, false);
}
function isUnrestricted(...args) {
  return remoteCallFunction("isUnrestricted", args, false);
}
function isWearingOutfit(...args) {
  return remoteCallFunction("isWearingOutfit", args, false);
}
function itemAmount(...args) {
  return remoteCallFunction("itemAmount", args, 0);
}
function itemDropModifier(...args) {
  return remoteCallFunction("itemDropModifier", args, 0);
}
function itemDropsArray(...args) {
  return remoteCallFunction("itemDropsArray", args, []);
}
function itemType(...args) {
  return remoteCallFunction("itemType", args, "");
}
function meatDropModifier(...args) {
  return remoteCallFunction("meatDropModifier", args, 0);
}
function monsterLevelAdjustment(...args) {
  return remoteCallFunction("monsterLevelAdjustment", args, 0);
}
function mpCost(...args) {
  return remoteCallFunction("mpCost", args, 0);
}
function myAdventures(...args) {
  return remoteCallFunction("myAdventures", args, 0);
}
function myAscensions(...args) {
  return remoteCallFunction("myAscensions", args, 0);
}
function myBasestat(...args) {
  return remoteCallFunction("myBasestat", args, 0);
}
function myBuffedstat(...args) {
  return remoteCallFunction("myBuffedstat", args, 0);
}
function myClass(...args) {
  return remoteCallFunction("myClass", args, Class.none);
}
function myDaycount(...args) {
  return remoteCallFunction("myDaycount", args, 0);
}
function myFamiliar(...args) {
  return remoteCallFunction("myFamiliar", args, Familiar.none);
}
function myFullness(...args) {
  return remoteCallFunction("myFullness", args, 0);
}
function myHash(...args) {
  return remoteCallFunction("myHash", args, "");
}
function myHp(...args) {
  return remoteCallFunction("myHp", args, 0);
}
function myInebriety(...args) {
  return remoteCallFunction("myInebriety", args, 0);
}
function myLevel(...args) {
  return remoteCallFunction("myLevel", args, 0);
}
function myLocation(...args) {
  return remoteCallFunction("myLocation", args, Location.none);
}
function myMaxhp(...args) {
  return remoteCallFunction("myMaxhp", args, 0);
}
function myMeat(...args) {
  return remoteCallFunction("myMeat", args, 0);
}
function myMp(...args) {
  return remoteCallFunction("myMp", args, 0);
}
function myPath(...args) {
  return remoteCallFunction("myPath", args, Path.none);
}
function myPathId(...args) {
  return remoteCallFunction("myPathId", args, 0);
}
function myPrimestat(...args) {
  return remoteCallFunction("myPrimestat", args, Stat.none);
}
function mySign(...args) {
  return remoteCallFunction("mySign", args, "");
}
function mySpleenUse(...args) {
  return remoteCallFunction("mySpleenUse", args, 0);
}
function myThrall(...args) {
  return remoteCallFunction("myThrall", args, Thrall.none);
}
function myTurncount(...args) {
  return remoteCallFunction("myTurncount", args, 0);
}
function npcPrice(...args) {
  return remoteCallFunction("npcPrice", args, 0);
}
function numericModifier(...args) {
  return remoteCallFunction("numericModifier", args, 0);
}
function print(...args) {
  return remoteCallFunction("print", args, void 0);
}
function pullsRemaining(...args) {
  return remoteCallFunction("pullsRemaining", args, 0);
}
function round(...args) {
  return remoteCallFunction("round", args, 0);
}
function spleenLimit(...args) {
  return remoteCallFunction("spleenLimit", args, 0);
}
function storageAmount(...args) {
  return remoteCallFunction("storageAmount", args, 0);
}
function stringModifier(...args) {
  return remoteCallFunction("stringModifier", args, "");
}
function toBounty(...args) {
  return remoteCallFunction("toBounty", args, Bounty.none);
}
function toClass(...args) {
  return remoteCallFunction("toClass", args, Class.none);
}
function toCoinmaster(...args) {
  return remoteCallFunction("toCoinmaster", args, Coinmaster.none);
}
function toEffect(...args) {
  return remoteCallFunction("toEffect", args, Effect.none);
}
function toElement(...args) {
  return remoteCallFunction("toElement", args, Element$1.none);
}
function toFamiliar(...args) {
  return remoteCallFunction("toFamiliar", args, Familiar.none);
}
function toItem(...args) {
  return remoteCallFunction("toItem", args, Item.none);
}
function toLocation(...args) {
  return remoteCallFunction("toLocation", args, Location.none);
}
function toModifier(...args) {
  return remoteCallFunction("toModifier", args, Modifier.none);
}
function toMonster(...args) {
  return remoteCallFunction("toMonster", args, Monster.none);
}
function toPath(...args) {
  return remoteCallFunction("toPath", args, Path.none);
}
function toPhylum(...args) {
  return remoteCallFunction("toPhylum", args, Phylum.none);
}
function toServant(...args) {
  return remoteCallFunction("toServant", args, Servant.none);
}
function toSkill(...args) {
  return remoteCallFunction("toSkill", args, Skill.none);
}
function toSlot(...args) {
  return remoteCallFunction("toSlot", args, Slot.none);
}
function toStat(...args) {
  return remoteCallFunction("toStat", args, Stat.none);
}
function toThrall(...args) {
  return remoteCallFunction("toThrall", args, Thrall.none);
}
function todayToString(...args) {
  return remoteCallFunction("todayToString", args, "");
}
function totalFreeRests(...args) {
  return remoteCallFunction("totalFreeRests", args, 0);
}
function totalTurnsPlayed(...args) {
  return remoteCallFunction("totalTurnsPlayed", args, 0);
}
function trackCopyCount(...args) {
  return remoteCallFunction("trackCopyCount", args, 0);
}
function trackIgnoreQueue(...args) {
  return remoteCallFunction("trackIgnoreQueue", args, false);
}
function weaponHands(...args) {
  return remoteCallFunction("weaponHands", args, 0);
}
function weaponType(...args) {
  return remoteCallFunction("weaponType", args, Stat.none);
}
function weightAdjustment(...args) {
  return remoteCallFunction("weightAdjustment", args, 0);
}
const objectCache = Object.fromEntries(Object.entries(enumeratedTypes).map(([name, type]) => [
  name,
  /* @__PURE__ */ new Map([["none", type.none]])
]));
let uniqueId = 0;
function cacheIdentified(object, updateCachedValue) {
  const { objectType, identifierString } = object;
  const cached = objectCache[objectType].get(identifierString);
  if (cached !== void 0) {
    if (updateCachedValue) {
      Object.assign(cached, object);
    }
    return cached;
  }
  const ClassObject = enumeratedTypes[objectType];
  const result = new ClassObject({ ...ClassObject.none, ...object });
  Object.assign(result, { _unique: uniqueId++ });
  objectCache[objectType].set(identifierString, result);
  return result;
}
function isPOJO(arg) {
  if (arg === null || typeof arg !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(arg);
  return !proto || proto.constructor.name === "Object";
}
function serialize(object) {
  if (typeof object !== "object" || object === null) {
    return object;
  } else if (Array.isArray(object)) {
    return object.map((item2) => serialize(item2));
  } else if (isPlaceholder(object)) {
    if ("identifierString" in object) {
      return {
        objectType: object.objectType,
        identifierString: object.identifierString
      };
    } else if ("identifierNumber" in object) {
      return {
        objectType: object.objectType,
        identifierNumber: object.identifierNumber
      };
    } else {
      throw new Error("Placeholder and no identifier??");
    }
  } else if (isPOJO(object)) {
    return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, serialize(value)]));
  } else
    return object;
}
function singletonize(object, updateCachedValue) {
  if (typeof object !== "object" || object === null) {
    return object;
  } else if (Array.isArray(object)) {
    return object.map((item2) => singletonize(item2, updateCachedValue));
  } else if (isIdentified(object)) {
    return cacheIdentified(object, updateCachedValue);
  } else if (isPOJO(object)) {
    return Object.fromEntries(Object.entries(object).map(([key, value]) => [
      key,
      singletonize(value, updateCachedValue)
    ]));
  } else
    return object;
}
const remoteFunctionsLoader = new DataLoader$1(batchFunction);
let rerenderQueuer = () => {
};
function setRerenderQueuer(queuer) {
  rerenderQueuer = queuer;
}
const cachedFunctionValues = /* @__PURE__ */ new Map();
const dirtyCachedFunctionValues = /* @__PURE__ */ new Set();
const overriddenCachedFunctionValues = /* @__PURE__ */ new Map();
let clearCount = 0;
function markRemoteCallCacheDirty() {
  for (const key of Array.from(cachedFunctionValues.keys())) {
    dirtyCachedFunctionValues.add(key);
  }
  clearCount++;
}
function fetchResult(name, serializedArgs, key) {
  const initialClearCount = clearCount;
  remoteFunctionsLoader.load({ name, args: serializedArgs }).then((value) => {
    value = singletonize(value, true);
    const override = processOverrides(name, serializedArgs, value);
    cachedFunctionValues.set(key, value);
    if (override.applied) {
      overriddenCachedFunctionValues.set(value, override.value);
    }
    if (clearCount === initialClearCount) {
      dirtyCachedFunctionValues.delete(key);
      rerenderQueuer();
    }
  });
}
const overrideListeners = [];
function processOverrides(name, args, value) {
  for (const listener of overrideListeners) {
    const override = listener(name, args, value);
    if (override.applied)
      return override;
  }
  return { applied: false };
}
function remoteCall(name, args, default_, ignoreOverrides = false) {
  if (args.some((arg) => arg === null)) {
    throw new Error("Can't make a remote call with null arguments.");
  }
  const key = JSON.stringify([name, serialize(args)]);
  const firstArg = args[0];
  if (!ignoreOverrides) {
    for (const listener of overrideListeners) {
      const override = listener(name, args);
      if (override.applied)
        return override.value;
    }
  }
  if (name === "toInt" && firstArg !== null && typeof firstArg === "object" && isNumberPlaceholder(firstArg) && "identifierNumber" in firstArg && (firstArg.identifierNumber ?? -1) >= 0) {
    return firstArg.identifierNumber;
  } else if (name === "toString" && firstArg !== null && typeof firstArg === "object" && "identifierString" in firstArg && typeof firstArg.identifierString === "string" && firstArg.identifierString !== "") {
    return firstArg.identifierString;
  }
  let processedDefault = default_;
  if (isIdentified(processedDefault)) {
    processedDefault = singletonize(processedDefault, false);
  }
  let cached = cachedFunctionValues.get(key);
  if (cached === void 0 || dirtyCachedFunctionValues.has(key)) {
    const serializedArgs = serialize(args);
    if (cached === void 0) {
      cached = processedDefault;
      const override = processOverrides(name, serializedArgs, cached);
      cachedFunctionValues.set(key, cached);
      if (override.applied) {
        overriddenCachedFunctionValues.set(cached, override.value);
      }
    } else {
      dirtyCachedFunctionValues.delete(key);
    }
    fetchResult(name, serializedArgs, key);
  }
  if (cached !== void 0 && typeof cached === "object" && !ignoreOverrides) {
    const overrideCached = overriddenCachedFunctionValues.get(cached);
    if (overrideCached !== void 0) {
      return overrideCached;
    }
  }
  return cached;
}
setRemoteCallFunction(remoteCall);
function remoteCliExecute(command) {
  return apiCall({
    functions: [{ name: "cliExecute", args: [command] }]
  }).then((response) => {
    var _a2;
    const result = (_a2 = response == null ? void 0 : response.functions) == null ? void 0 : _a2[0];
    return typeof result === "boolean" ? result : void 0;
  });
}
function useInterval(callback, delay3) {
  const savedCallback = reactExports.useRef(callback);
  reactExports.useLayoutEffect(() => {
    savedCallback.current = callback;
  }, [callback]);
  reactExports.useEffect(() => {
    if (!delay3 && delay3 !== 0) {
      return;
    }
    const id2 = setInterval(() => savedCallback.current(), delay3);
    return () => clearInterval(id2);
  }, [delay3]);
}
function isEqual(a, b2) {
  if (a === null)
    return b2 === null;
  else if (b2 === null)
    return false;
  if (typeof a !== "object")
    return Object.is(a, b2);
  else if (typeof b2 !== "object")
    return false;
  if (Array.isArray(a)) {
    return Array.isArray(b2) && a.length === b2.length && a.every((x2, index) => isEqual(x2, b2[index]));
  } else if (Array.isArray(b2)) {
    return false;
  }
  if (Object.keys(a).length !== Object.keys(b2).length)
    return false;
  for (const [key, value] of Object.entries(a)) {
    if (!(key in b2) || !isEqual(value, b2[key])) {
      return false;
    }
  }
  return true;
}
const NO_REFRESH_URLS = /* @__PURE__ */ new Set([
  "/charpane.php",
  "/inventory.php",
  "/desc_item.php",
  "/desc_effect.php",
  "/desc_skill.php",
  "/desc_familiar.php",
  "/town.php"
]);
const NO_REFRESH_IF_NO_PARAMS_URLS = /* @__PURE__ */ new Set([
  "/woods.php",
  "/main.php",
  "/fernruin.php",
  "/cobbsknob.php",
  "/cyrpt.php",
  "/friars.php",
  "/pandamonium.php",
  "/tutorial.php",
  "/island.php",
  "/bigisland.php",
  "/postwarisland.php",
  "/pyramid.php",
  "/manor3.php",
  "/da.php",
  "/canadia.php",
  "/gnomes.php",
  "/heydeze.php",
  "/dwarffactory.php"
]);
function shouldRefreshOnLoad(urlObject) {
  const url = typeof urlObject === "string" ? new URL(urlObject, window.location.href) : urlObject;
  return !NO_REFRESH_URLS.has(url.pathname) && // Don't refresh on place.php?whichplace=xxxxx
  !(url.pathname === "/place.php" && url.searchParams.size === 1 && url.searchParams.get("whichplace") !== null) && !(NO_REFRESH_IF_NO_PARAMS_URLS.has(url.pathname) && url.searchParams.size === 0);
}
function instrumentXHR(targetName, callback) {
  const target = window.parent.parent.frames[targetName];
  if (!target) {
    console.error(`tome-kolmafia: Failed to instrument XHR in pane ${targetName}!`);
    return;
  }
  if (!("instrumented" in target.XMLHttpRequest && target.XMLHttpRequest.instrumented)) {
    const openOld = target.XMLHttpRequest.prototype.open;
    const openNew = function(method, url, async = true, username, password) {
      if (shouldRefreshOnLoad(url)) {
        this.addEventListener("readystatechange", () => {
          if (this.readyState === target.XMLHttpRequest.DONE) {
            const status = this.status;
            if (status === 0 || status >= 200 && status < 400) {
              callback();
            }
          }
        });
      }
      return openOld.call(this, method, url, async, username, password);
    };
    target.XMLHttpRequest.prototype.open = openNew;
    Object.assign(target.XMLHttpRequest, { instrumented: true });
  }
}
const trackedSlots = [
  "hat",
  "back",
  "shirt",
  "pants",
  "weapon",
  "off-hand",
  "acc1",
  "acc2",
  "acc3",
  "familiar"
];
const properties = [
  "8BitColor",
  "8BitScore",
  "blackForestProgress",
  "breathitinCharges",
  "camelSpit",
  "cosmicBowlingBallReturnCombats",
  "cursedMagnifyingGlassCount",
  "cyrptAlcoveEvilness",
  "cyrptCrannyEvilness",
  "cyrptNicheEvilness",
  "cyrptNookEvilness",
  "noncombatForcerActive",
  "questL02Larva",
  "questL03Rat",
  "questL04Bat",
  "questL05Goblin",
  "questL06Friar",
  "questL07Cyrptic",
  "questL08Trapper",
  "questL09Topping",
  "questL10Garbage",
  "questL11MacGuffin",
  "questL11Manor",
  "questL11Palindome",
  "questL11Pyramid",
  "questL11Worship",
  "questL12War",
  "questL13Final",
  "hiddenApartmentProgress",
  "hiddenBowlingAlleyProgress",
  "hiddenHospitalProgress",
  "hiddenTavernUnlock",
  "noncombatForcerActive",
  "questM05Toot",
  "questM20Necklace",
  "questM21Dance",
  "sidequestArenaCompleted",
  "sidequestFarmCompleted",
  "sidequestJunkyardCompleted",
  "sidequestLighthouseCompleted",
  "sidequestNunsCompleted",
  "sidequestOrchardCompleted"
];
async function getCharacterState() {
  var _a2;
  const functions = [
    { name: "myTurncount", args: [] },
    { name: "myMeat", args: [] },
    { name: "myHp", args: [] },
    { name: "myMp", args: [] },
    { name: "myFamiliar", args: [] },
    { name: "myAdventures", args: [] },
    { name: "myEffects", args: [] },
    ...["Muscle", "Mysticality", "Moxie"].map((stat) => ({
      name: "myBasestat",
      args: [{ objectType: "Stat", identifierString: stat }]
    })),
    ...["inventory", "closet", "storage", "display"].map((collection) => ({
      name: "getItemsHash",
      args: [collection]
    })),
    ...trackedSlots.map((slot) => ({
      name: "equippedItem",
      args: [makePlaceholder("Slot", slot)]
    }))
  ];
  const response = await apiCall({ properties, functions }, await getHash());
  if (!response || !response.functions) {
    throw new Error("API call failed for some reason.");
  }
  return Object.fromEntries((_a2 = response == null ? void 0 : response.functions) == null ? void 0 : _a2.map((result, index) => {
    const { name, args } = functions[index];
    return [JSON.stringify([name, args]), result];
  }));
}
const DEFAULT_CHARACTER_STATE_INTERVAL = 2e3;
let lastCharacterState = null;
const DEFAULT_RERENDER_MAX_WAIT = 6e3;
let rerenderQueued = false;
let lastRerender = Date.now();
const RefreshContextProvider = ({ rerenderMaxWait = DEFAULT_RERENDER_MAX_WAIT, characterStateInterval = DEFAULT_CHARACTER_STATE_INTERVAL, characterStateOverride = getCharacterState, children }) => {
  const [rerenderCount, setRerenderCount] = reactExports.useState(0);
  const [hardRefreshCount, setHardRefreshCount] = reactExports.useState(0);
  rerenderQueued = false;
  lastRerender = Date.now();
  const triggerHardRefresh = reactExports.useCallback(() => {
    lastCharacterState = null;
    markRemoteCallCacheDirty();
    setHardRefreshCount((count) => count + 1);
  }, []);
  useInterval(async () => {
    if (outstandingCalls.size === 0) {
      const characterState = await characterStateOverride();
      if (characterState !== void 0 && lastCharacterState !== null && !isEqual(characterState, lastCharacterState)) {
        lastCharacterState = characterState;
        triggerHardRefresh();
      }
      if (characterState !== void 0 && lastCharacterState === null) {
        lastCharacterState = characterState;
      }
    }
    if (rerenderQueued && Date.now() - lastRerender > rerenderMaxWait) {
      outstandingCalls.clear();
      setRerenderCount((count) => count + 1);
    }
  }, characterStateInterval);
  reactExports.useEffect(() => {
    var _a2;
    for (const pane of ["mainpane", "charpane"]) {
      const target = window.parent.parent.frames[pane];
      if (target) {
        instrumentXHR(pane, triggerHardRefresh);
        (_a2 = target == null ? void 0 : target.frameElement) == null ? void 0 : _a2.addEventListener("load", () => {
          if (shouldRefreshOnLoad(target.location.href)) {
            triggerHardRefresh();
          }
          instrumentXHR(pane, triggerHardRefresh);
        });
      }
    }
  }, [triggerHardRefresh]);
  reactExports.useEffect(() => {
    setRerenderQueuer(() => {
      if (outstandingCalls.size === 0) {
        setRerenderCount((count) => count + 1);
      } else {
        rerenderQueued = true;
      }
    });
  }, []);
  return jsxRuntimeExports.jsx(RefreshContext.Provider, { value: {
    rerenderCount,
    hardRefreshCount,
    triggerHardRefresh
  }, children });
};
const H1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h1", size: ["2xl", "3xl"], ...props });
const ErrorPage = ({ error }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxW: "4xl", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Stack,
  {
    justifyContent: "center",
    alignItems: "center",
    textAlign: "center",
    h: "100vh",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(H1, { children: "Error while rendering YORICK." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Code, { children: error.message }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: "https://github.com/loathers/yorick/issues", target: "_blank", children: "Please report this on GitHub!" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: () => window.location.reload(), children: "Reload YORICK" })
    ]
  }
) });
var NagPriority = /* @__PURE__ */ ((NagPriority2) => {
  NagPriority2[NagPriority2["CMC"] = 200] = "CMC";
  NagPriority2[NagPriority2["ERROR"] = 150] = "ERROR";
  NagPriority2[NagPriority2["IMMEDIATE"] = 100] = "IMMEDIATE";
  NagPriority2[NagPriority2["MID"] = 50] = "MID";
  NagPriority2[NagPriority2["LOW"] = 0] = "LOW";
  return NagPriority2;
})(NagPriority || {});
const NagContext = reactExports.createContext({
  nags: {},
  withNag() {
  }
});
const NagContextProvider = ({ children }) => {
  const [nags, setNags] = reactExports.useState({});
  const withNag = reactExports.useCallback(
    (id2, priority, imageUrl, node2) => {
      setNags((oldNags) => {
        if (node2) {
          return { ...oldNags, [id2]: { priority, imageUrl, node: node2 } };
        } else {
          const { [id2]: _, ...rest } = oldNags;
          return rest;
        }
      });
    },
    [setNags]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NagContext.Provider, { value: { nags, withNag }, children });
};
const BrandHeading = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(H1, { textAlign: "center", children: [
  "Y",
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    Image,
    {
      src: "Skull192.png",
      alt: "O",
      display: "inline",
      h: "1.75rem",
      ml: "-5px",
      mt: "-5px",
      mr: "-1px",
      mixBlendMode: "multiply"
    }
  ),
  "RICK"
] });
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes) => classes.filter((className, index, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
}).join(" ").trim();
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = reactExports.forwardRef(
  ({
    color = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref2) => {
    return reactExports.createElement(
      "svg",
      {
        ref: ref2,
        ...defaultAttributes,
        width: size2,
        height: size2,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ className, ...props }, ref2) => reactExports.createElement(Icon, {
      ref: ref2,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronLeft = createLucideIcon("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CircleAlert = createLucideIcon("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CircleHelp = createLucideIcon("CircleHelp", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Info = createLucideIcon("Info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Repeat = createLucideIcon("Repeat", [
  ["path", { d: "m17 2 4 4-4 4", key: "nntrym" }],
  ["path", { d: "M3 11v-1a4 4 0 0 1 4-4h14", key: "84bu3i" }],
  ["path", { d: "m7 22-4-4 4-4", key: "1wqhfi" }],
  ["path", { d: "M21 13v1a4 4 0 0 1-4 4H3", key: "1rx37r" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X = createLucideIcon("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
const ChatButton = ({ direction, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Button$1,
  {
    asChild: true,
    "aria-label": "Refresh",
    _hover: { bgColor: "bg.emphasized" },
    bgColor: "bg",
    p: 1,
    size: "xs",
    variant: "outline",
    height: "fit-content",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { writingMode: "vertical-rl", scale: -1, children: [
      "Chat ",
      direction === "left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeft, {})
    ] })
  }
);
const CloseIconButton = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  IconButton,
  {
    asChild: true,
    "aria-label": "Close",
    size: "2xs",
    _hover: { bgColor: "bg.emphasized" },
    bgColor: "bg",
    p: 1,
    variant: "outline",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, {})
  }
);
const booleanProperties = ["abortOnChoiceWhenNotInChoice", "addChatCommandLine", "addCreationQueue", "addStatusBarToFrames", "allowCloseableDesktopTabs", "allowNegativeTally", "allowNonMoodBurning", "allowSummonBurning", "autoHighlightOnFocus", "broadcastEvents", "cacheMallSearches", "chatBeep", "chatLinksUseRelay", "compactChessboard", "copyAsHTML", "customizedTabs", "debugBuy", "debugConsequences", "debugFoxtrotRemoval", "debugPathnames", "debugTopMenuStyle", "gapProtection", "gitInstallDependencies", "gitShowCommitMessages", "gitUpdateOnLogin", "greenScreenProtection", "guiUsesOneWindow", "hideServerDebugText", "logAcquiredItems", "logBattleAction", "logBrowserInteractions", "logChatMessages", "logChatRequests", "logCleanedHTML", "logDecoratedResponses", "logFamiliarActions", "logGainMessages", "logReadableHTML", "logPreferenceChange", "logMonsterHealth", "logReverseOrder", "logStatGains", "logStatusEffects", "logStatusOnLogin", "macroDebug", "macroLens", "mementoListActive", "mergeHobopolisChat", "pingLogin", "pingStealthyTimein", "printStackOnAbort", "proxySet", "relayAddSounds", "relayAddsCustomCombat", "relayAddsDiscoHelper", "relayAddsGraphicalCLI", "relayAddsQuickScripts", "relayAddsRestoreLinks", "relayAddsUpArrowLinks", "relayAddsUseLinks", "relayAddsWikiLinks", "relayAllowRemoteAccess", "relayBrowserOnly", "relayCacheUncacheable", "relayFormatsChatText", "relayHidesJunkMallItems", "relayMaintainsEffects", "relayMaintainsHealth", "relayMaintainsMana", "relayOverridesImages", "relayRunsAfterAdventureScript", "relayRunsBeforeBattleScript", "relayRunsBeforePVPScript", "relayScriptButtonFirst", "relayTextualizesEffects", "relayTrimsZapList", "relayUsesInlineLinks", "relayUsesIntegratedChat", "relayWarnOnRecoverFailure", "removeMalignantEffects", "saveSettingsOnSet", "sharePriceData", "showAllRequests", "showExceptionalRequests", "stealthLogin", "svnAlwaysAdd", "svnAlwaysOverwrite", "svnInstallDependencies", "svnShowCommitMessages", "svnUpdateOnLogin", "switchEquipmentForBuffs", "syncAfterSvnUpdate", "useChatToolbar", "useContactsFrame", "useDevServer", "useDockIconBadge", "useHugglerChannel", "useImageCache", "useLastUserAgent", "useSystemTrayIcon", "useTabbedChatFrame", "useToolbars", "useCachedVolcanoMaps", "useZoneComboBox", "verboseSpeakeasy", "verboseFloundry", "wrapLongLines", "_faxDataChanged", "_gitUpdated", "_svnRepoFileFetched", "_svnUpdated", "antagonisticSnowmanKitAvailable", "arcadeGameHints", "armoryUnlocked", "autoForbidIgnoringStores", "autoCraft", "autoQuest", "autoEntangle", "autoGarish", "autoManaRestore", "autoFillMayoMinder", "autoPinkyRing", "autoPlantHardcore", "autoPlantSoftcore", "autoPotionID", "autoRepairBoxServants", "autoSatisfyWithCloset", "autoSatisfyWithCoinmasters", "autoSatisfyWithMall", "autoSatisfyWithNPCs", "autoSatisfyWithStash", "autoSatisfyWithStorage", "autoSetConditions", "autoSteal", "autoTuxedo", "backupCameraReverserEnabled", "badMoonEncounter01", "badMoonEncounter02", "badMoonEncounter03", "badMoonEncounter04", "badMoonEncounter05", "badMoonEncounter06", "badMoonEncounter07", "badMoonEncounter08", "badMoonEncounter09", "badMoonEncounter10", "badMoonEncounter11", "badMoonEncounter12", "badMoonEncounter13", "badMoonEncounter14", "badMoonEncounter15", "badMoonEncounter16", "badMoonEncounter17", "badMoonEncounter18", "badMoonEncounter19", "badMoonEncounter20", "badMoonEncounter21", "badMoonEncounter22", "badMoonEncounter23", "badMoonEncounter24", "badMoonEncounter25", "badMoonEncounter26", "badMoonEncounter27", "badMoonEncounter28", "badMoonEncounter29", "badMoonEncounter30", "badMoonEncounter31", "badMoonEncounter32", "badMoonEncounter33", "badMoonEncounter34", "badMoonEncounter35", "badMoonEncounter36", "badMoonEncounter37", "badMoonEncounter38", "badMoonEncounter39", "badMoonEncounter40", "badMoonEncounter41", "badMoonEncounter42", "badMoonEncounter43", "badMoonEncounter44", "badMoonEncounter45", "badMoonEncounter46", "badMoonEncounter47", "badMoonEncounter48", "barrelShrineUnlocked", "batWingsBatHoleEntrance", "batWingsBatratBurrow", "batWingsBeanbatChamber", "batWingsGuanoJunction", "bigBrotherRescued", "blackBartsBootyAvailable", "bondAdv", "bondBeach", "bondBeat", "bondBooze", "bondBridge", "bondDesert", "bondDR", "bondDrunk1", "bondDrunk2", "bondHoney", "bondHP", "bondInit", "bondItem1", "bondItem2", "bondItem3", "bondJetpack", "bondMartiniDelivery", "bondMartiniPlus", "bondMartiniTurn", "bondMeat", "bondMox1", "bondMox2", "bondMPregen", "bondMus1", "bondMus2", "bondMys1", "bondMys2", "bondSpleen", "bondStat", "bondStat2", "bondStealth", "bondStealth2", "bondSymbols", "bondWar", "bondWeapon2", "bondWpn", "bookOfIronyAvailable", "booPeakLit", "bootsCharged", "breakfastCompleted", "burlyBodyguardReceivedBonus", "burrowgrubHiveUsed", "calzoneOfLegendEaten", "candyCaneSwordApartmentBuilding", "candyCaneSwordBlackForest", "candyCaneSwordBowlingAlley", "candyCaneSwordCopperheadClub", "candyCaneSwordDailyDungeon", "candyCaneSwordDefiledCranny", "candyCaneSwordFunHouse", "candyCaneSwordShore", "candyCaneSwordWarFratRoom", "candyCaneSwordWarFratZetas", "candyCaneSwordWarHippyBait", "candyCaneSwordWarHippyLine", "canteenUnlocked", "chaosButterflyThrown", "chatbotScriptExecuted", "chateauAvailable", "chatLiterate", "chatServesUpdates", "checkJackassHardcore", "checkJackassSoftcore", "clanAttacksEnabled", "coldAirportAlways", "considerShadowNoodles", "controlRoomUnlock", "concertVisited", "controlPanel1", "controlPanel2", "controlPanel3", "controlPanel4", "controlPanel5", "controlPanel6", "controlPanel7", "controlPanel8", "controlPanel9", "corralUnlocked", "crAlways", "crimbo23ArmoryAtWar", "crimbo23BarAtWar", "crimbo23CafeAtWar", "crimbo23CottageAtWar", "crimbo23FoundryAtWar", "cyberDatastickCollected", "dailyDungeonDone", "dampOldBootPurchased", "daycareOpen", "deepDishOfLegendEaten", "demonSummoned", "dinseyAudienceEngagement", "dinseyGarbagePirate", "dinseyRapidPassEnabled", "dinseyRollercoasterNext", "dinseySafetyProtocolsLoose", "doghouseBoarded", "dontStopForCounters", "drippingHallUnlocked", "drippyShieldUnlocked", "edUsedLash", "eldritchFissureAvailable", "eldritchHorrorAvailable", "enqueueForConsumption", "errorOnAmbiguousFold", "essenceOfAnnoyanceAvailable", "essenceOfBearAvailable", "expressCardUsed", "falloutShelterChronoUsed", "falloutShelterCoolingTankUsed", "fireExtinguisherBatHoleUsed", "fireExtinguisherChasmUsed", "fireExtinguisherCyrptUsed", "fireExtinguisherDesertUsed", "fireExtinguisherHaremUsed", "fistTeachingsHaikuDungeon", "fistTeachingsPokerRoom", "fistTeachingsBarroomBrawl", "fistTeachingsConservatory", "fistTeachingsBatHole", "fistTeachingsFunHouse", "fistTeachingsMenagerie", "fistTeachingsSlums", "fistTeachingsFratHouse", "fistTeachingsRoad", "fistTeachingsNinjaSnowmen", "flickeringPixel1", "flickeringPixel2", "flickeringPixel3", "flickeringPixel4", "flickeringPixel5", "flickeringPixel6", "flickeringPixel7", "flickeringPixel8", "floristFriarAvailable", "floristFriarChecked", "frAlways", "frCemetaryUnlocked", "friarsBlessingReceived", "frMountainsUnlocked", "frSwampUnlocked", "frVillageUnlocked", "frWoodUnlocked", "getawayCampsiteUnlocked", "ghostPencil1", "ghostPencil2", "ghostPencil3", "ghostPencil4", "ghostPencil5", "ghostPencil6", "ghostPencil7", "ghostPencil8", "ghostPencil9", "gingerAdvanceClockUnlocked", "gingerBlackmailAccomplished", "gingerbreadCityAvailable", "gingerExtraAdventures", "gingerNegativesDropped", "gingerSewersUnlocked", "gingerSubwayLineUnlocked", "gingerRetailUnlocked", "glitchItemAvailable", "grabCloversHardcore", "grabCloversSoftcore", "guideToSafariAvailable", "guyMadeOfBeesDefeated", "hallowienerDefiledNook", "hallowienerGuanoJunction", "hallowienerKnollGym", "hallowienerMadnessBakery", "hallowienerMiddleChamber", "hallowienerOvergrownLot", "hallowienerSkeletonStore", "hallowienerSmutOrcs", "hallowienerSonofaBeach", "hallowienerVolcoino", "hardcorePVPWarning", "harvestBatteriesHardcore", "harvestBatteriesSoftcore", "hasAutumnaton", "hasBartender", "hasChef", "hasCocktailKit", "hasCosmicBowlingBall", "hasDetectiveSchool", "hasMaydayContract", "hasOven", "hasRange", "hasShaker", "hasSushiMat", "hasTwinkleVision", "haveBoxingDaydreamHardcore", "haveBoxingDaydreamSoftcore", "hermitHax0red", "holidayHalsBookAvailable", "horseryAvailable", "hotAirportAlways", "intenseCurrents", "itemBoughtPerAscension637", "itemBoughtPerAscension8266", "itemBoughtPerAscension10790", "itemBoughtPerAscension10794", "itemBoughtPerAscension10795", "itemBoughtPerCharacter6423", "itemBoughtPerCharacter6428", "itemBoughtPerCharacter6429", "kingLiberated", "lastPirateInsult1", "lastPirateInsult2", "lastPirateInsult3", "lastPirateInsult4", "lastPirateInsult5", "lastPirateInsult6", "lastPirateInsult7", "lastPirateInsult8", "lawOfAveragesAvailable", "leafletCompleted", "ledCandleDropped", "libraryCardUsed", "lockPicked", "logBastilleBattalionBattles", "loginRecoveryHardcore", "loginRecoverySoftcore", "lovebugsUnlocked", "loveTunnelAvailable", "lowerChamberUnlock", "madnessBakeryAvailable", "makePocketWishesHardcore", "makePocketWishesSoftcore", "manualOfNumberologyAvailable", "mappingMonsters", "mapToAnemoneMinePurchased", "mapToKokomoAvailable", "mapToMadnessReefPurchased", "mapToTheDiveBarPurchased", "mapToTheMarinaraTrenchPurchased", "mapToTheSkateParkPurchased", "maraisBeaverUnlock", "maraisCorpseUnlock", "maraisDarkUnlock", "maraisVillageUnlock", "maraisWildlifeUnlock", "maraisWizardUnlock", "maximizerAlwaysCurrent", "maximizerCreateOnHand", "maximizerCurrentMallPrices", "maximizerFoldables", "maximizerIncludeAll", "maximizerNoAdventures", "middleChamberUnlock", "milkOfMagnesiumActive", "moonTuned", "neverendingPartyAlways", "noncombatForcerActive", "oasisAvailable", "odeBuffbotCheck", "oilPeakLit", "oscusSodaUsed", "outrageousSombreroUsed", "overgrownLotAvailable", "ownsFloristFriar", "ownsSpeakeasy", "pathedSummonsHardcore", "pathedSummonsSoftcore", "pirateRealmUnlockedAnemometer", "pirateRealmUnlockedBlunderbuss", "pirateRealmUnlockedBreastplate", "pirateRealmUnlockedClipper", "pirateRealmUnlockedCrabsicle", "pirateRealmUnlockedFlag", "pirateRealmUnlockedFork", "pirateRealmUnlockedGoldRing", "pirateRealmUnlockedManOWar", "pirateRealmUnlockedPlushie", "pirateRealmUnlockedRadioRing", "pirateRealmUnlockedRhum", "pirateRealmUnlockedScurvySkillbook", "pirateRealmUnlockedShavingCream", "pirateRealmUnlockedSpyglass", "pirateRealmUnlockedTattoo", "pirateRealmUnlockedThirdCrewmate", "pirateRealmUnlockedTikiSkillbook", "pizzaOfLegendEaten", "popularTartUnlocked", "potatoAlarmClockUsed", "prAlways", "prayedForGlamour", "prayedForProtection", "prayedForVigor", "primaryLabCheerCoreGrabbed", "pumpkinSpiceWhorlUsed", "pyramidBombUsed", "rageGlandVented", "readManualHardcore", "readManualSoftcore", "relayShowSpoilers", "relayShowWarnings", "rememberDesktopSize", "replicaChateauAvailable", "replicaNeverendingPartyAlways", "replicaWitchessSetAvailable", "requireBoxServants", "requireSewerTestItems", "restUsingCampAwayTent", "restUsingChateau", "ROMOfOptimalityAvailable", "safePickpocket", "schoolOfHardKnocksDiplomaAvailable", "scriptCascadingMenus", "serverAddsCustomCombat", "serverAddsBothCombat", "SHAWARMAInitiativeUnlocked", "showForbiddenStores", "showGainsPerUnit", "showIgnoringStorePrices", "showNoSummonOnly", "showTurnFreeOnly", "skeletonStoreAvailable", "sleazeAirportAlways", "snojoAvailable", "sortByEffect", "sortByRoom", "spacegateAlways", "spacegateVaccine1", "spacegateVaccine2", "spacegateVaccine3", "spaceInvaderDefeated", "spelunkyHints", "spiceMelangeUsed", "spookyAirportAlways", "stenchAirportAlways", "stopForFixedWanderer", "stopForUltraRare", "styxPixieVisited", "superconductorDefeated", "suppressCyberRealmDarkMode", "suppressCyberRealmGreenImages", "suppressInappropriateNags", "suppressPowerPixellation", "suppressMallPriceCacheMessages", "telegraphOfficeAvailable", "telescopeLookedHigh", "timeTowerAvailable", "trackLightsOut", "uneffectWithHotTub", "universalSeasoningActive", "universalSeasoningAvailable", "useBookOfEverySkillHardcore", "useBookOfEverySkillSoftcore", "useCrimboToysHardcore", "useCrimboToysSoftcore", "verboseMaximizer", "visitLoungeHardcore", "visitLoungeSoftcore", "visitRumpusHardcore", "visitRumpusSoftcore", "voteAlways", "wildfireBarrelCaulked", "wildfireDusted", "wildfireFracked", "wildfirePumpGreased", "wildfireSprinkled", "yearbookCameraPending", "youRobotScavenged", "_2002MrStoreCreditsCollected", "_affirmationCookieEaten", "_affirmationHateUsed", "_airFryerUsed", "_akgyxothUsed", "_alienAnimalMilkUsed", "_alienPlantPodUsed", "_allYearSucker", "_aprilShower", "_armyToddlerCast", "_aug1Cast", "_aug2Cast", "_aug3Cast", "_aug4Cast", "_aug5Cast", "_aug6Cast", "_aug7Cast", "_aug8Cast", "_aug9Cast", "_aug10Cast", "_aug11Cast", "_aug12Cast", "_aug13Cast", "_aug14Cast", "_aug15Cast", "_aug16Cast", "_aug17Cast", "_aug18Cast", "_aug19Cast", "_aug20Cast", "_aug21Cast", "_aug22Cast", "_aug23Cast", "_aug24Cast", "_aug25Cast", "_aug26Cast", "_aug27Cast", "_aug28Cast", "_aug29Cast", "_aug30Cast", "_aug31Cast", "_augTodayCast", "_authorsInkUsed", "_baconMachineUsed", "_bagOfCandy", "_bagOfCandyUsed", "_bagOTricksUsed", "_ballastTurtleUsed", "_ballInACupUsed", "_ballpit", "_barrelPrayer", "_bastilleLastBattleWon", "_beachCombing", "_bendHellUsed", "_blackMonolithUsed", "_blankoutUsed", "_bonersSummoned", "_bookOfEverySkillUsed", "_borrowedTimeUsed", "_bowleggedSwaggerUsed", "_bowlFullOfJellyUsed", "_boxOfHammersUsed", "_brainPreservationFluidUsed", "_brassDreadFlaskUsed", "_cameraUsed", "_canSeekBirds", "_candyCaneSwordBackAlley", "_candyCaneSwordHauntedBedroom", "_candyCaneSwordHauntedLibrary", "_candyCaneSwordLyle", "_candyCaneSwordMadnessBakery", "_candyCaneSwordOvergrownLot", "_candyCaneSwordOvergrownShrine", "_candyCaneSwordPalindome", "_candyCaneSwordSouthOfTheBorder", "_candyCaneSwordSpookyForest", "_carboLoaded", "_cargoPocketEmptied", "_ceciHatUsed", "_chateauDeskHarvested", "_chateauMonsterFought", "_chibiChanged", "_chronerCrossUsed", "_chronerTriggerUsed", "_chubbyAndPlumpUsed", "_circadianRhythmsRecalled", "_circleDrumUsed", "_clanFortuneBuffUsed", "_claraBellUsed", "_coalPaperweightUsed", "_cocoaDispenserUsed", "_cocktailShakerUsed", "_coldAirportToday", "_coldOne", "_communismUsed", "_confusingLEDClockUsed", "_controlPanelUsed", "_cookbookbatRecipeDrops", "_corruptedStardustUsed", "_cosmicSixPackConjured", "_crappyCameraUsed", "_creepyVoodooDollUsed", "_crimboTraining", "_crimboTree", "_crToday", "_cursedKegUsed", "_cursedMicrowaveUsed", "_cyberTrashCollected", "_dailyDungeonMalwareUsed", "_darkChocolateHeart", "_daycareFights", "_daycareNap", "_daycareSpa", "_daycareToday", "_defectiveTokenChecked", "_defectiveTokenUsed", "_dinseyGarbageDisposed", "_discoKnife", "_distentionPillUsed", "_dnaHybrid", "_docClocksThymeCocktailDrunk", "_drippingHallDoor1", "_drippingHallDoor2", "_drippingHallDoor3", "_drippingHallDoor4", "_drippyCaviarUsed", "_drippyNuggetUsed", "_drippyPilsnerUsed", "_drippyPlumUsed", "_drippyWineUsed", "_eldritchHorrorEvoked", "_eldritchTentacleFought", "_emberingHulkFought", "_entauntaunedToday", "_envyfishEggUsed", "_epicMcTwistUsed", "_essentialTofuUsed", "_etchedHourglassUsed", "_eternalCarBatteryUsed", "_everfullGlassUsed", "_extraGreasySliderEaten", "_eyeAndATwistUsed", "_fancyChessSetUsed", "_falloutShelterSpaUsed", "_fancyHotDogEaten", "_farmerItemsCollected", "_favoriteBirdVisited", "_firedJokestersGun", "_fireExtinguisherRefilled", "_fireStartingKitUsed", "_fireworksShop", "_fireworksShopHatBought", "_fireworksShopEquipmentBought", "_fireworkUsed", "_fishyPipeUsed", "_floundryItemCreated", "_floundryItemUsed", "_freePillKeeperUsed", "_frToday", "_frostyMugUsed", "_fudgeSporkUsed", "_garbageItemChanged", "_gingerBiggerAlligators", "_gingerbreadCityToday", "_gingerbreadClockAdvanced", "_gingerbreadClockVisited", "_gingerbreadColumnDestroyed", "_gingerbreadMobHitUsed", "_glennGoldenDiceUsed", "_glitchItemImplemented", "_gnollEyeUsed", "_governmentPerDiemUsed", "_grimBuff", "_guildManualUsed", "_guzzlrQuestAbandoned", "_hardKnocksDiplomaUsed", "_hippyMeatCollected", "_hobbyHorseUsed", "_hodgmansBlanketDrunk", "_holidayFunUsed", "_holoWristCrystal", "_hotAirportToday", "_hungerSauceUsed", "_hyperinflatedSealLungUsed", "_iceHotelRoomsRaided", "_iceSculptureUsed", "_incredibleSelfEsteemCast", "_infernoDiscoVisited", "_infiniteJellyUsed", "_internetDailyDungeonMalwareBought", "_internetGallonOfMilkBought", "_internetPlusOneBought", "_internetPrintScreenButtonBought", "_internetViralVideoBought", "_interviewIsabella", "_interviewMasquerade", "_interviewVlad", "_inquisitorsUnidentifiableObjectUsed", "_ironicMoustache", "_jackassPlumberGame", "_jarlsCheeseSummoned", "_jarlsCreamSummoned", "_jarlsDoughSummoned", "_jarlsEggsSummoned", "_jarlsFruitSummoned", "_jarlsMeatSummoned", "_jarlsPotatoSummoned", "_jarlsVeggiesSummoned", "_jingleBellUsed", "_jukebox", "_kgbFlywheelCharged", "_kgbLeftDrawerUsed", "_kgbOpened", "_kgbRightDrawerUsed", "_kolConSixPackUsed", "_kolhsCutButNotDried", "_kolhsIsskayLikeAnAshtray", "_kolhsPoeticallyLicenced", "_kolhsSchoolSpirited", "_kudzuSaladEaten", "_lastCombatLost", "_lastCombatWon", "_latteBanishUsed", "_latteCopyUsed", "_latteDrinkUsed", "_leafAntEggCrafted", "_leafDayShortenerCrafted", "_leafTattooCrafted", "_leavesJumped", "_legendaryBeat", "_licenseToChillUsed", "_lodestoneUsed", "_lookingGlass", "_loveTunnelToday", "_loveTunnelUsed", "_luckyGoldRingVolcoino", "_lunchBreak", "_lupineHormonesUsed", "_lyleFavored", "_madLiquorDrunk", "_madTeaParty", "_mafiaMiddleFingerRingUsed", "_managerialManipulationUsed", "_mansquitoSerumUsed", "_mapToACandyRichBlockUsed", "_maydayDropped", "_mayoDeviceRented", "_mayoTankSoaked", "_meatballMachineUsed", "_meatifyMatterUsed", "_milkOfMagnesiumUsed", "_mimeArmyShotglassUsed", "_miniKiwiIntoxicatingSpiritsBought", "_missGravesVermouthDrunk", "_missileLauncherUsed", "_molehillMountainUsed", "_momFoodReceived", "_mrBurnsgerEaten", "_muffinOrderedToday", "_mulliganStewEaten", "_mushroomGardenVisited", "_neverendingPartyToday", "_newYouQuestCompleted", "_olympicSwimmingPool", "_olympicSwimmingPoolItemFound", "_overflowingGiftBasketUsed", "_partyHard", "_pastaAdditive", "_perfectFreezeUsed", "_perfectlyFairCoinUsed", "_petePartyThrown", "_peteRiotIncited", "_photocopyUsed", "_pickyTweezersUsed", "_pickleJuiceDrunk", "_pingPongGame", "_pirateBellowUsed", "_pirateDinghyUsed", "_pirateForkUsed", "_pirateRealmSoldCompass", "_pirateRealmWindicleUsed", "_pixelOrbUsed", "_plumbersMushroomStewEaten", "_pneumaticityPotionUsed", "_portableSteamUnitUsed", "_pottedTeaTreeUsed", "_prToday", "_psychoJarFilled", "_psychoJarUsed", "_psychokineticHugUsed", "_punchingMirrorUsed", "_rainStickUsed", "_redwoodRainStickUsed", "_replicaSnowconeTomeUsed", "_replicaResolutionLibramUsed", "_replicaSmithsTomeUsed", "_requestSandwichSucceeded", "_rhinestonesAcquired", "_saladForkUsed", "_seaJellyHarvested", "_septEmberBalanceChecked", "_setOfJacksUsed", "_sewingKitUsed", "_sexChanged", "_shadowAffinityToday", "_shadowForestLooted", "_shrubDecorated", "_silverDreadFlaskUsed", "_sitCourseCompleted", "_skateBuff1", "_skateBuff2", "_skateBuff3", "_skateBuff4", "_skateBuff5", "_sleazeAirportToday", "_snowballFactoryUsed", "_sobrieTeaUsed", "_softwareGlitchTurnReceived", "_sotParcelReturned", "_spacegateMurderbot", "_spacegateRuins", "_spacegateSpant", "_spacegateToday", "_spacegateVaccine", "_spaghettiBreakfast", "_spaghettiBreakfastEaten", "_spinmasterLatheVisited", "_spinningWheel", "_spookyAirportToday", "_stabonicScrollUsed", "_steelyEyedSquintUsed", "_stenchAirportToday", "_stinkyCheeseBanisherUsed", "_strangeStalagmiteUsed", "_streamsCrossed", "_structuralEmberUsed", "_stuffedPocketwatchUsed", "_styxSprayUsed", "_summonAnnoyanceUsed", "_summonCarrotUsed", "_summonResortPassUsed", "_sweetToothUsed", "_syntheticDogHairPillUsed", "_tacoFlierUsed", "_takerSpaceSuppliesDelivered", "_telegraphOfficeToday", "_templeHiddenPower", "_tempuraAirUsed", "_thesisDelivered", "_tiedUpFlamingLeafletFought", "_tiedUpFlamingMonsteraFought", "_tiedUpLeaviathanFought", "_timeSpinnerReplicatorUsed", "_toastSummoned", "_tonicDjinn", "_treasuryEliteMeatCollected", "_treasuryHaremMeatCollected", "_trivialAvocationsGame", "_tryptophanDartUsed", "_turtlePowerCast", "_twelveNightEnergyUsed", "_ultraMegaSourBallUsed", "_victorSpoilsUsed", "_villainLairCanLidUsed", "_villainLairColorChoiceUsed", "_villainLairDoorChoiceUsed", "_villainLairFirecrackerUsed", "_villainLairSymbologyChoiceUsed", "_villainLairWebUsed", "_vmaskBanisherUsed", "_voraciTeaUsed", "_volcanoItemRedeemed", "_volcanoSuperduperheatedMetal", "_voodooSnuffUsed", "_voteToday", "_VYKEACafeteriaRaided", "_VYKEALoungeRaided", "_walfordQuestStartedToday", "_warbearBankUsed", "_warbearBreakfastMachineUsed", "_warbearGyrocopterUsed", "_warbearSodaMachineUsed", "_wildfireBarrelHarvested", "_witchessBuff", "_workshedItemUsed", "_yamBatteryUsed", "_zombieClover", "_preventScurvy", "lockedItem4637", "lockedItem4638", "lockedItem4639", "lockedItem4646", "lockedItem4647", "unknownRecipe3542", "unknownRecipe3543", "unknownRecipe3544", "unknownRecipe3545", "unknownRecipe3546", "unknownRecipe3547", "unknownRecipe3548", "unknownRecipe3749", "unknownRecipe3751", "unknownRecipe4172", "unknownRecipe4173", "unknownRecipe4174", "unknownRecipe5060", "unknownRecipe5061", "unknownRecipe5062", "unknownRecipe5063", "unknownRecipe5064", "unknownRecipe5066", "unknownRecipe5067", "unknownRecipe5069", "unknownRecipe5070", "unknownRecipe5072", "unknownRecipe5073", "unknownRecipe5670", "unknownRecipe5671", "unknownRecipe6501", "unknownRecipe6564", "unknownRecipe6565", "unknownRecipe6566", "unknownRecipe6567", "unknownRecipe6568", "unknownRecipe6569", "unknownRecipe6570", "unknownRecipe6571", "unknownRecipe6572", "unknownRecipe6573", "unknownRecipe6574", "unknownRecipe6575", "unknownRecipe6576", "unknownRecipe6577", "unknownRecipe6578", "unknownRecipe7752", "unknownRecipe7753", "unknownRecipe7754", "unknownRecipe7755", "unknownRecipe7756", "unknownRecipe7757", "unknownRecipe7758", "unknownRecipe10970", "unknownRecipe10971", "unknownRecipe10972", "unknownRecipe10973", "unknownRecipe10974", "unknownRecipe10975", "unknownRecipe10976", "unknownRecipe10977", "unknownRecipe10978", "unknownRecipe10988", "unknownRecipe10989", "unknownRecipe10990", "unknownRecipe10991", "unknownRecipe10992", "unknownRecipe11000"];
const numericProperties = ["coinMasterIndex", "dailyDeedsVersion", "defaultDropdown1", "defaultDropdown2", "defaultDropdownSplit", "defaultLimit", "fixedThreadPoolSize", "itemManagerIndex", "lastBuffRequestType", "lastGlobalCounterDay", "lastImageCacheClear", "pingDefaultTestPings", "pingLoginCount", "pingLoginGoal", "pingLoginThreshold", "pingTestPings", "previousUpdateRevision", "relayDelayForSVN", "relaySkillButtonCount", "scriptButtonPosition", "statusDropdown", "svnThreadPoolSize", "toolbarPosition", "_beachTides", "_g9Effect", "8BitBonusTurns", "8BitScore", "addingScrolls", "affirmationCookiesEaten", "aminoAcidsUsed", "antagonisticSnowmanKitCost", "ascensionsToday", "asolDeferredPoints", "asolPointsPigSkinner", "asolPointsCheeseWizard", "asolPointsJazzAgent", "autoAbortThreshold", "autoAntidote", "autoBuyPriceLimit", "autopsyTweezersUsed", "autumnatonQuestTurn", "availableCandyCredits", "availableDimes", "availableFunPoints", "availableMrStore2002Credits", "availableQuarters", "availableSeptEmbers", "availableStoreCredits", "availableSwagger", "avantGuardPoints", "averageSwagger", "awolMedicine", "awolPointsBeanslinger", "awolPointsCowpuncher", "awolPointsSnakeoiler", "awolDeferredPointsBeanslinger", "awolDeferredPointsCowpuncher", "awolDeferredPointsSnakeoiler", "awolVenom", "bagOTricksCharges", "ballpitBonus", "bankedKarma", "bartenderTurnsUsed", "basementMallPrices", "basementSafetyMargin", "batmanFundsAvailable", "batmanBonusInitialFunds", "batmanTimeLeft", "bearSwagger", "beeCounter", "beGregariousCharges", "beGregariousFightsLeft", "birdformCold", "birdformHot", "birdformRoc", "birdformSleaze", "birdformSpooky", "birdformStench", "blackBartsBootyCost", "blackPuddingsDefeated", "blackForestProgress", "blankOutUsed", "bloodweiserDrunk", "bodyguardCharge", "bondPoints", "bondVillainsDefeated", "boneAbacusVictories", "bookOfFactsGummi", "bookOfFactsPinata", "bookOfIronyCost", "booPeakProgress", "borisPoints", "breakableHandling", "breakableHandling1964", "breakableHandling9691", "breakableHandling9692", "breakableHandling9699", "breathitinCharges", "brodenBacteria", "brodenSprinkles", "buffBotMessageDisposal", "buffBotPhilanthropyType", "buffJimmyIngredients", "burnoutsDefeated", "burrowgrubSummonsRemaining", "bwApronMealsEaten", "camelSpit", "camerasUsed", "campAwayDecoration", "candyWitchTurnsUsed", "candyWitchCandyTotal", "carboLoading", "catBurglarBankHeists", "cellarLayout", "charitableDonations", "chasmBridgeProgress", "chefTurnsUsed", "chessboardsCleared", "chibiAlignment", "chibiBirthday", "chibiFitness", "chibiIntelligence", "chibiLastVisit", "chibiSocialization", "chilledToTheBone", "cinchoSaltAndLime", "cinderellaMinutesToMidnight", "cinderellaScore", "cocktailSummons", "commerceGhostCombats", "cookbookbatIngredientsCharge", "controlPanelOmega", "cornucopiasOpened", "cosmicBowlingBallReturnCombats", "cozyCounter6332", "cozyCounter6333", "cozyCounter6334", "craftingClay", "craftingLeather", "craftingStraw", "crimbo16BeardChakraCleanliness", "crimbo16BootsChakraCleanliness", "crimbo16BungChakraCleanliness", "crimbo16CrimboHatChakraCleanliness", "crimbo16GutsChakraCleanliness", "crimbo16HatChakraCleanliness", "crimbo16JellyChakraCleanliness", "crimbo16LiverChakraCleanliness", "crimbo16NippleChakraCleanliness", "crimbo16NoseChakraCleanliness", "crimbo16ReindeerChakraCleanliness", "crimbo16SackChakraCleanliness", "crimboTrainingSkill", "crimboTreeDays", "cubelingProgress", "cupidBowFights", "currentExtremity", "currentHedgeMazeRoom", "currentMojoFilters", "currentNunneryMeat", "currentPortalEnergy", "currentReplicaStoreYear", "cursedMagnifyingGlassCount", "cyrptAlcoveEvilness", "cyrptCrannyEvilness", "cyrptNicheEvilness", "cyrptNookEvilness", "cyrptTotalEvilness", "darkGyfftePoints", "dartsThrown", "daycareEquipment", "daycareInstructorItemQuantity", "daycareInstructors", "daycareLastScavenge", "daycareToddlers", "dbNemesisSkill1", "dbNemesisSkill2", "dbNemesisSkill3", "desertExploration", "desktopHeight", "desktopWidth", "dinseyFilthLevel", "dinseyFunProgress", "dinseyNastyBearsDefeated", "dinseySocialJusticeIProgress", "dinseySocialJusticeIIProgress", "dinseyTouristsFed", "dinseyToxicMultiplier", "doctorBagQuestLights", "doctorBagUpgrades", "dreadScroll1", "dreadScroll2", "dreadScroll3", "dreadScroll4", "dreadScroll5", "dreadScroll6", "dreadScroll7", "dreadScroll8", "dripAdventuresSinceAscension", "drippingHallAdventuresSinceAscension", "drippingTreesAdventuresSinceAscension", "drippyBatsUnlocked", "drippyJuice", "drippyOrbsClaimed", "droneSelfDestructChipsUsed", "drunkenSwagger", "edDefeatAbort", "edPoints", "eldritchTentaclesFought", "electricKoolAidEaten", "elfGratitude", "encountersUntilDMTChoice", "encountersUntilYachtzeeChoice", "encountersUntilNEPChoice", "encountersUntilSRChoice", "ensorceleeLevel", "entauntaunedColdRes", "essenceOfAnnoyanceCost", "essenceOfBearCost", "extraRolloverAdventures", "falloutShelterLevel", "familiarSweat", "fingernailsClipped", "fistSkillsKnown", "flyeredML", "fossilB", "fossilD", "fossilN", "fossilP", "fossilS", "fossilW", "fratboysDefeated", "frenchGuardTurtlesFreed", "funGuyMansionKills", "garbageChampagneCharge", "garbageFireProgress", "garbageShirtCharge", "garbageTreeCharge", "garlandUpgrades", "getsYouDrunkTurnsLeft", "ghostPepperTurnsLeft", "gingerDigCount", "gingerLawChoice", "gingerMuscleChoice", "gingerTrainScheduleStudies", "gladiatorBallMovesKnown", "gladiatorBladeMovesKnown", "gladiatorNetMovesKnown", "glitchItemCost", "glitchItemImplementationCount", "glitchItemImplementationLevel", "glitchSwagger", "gloverPoints", "gnasirProgress", "goldenMrAccessories", "gongPath", "gooseDronesRemaining", "goreCollected", "gourdItemCount", "greyYouPoints", "grimoire1Summons", "grimoire2Summons", "grimoire3Summons", "grimstoneCharge", "guardTurtlesFreed", "guideToSafariCost", "guyMadeOfBeesCount", "guzzlrBronzeDeliveries", "guzzlrDeliveryProgress", "guzzlrGoldDeliveries", "guzzlrPlatinumDeliveries", "haciendaLayout", "hallowiener8BitRealm", "hallowienerCoinspiracy", "hareMillisecondsSaved", "hareTurnsUsed", "heavyRainsStartingThunder", "heavyRainsStartingRain", "heavyRainsStartingLightning", "heroDonationBoris", "heroDonationJarlsberg", "heroDonationSneakyPete", "hiddenApartmentProgress", "hiddenBowlingAlleyProgress", "hiddenHospitalProgress", "hiddenOfficeProgress", "hiddenTavernUnlock", "highTopPumped", "hippiesDefeated", "holidayHalsBookCost", "holidaySwagger", "homemadeRobotUpgrades", "homebodylCharges", "hpAutoRecovery", "hpAutoRecoveryTarget", "iceSwagger", "ironicSwagger", "jarlsbergPoints", "juicyGarbageUsed", "jungCharge", "junglePuns", "knownAscensions", "kolhsTotalSchoolSpirited", "lastAnticheeseDay", "lastArcadeAscension", "lastBadMoonReset", "lastBangPotionReset", "lastBattlefieldReset", "lastBeardBuff", "lastBreakfast", "lastCartographyBooPeak", "lastCartographyCastleTop", "lastCartographyDarkNeck", "lastCartographyDefiledNook", "lastCartographyFratHouse", "lastCartographyFratHouseVerge", "lastCartographyGuanoJunction", "lastCartographyHauntedBilliards", "lastCartographyHippyCampVerge", "lastCartographyZeppelinProtesters", "lastCastleGroundUnlock", "lastCastleTopUnlock", "lastCellarReset", "lastChanceThreshold", "lastChasmReset", "lastColosseumRoundWon", "lastCouncilVisit", "lastCounterDay", "lastDesertUnlock", "lastDispensaryOpen", "lastDMTDuplication", "lastDwarfFactoryReset", "lastEVHelmetValue", "lastEVHelmetReset", "lastEmptiedStorage", "lastFilthClearance", "lastGoofballBuy", "lastGuildStoreOpen", "lastGuyMadeOfBeesReset", "lastFratboyCall", "lastFriarCeremonyAscension", "lastFriarsElbowNC", "lastFriarsHeartNC", "lastFriarsNeckNC", "lastHippyCall", "lastIslandUnlock", "lastKeyotronUse", "lastKingLiberation", "lastLightsOutTurn", "lastMushroomPlot", "lastMiningReset", "lastNemesisReset", "lastPaperStripReset", "lastPirateEphemeraReset", "lastPirateInsultReset", "lastPlusSignUnlock", "lastQuartetAscension", "lastQuartetRequest", "lastSecondFloorUnlock", "lastShadowForgeUnlockAdventure", "lastSkateParkReset", "lastStillBeatingSpleen", "lastTavernAscension", "lastTavernSquare", "lastTelescopeReset", "lastTempleAdventures", "lastTempleButtonsUnlock", "lastTempleUnlock", "lastThingWithNoNameDefeated", "lastTowelAscension", "lastTr4pz0rQuest", "lastTrainsetConfiguration", "lastVioletFogMap", "lastVoteMonsterTurn", "lastWartDinseyDefeated", "lastWuTangDefeated", "lastYearbookCameraAscension", "lastZapperWand", "lastZapperWandExplosionDay", "lawOfAveragesCost", "legacyPoints", "leprecondoLastNeedChange", "libramSummons", "lightsOutAutomation", "louvreDesiredGoal", "louvreGoal", "lovebugsAridDesert", "lovebugsBeachBuck", "lovebugsBooze", "lovebugsChroner", "lovebugsCoinspiracy", "lovebugsCyrpt", "lovebugsFreddy", "lovebugsFunFunds", "lovebugsHoboNickel", "lovebugsItemDrop", "lovebugsMeat", "lovebugsMeatDrop", "lovebugsMoxie", "lovebugsMuscle", "lovebugsMysticality", "lovebugsOilPeak", "lovebugsOrcChasm", "lovebugsPowder", "lovebugsWalmart", "lttQuestDifficulty", "lttQuestStageCount", "manaBurnSummonThreshold", "manaBurningThreshold", "manaBurningTrigger", "manorDrawerCount", "manualOfNumberologyCost", "mapToKokomoCost", "masksUnlocked", "maximizerMRUSize", "maximizerCombinationLimit", "maximizerEquipmentLevel", "maximizerEquipmentScope", "maximizerMaxPrice", "maximizerPriceLevel", "maxManaBurn", "mayflyExperience", "mayoLevel", "meansuckerPrice", "merkinVocabularyMastery", "miniAdvClass", "miniKiwiAiolisUsed", "miniMartinisDrunk", "moleTunnelLevel", "mothershipProgress", "mpAutoRecovery", "mpAutoRecoveryTarget", "munchiesPillsUsed", "mushroomGardenCropLevel", "nanopolymerSpiderWebsUsed", "nextAprilBandTurn", "nextParanormalActivity", "nextQuantumFamiliarOwnerId", "nextQuantumFamiliarTurn", "noobPoints", "noobDeferredPoints", "noodleSummons", "nsContestants1", "nsContestants2", "nsContestants3", "nuclearAutumnPoints", "numericSwagger", "nunsVisits", "oilPeakProgress", "optimalSwagger", "optimisticCandleProgress", "palindomeDudesDefeated", "parasolUsed", "peaceTurkeyIndex", "pendingMapReflections", "phosphorTracesUses", "pingpongSkill", "pirateRealmPlasticPiratesDefeated", "pirateRealmShipsDestroyed", "pirateRealmStormsEscaped", "pirateSwagger", "plantingDay", "plumberBadgeCost", "plumberCostumeCost", "plumberPoints", "poolSharkCount", "poolSkill", "powerPillProgress", "preworkoutPowderUses", "primaryLabGooIntensity", "prismaticSummons", "procrastinatorLanguageFluency", "promptAboutCrafting", "puzzleChampBonus", "pyramidPosition", "quantumPoints", "reagentSummons", "reanimatorArms", "reanimatorLegs", "reanimatorSkulls", "reanimatorWeirdParts", "reanimatorWings", "recentLocations", "redSnapperProgress", "relayPort", "relocatePygmyJanitor", "relocatePygmyLawyer", "rockinRobinProgress", "romanCandelabraRedCasts", "romanCandelabraBlueCasts", "romanCandelabraYellowCasts", "romanCandelabraGreenCasts", "romanCandelabraPurpleCasts", "ROMOfOptimalityCost", "rumpelstiltskinKidsRescued", "rumpelstiltskinTurnsUsed", "rwbMonsterCount", "safariSwagger", "sausageGrinderUnits", "schoolOfHardKnocksDiplomaCost", "schoolSwagger", "scrapbookCharges", "screechCombats", "scriptMRULength", "seaodesFound", "SeasoningSwagger", "sexChanges", "shenInitiationDay", "shockingLickCharges", "singleFamiliarRun", "skillBurn3", "skillBurn90", "skillBurn153", "skillBurn154", "skillBurn155", "skillBurn236", "skillBurn237", "skillBurn1019", "skillBurn5017", "skillBurn6014", "skillBurn6015", "skillBurn6016", "skillBurn6020", "skillBurn6021", "skillBurn6022", "skillBurn6023", "skillBurn6024", "skillBurn6026", "skillBurn6028", "skillBurn7323", "skillBurn14008", "skillBurn14028", "skillBurn14038", "skillBurn15011", "skillBurn15028", "skillBurn17005", "skillBurn22034", "skillBurn22035", "skillBurn23301", "skillBurn23302", "skillBurn23303", "skillBurn23304", "skillBurn23305", "skillBurn23306", "skillLevel46", "skillLevel47", "skillLevel48", "skillLevel117", "skillLevel118", "skillLevel121", "skillLevel128", "skillLevel134", "skillLevel135", "skillLevel144", "skillLevel180", "skillLevel188", "skillLevel227", "skillLevel7254", "slimelingFullness", "slimelingStacksDropped", "slimelingStacksDue", "smoresEaten", "smutOrcNoncombatProgress", "sneakyPetePoints", "snojoMoxieWins", "snojoMuscleWins", "snojoMysticalityWins", "sourceAgentsDefeated", "sourceEnlightenment", "sourceInterval", "sourcePoints", "sourceTerminalGram", "sourceTerminalPram", "sourceTerminalSpam", "spaceBabyLanguageFluency", "spacePirateLanguageFluency", "spelunkyNextNoncombat", "spelunkySacrifices", "spelunkyWinCount", "spookyPuttyCopiesMade", "spookyVHSTapeMonsterTurn", "statbotUses", "sugarCounter4178", "sugarCounter4179", "sugarCounter4180", "sugarCounter4181", "sugarCounter4182", "sugarCounter4183", "sugarCounter4191", "summonAnnoyanceCost", "sweat", "tacoDanCocktailSauce", "tacoDanFishMeat", "takerSpaceAnchor", "takerSpaceGold", "takerSpaceMast", "takerSpaceRum", "takerSpaceSilk", "takerSpaceSpice", "tavernLayout", "telescopeUpgrades", "tempuraSummons", "timeSpinnerMedals", "timesRested", "tomeSummons", "totalCharitableDonations", "trainsetPosition", "turtleBlessingTurns", "twinPeakProgress", "twoCRSPoints", "unicornHornInflation", "universalSeasoningCost", "usable1HWeapons", "usable1xAccs", "usable2HWeapons", "usable3HWeapons", "usableAccessories", "usableHats", "usableOffhands", "usableOther", "usablePants", "usableShirts", "valueOfAdventure", "valueOfInventory", "valueOfStill", "valueOfTome", "vintnerCharge", "vintnerWineLevel", "violetFogGoal", "walfordBucketProgress", "warehouseProgress", "welcomeBackAdv", "wereProfessorBite", "wereProfessorKick", "wereProfessorLiver", "wereProfessorPoints", "wereProfessorRend", "wereProfessorResearchPoints", "wereProfessorStomach", "wereProfessorTransformTurns", "whetstonesUsed", "wolfPigsEvicted", "wolfTurnsUsed", "writingDesksDefeated", "xoSkeleltonXProgress", "xoSkeleltonOProgress", "yearbookCameraAscensions", "yearbookCameraUpgrades", "youRobotBody", "youRobotBottom", "youRobotLeft", "youRobotPoints", "youRobotRight", "youRobotTop", "zeppelinProgress", "zeppelinProtestors", "zigguratLianas", "zombiePoints", "zootSpecimensPrepared", "zootomistPoints", "_absintheDrops", "_abstractionDropsCrown", "_aguaDrops", "_xenomorphCharge", "_ancestralRecallCasts", "_antihangoverBonus", "_aprilBandInstruments", "_aprilBandSaxophoneUses", "_aprilBandTomUses", "_aprilBandTubaUses", "_aprilBandStaffUses", "_aprilBandPiccoloUses", "_astralDrops", "_augSkillsCast", "_assertYourAuthorityCast", "_automatedFutureManufactures", "_autumnatonQuests", "_backUpUses", "_badlyRomanticArrows", "_badgerCharge", "_balefulHowlUses", "_banderRunaways", "_bastilleCheese", "_bastilleGames", "_bastilleGameTurn", "_bastilleLastCheese", "_batWingsCauldronUsed", "_batWingsFreeFights", "_batWingsRestUsed", "_batWingsSwoopUsed", "_beanCannonUses", "_bearHugs", "_beerLensDrops", "_bellydancerPickpockets", "_benettonsCasts", "_birdsSoughtToday", "_bookOfFactsWishes", "_bookOfFactsTatters", "_boomBoxFights", "_boomBoxSongsLeft", "_bootStomps", "_boxingGloveArrows", "_brickoEyeSummons", "_brickoFights", "_campAwayCloudBuffs", "_campAwaySmileBuffs", "_candyEggsDeviled", "_candySummons", "_captainHagnkUsed", "_carnieCandyDrops", "_carnivorousPottedPlantWins", "_carrotNoseDrops", "_catBurglarCharge", "_catBurglarHeistsComplete", "_cheerleaderSteam", "_chestXRayUsed", "_chibiAdventures", "_chipBags", "_chocolateCigarsUsed", "_chocolateCoveredPingPongBallsUsed", "_chocolateSculpturesUsed", "_chocolatesUsed", "_chronolithActivations", "_chronolithNextCost", "_cinchUsed", "_cinchoRests", "_circadianRhythmsAdventures", "_clanFortuneConsultUses", "_clipartSummons", "_cloversPurchased", "_coldMedicineConsults", "_coldMedicineEquipmentTaken", "_companionshipCasts", "_cookbookbatCrafting", "_cookbookbatCombatsUntilNewQuest", "_cosmicBowlingSkillsUsed", "_crimbo21ColdResistance", "_cyberFreeFights", "_cyberZone1Turns", "_cyberZone2Turns", "_cyberZone3Turns", "_dailySpecialPrice", "_dartsLeft", "_daycareGymScavenges", "_daycareRecruits", "_deckCardsDrawn", "_deluxeKlawSummons", "_demandSandwich", "_detectiveCasesCompleted", "_disavowed", "_dnaPotionsMade", "_donhosCasts", "_douseFoeUses", "_dreamJarDrops", "_drunkPygmyBanishes", "_edDefeats", "_edLashCount", "_eldritchTentaclesFoughtToday", "_elfGuardCookingUsed", "_elronsCasts", "_enamorangs", "_energyCollected", "_expertCornerCutterUsed", "_extraTimeUsed", "_favorRareSummons", "_feastUsed", "_feelinTheRhythm", "_feelPrideUsed", "_feelExcitementUsed", "_feelHatredUsed", "_feelLonelyUsed", "_feelNervousUsed", "_feelEnvyUsed", "_feelDisappointedUsed", "_feelSuperiorUsed", "_feelLostUsed", "_feelNostalgicUsed", "_feelPeacefulUsed", "_fingertrapArrows", "_fireExtinguisherCharge", "_fragrantHerbsUsed", "_freeBeachWalksUsed", "_frButtonsPressed", "_fudgeWaspFights", "_gapBuffs", "_garbageFireDrops", "_garbageFireDropsCrown", "_genieFightsUsed", "_genieWishesUsed", "_gibbererAdv", "_gibbererCharge", "_gingerbreadCityTurns", "_glarkCableUses", "_glitchMonsterFights", "_gnomeAdv", "_godLobsterFights", "_goldenMoneyCharge", "_gongDrops", "_gothKidCharge", "_gothKidFights", "_greyYouAdventures", "_grimBrotherCharge", "_grimFairyTaleDrops", "_grimFairyTaleDropsCrown", "_grimoireConfiscatorSummons", "_grimoireGeekySummons", "_grimstoneMaskDrops", "_grimstoneMaskDropsCrown", "_grooseCharge", "_grooseDrops", "_grubbyWoolDrops", "_guzzlrDeliveries", "_guzzlrGoldDeliveries", "_guzzlrPlatinumDeliveries", "_hareAdv", "_hareCharge", "_highTopPumps", "_hipsterAdv", "_hoardedCandyDropsCrown", "_hoboUnderlingSummons", "_holidayMultitaskingUsed", "_holoWristDrops", "_holoWristProgress", "_hotAshesDrops", "_hotJellyUses", "_hotTubSoaks", "_humanMuskUses", "_iceballUses", "_inigosCasts", "_ironTricornHeadbuttUsed", "_jerksHealthMagazinesUsed", "_jiggleCheese", "_jiggleCream", "_jiggleLife", "_jiggleSteak", "_jitbCharge", "_juneCleaverAdvs", "_juneCleaverFightsLeft", "_juneCleaverEncounters", "_juneCleaverStench", "_juneCleaverSpooky", "_juneCleaverSleaze", "_juneCleaverHot", "_juneCleaverCold", "_juneCleaverSkips", "_jungDrops", "_kgbClicksUsed", "_kgbDispenserUses", "_kgbTranquilizerDartUses", "_klawSummons", "_kloopCharge", "_kloopDrops", "_kolhsAdventures", "_kolhsSavedByTheBell", "_lastDailyDungeonRoom", "_lastSausageMonsterTurn", "_lastZomboEye", "_latteRefillsUsed", "_lawOfAveragesUsed", "_leafblowerML", "_leafLassosCrafted", "_leafMonstersFought", "_leavesBurned", "_legionJackhammerCrafting", "_leprecondoRearrangements", "_leprecondoFurniture", "_llamaCharge", "_longConUsed", "_lovebugsBeachBuck", "_lovebugsChroner", "_lovebugsCoinspiracy", "_lovebugsFreddy", "_lovebugsFunFunds", "_lovebugsHoboNickel", "_lovebugsWalmart", "_loveChocolatesUsed", "_lynyrdSnareUses", "_machineTunnelsAdv", "_macrometeoriteUses", "_mafiaThumbRingAdvs", "_mapToACandyRichBlockDrops", "_mayamRests", "_mayflowerDrops", "_mayflySummons", "_mcHugeLargeAvalancheUses", "_mcHugeLargeSkiPlowUses", "_mcHugeLargeSlashUses", "_mediumSiphons", "_meteoriteAdesUsed", "_meteorShowerUses", "_micrometeoriteUses", "_mildEvilPerpetrated", "_mimicEggsDonated", "_mimicEggsObtained", "_miniKiwiDrops", "_miniMartiniDrops", "_monkeyPawWishesUsed", "_monsterHabitatsFightsLeft", "_monsterHabitatsRecalled", "_monstersMapped", "_mushroomGardenFights", "_nanorhinoCharge", "_navelRunaways", "_neverendingPartyFreeTurns", "_newYouQuestSharpensDone", "_newYouQuestSharpensToDo", "_nextColdMedicineConsult", "_nextQuantumAlignment", "_nightmareFuelCharges", "_noobSkillCount", "_nuclearStockpileUsed", "_oilExtracted", "_oldSchoolCocktailCraftingUsed", "_olfactionsUsed", "_optimisticCandleDropsCrown", "_oreDropsCrown", "_otoscopeUsed", "_oysterEggsFound", "_pantsgivingBanish", "_pantsgivingCount", "_pantsgivingCrumbs", "_pantsgivingFullness", "_pasteDrops", "_peteJukeboxFixed", "_peteJumpedShark", "_petePeeledOut", "_photoBoothEffects", "_photoBoothEquipment", "_pieDrops", "_piePartsCount", "_pirateRealmGold", "_pirateRealmGrog", "_pirateRealmGrub", "_pirateRealmGuns", "_pirateRealmIslandMonstersDefeated", "_pirateRealmSailingTurns", "_pirateRealmShipSpeed", "_pixieCharge", "_pocketProfessorLectures", "_poisonArrows", "_pokeGrowFertilizerDrops", "_poolGames", "_powderedGoldDrops", "_powderedMadnessUses", "_powerfulGloveBatteryPowerUsed", "_powerPillDrops", "_powerPillUses", "_precisionCasts", "_questPartyFairItemsOpened", "_radlibSummons", "_raindohCopiesMade", "_rapidPrototypingUsed", "_raveStealCount", "_reflexHammerUsed", "_resolutionAdv", "_resolutionRareSummons", "_riftletAdv", "_robinEggDrops", "_roboDrops", "_rogueProgramCharge", "_romanticFightsLeft", "_saberForceMonsterCount", "_saberForceUses", "_saberMod", "_saltGrainsConsumed", "_sandwormCharge", "_saplingsPlanted", "_sausageFights", "_sausagesEaten", "_sausagesMade", "_sealFigurineUses", "_sealScreeches", "_sealsSummoned", "_shadowBricksUsed", "_shadowRiftCombats", "_shatteringPunchUsed", "_shortOrderCookCharge", "_shrubCharge", "_slimeVialsHarvested", "_sloppyDinerBeachBucks", "_smilesOfMrA", "_smithsnessSummons", "_snojoFreeFights", "_snojoParts", "_snokebombUsed", "_snowconeSummons", "_snowglobeDrops", "_snowmanHatPlaceUsed", "_snowSuitCount", "_sourceTerminalDigitizeMonsterCount", "_sourceTerminalDigitizeUses", "_sourceTerminalDuplicateUses", "_sourceTerminalEnhanceUses", "_sourceTerminalExtrudes", "_sourceTerminalPortscanUses", "_spaceFurDropsCrown", "_spacegatePlanetIndex", "_spacegateTurnsLeft", "_spaceJellyfishDrops", "_speakeasyDrinksDrunk", "_speakeasyFreeFights", "_spelunkerCharges", "_spelunkingTalesDrops", "_spikolodonSpikeUses", "_spiritOfTheMountainsAdvs", "_spookyJellyUses", "_stackLumpsUses", "_steamCardDrops", "_stickerSummons", "_stinkyCheeseCount", "_stressBallSqueezes", "_sugarSummons", "_surprisinglySweetSlashUsed", "_surprisinglySweetStabUsed", "_sweatOutSomeBoozeUsed", "_taffyRareSummons", "_taffyYellowSummons", "_tearawayPantsAdvs", "_thanksgettingFoodsEaten", "_thingfinderCasts", "_thinknerdPackageDrops", "_thorsPliersCrafting", "_timeHelmetAdv", "_timeSpinnerMinutesUsed", "_tokenDrops", "_transponderDrops", "_turkeyBlastersUsed", "_turkeyBooze", "_turkeyMuscle", "_turkeyMyst", "_turkeyMoxie", "_unaccompaniedMinerUsed", "_unconsciousCollectiveCharge", "_universalSeasoningsUsed", "_universeCalculated", "_universeImploded", "_usedReplicaBatoomerang", "_vampyreCloakeFormUses", "_villainLairProgress", "_vitachocCapsulesUsed", "_vmaskAdv", "_voidFreeFights", "_volcanoItem1", "_volcanoItem2", "_volcanoItem3", "_volcanoItemCount1", "_volcanoItemCount2", "_volcanoItemCount3", "_voteFreeFights", "_VYKEACompanionLevel", "_warbearAutoAnvilCrafting", "_waxGlobDrops", "_whiteRiceDrops", "_witchessFights", "_xoHugsUsed", "_yellowPixelDropsCrown", "_zapCount", "_zombieSmashPocketsUsed", "lastNoncombat15", "lastNoncombat257", "lastNoncombat270", "lastNoncombat273", "lastNoncombat280", "lastNoncombat297", "lastNoncombat322", "lastNoncombat323", "lastNoncombat324", "lastNoncombat341", "lastNoncombat343", "lastNoncombat384", "lastNoncombat386", "lastNoncombat391", "lastNoncombat405", "lastNoncombat406", "lastNoncombat439", "lastNoncombat440", "lastNoncombat441", "lastNoncombat450", "lastNoncombat533", "lastNoncombat539", "lastNoncombat540", "lastNoncombat541", "lastNoncombat588", "lastNoncombat589", "lastNoncombat590", "lastNoncombat591", "lastNoncombat592"];
const monsterProperties = ["beGregariousMonster", "bodyguardChatMonster", "cameraMonster", "chateauMonster", "clumsinessGroveBoss", "crappyCameraMonster", "crudeMonster", "enamorangMonster", "envyfishMonster", "glacierOfJerksBoss", "holdHandsMonster", "iceSculptureMonster", "lastCopyableMonster", "longConMonster", "maelstromOfLoversBoss", "makeFriendsMonster", "merkinLockkeyMonster", "monkeyPointMonster", "motifMonster", "nosyNoseMonster", "olfactedMonster", "photocopyMonster", "rainDohMonster", "romanticTarget", "rufusDesiredEntity", "rwbMonster", "screencappedMonster", "spookyPuttyMonster", "spookyVHSTapeMonster", "stenchCursedMonster", "superficiallyInterestedMonster", "waxMonster", "yearbookCameraTarget", "_cookbookbatQuestMonster", "_gallapagosMonster", "_jiggleCreamedMonster", "_latteMonster", "_monsterHabitatsMonster", "_nanorhinoBanishedMonster", "_newYouQuestMonster", "_prankCardMonster", "_relativityMonster", "_saberForceMonster", "_sourceTerminalDigitizeMonster", "_trickCoinMonster", "_voteMonster"];
const monsterNumericProperties = [];
const locationProperties = ["autumnatonQuestLocation", "currentJunkyardLocation", "doctorBagQuestLocation", "ghostLocation", "guzzlrQuestLocation", "lastAdventure", "nextAdventure", "nextSpookyravenElizabethRoom", "nextSpookyravenStephenRoom", "rwbLocation", "sourceOracleTarget", "_cookbookbatQuestLastLocation", "_floundryBassLocation", "_floundryCarpLocation", "_floundryCodLocation", "_floundryHatchetfishLocation", "_floundryTroutLocation", "_floundryTunaLocation", "_lastPirateRealmIsland", "_sotParcelLocation"];
const stringProperties = ["autoLogin", "browserBookmarks", "chatFontSize", "combatHotkey0", "combatHotkey1", "combatHotkey2", "combatHotkey3", "combatHotkey4", "combatHotkey5", "combatHotkey6", "combatHotkey7", "combatHotkey8", "combatHotkey9", "commandBufferGCLI", "commandBufferTabbedChat", "commandLineNamespace", "dailyDeedsOptions", "defaultBorderColor", "displayName", "externalEditor", "getBreakfast", "headerStates", "highlightList", "http.proxyHost", "http.proxyPassword", "http.proxyPort", "http.proxyUser", "https.proxyHost", "https.proxyPassword", "https.proxyPort", "https.proxyUser", "initialDesktop", "initialFrames", "lastRelayUpdate", "lastUserAgent", "lastUsername", "logPreferenceChangeFilter", "loginScript", "loginServerName", "loginWindowLogo", "logoutScript", "pingDefaultTestPage", "pingLatest", "pingLoginAbort", "pingLoginCheck", "pingLoginFail", "pingLongest", "pingShortest", "pingTestPage", "previousNotifyList", "previousUpdateVersion", "saveState", "saveStateActive", "scriptList", "swingLookAndFeel", "userAgent", "8BitColor", "afterAdventureScript", "antiScientificMethod", "autoOlfact", "autoPutty", "autumnatonUpgrades", "backupCameraMode", "banishedMonsters", "banishedPhyla", "banishingShoutMonsters", "batmanStats", "batmanZone", "batmanUpgrades", "battleAction", "beachHeadsUnlocked", "beastSkillsAvailable", "beastSkillsKnown", "beforePVPScript", "betweenBattleScript", "boomBoxSong", "breakfastAlways", "breakfastHardcore", "breakfastSoftcore", "buffBotCasting", "buyScript", "cargoPocketsEmptied", "cargoPocketScraps", "chatbotScript", "chatPlayerScript", "chibiName", "choiceAdventureScript", "chosenTrip", "clanFortuneReply1", "clanFortuneReply2", "clanFortuneReply3", "clanFortuneWord1", "clanFortuneWord2", "clanFortuneWord3", "counterScript", "copperheadClubHazard", "crimbo23ArmoryControl", "crimbo23BarControl", "crimbo23CafeControl", "crimbo23CottageControl", "crimbo23FoundryControl", "crimbotChassis", "crimbotArm", "crimbotPropulsion", "crystalBallPredictions", "csServicesPerformed", "currentAstralTrip", "currentDistillateMods", "currentEasyBountyItem", "currentHardBountyItem", "currentHippyStore", "currentJunkyardTool", "currentLlamaForm", "currentMood", "currentPVPSeason", "currentPvpVictories", "currentSpecialBountyItem", "currentSITSkill", "customCombatScript", "cyrusAdjectives", "defaultFlowerLossMessage", "defaultFlowerWinMessage", "demonName1", "demonName2", "demonName3", "demonName4", "demonName5", "demonName6", "demonName7", "demonName8", "demonName9", "demonName10", "demonName11", "demonName12", "demonName13", "dinseyGatorStenchDamage", "dinseyRollercoasterStats", "duckAreasCleared", "duckAreasSelected", "edPiece", "enamorangMonsterTurn", "ensorcelee", "EVEDirections", "everfullDartPerks", "extraCosmeticModifiers", "familiarScript", "forbiddenStores", "gameProBossSpecialPower", "gooseReprocessed", "grimoireSkillsHardcore", "grimoireSkillsSoftcore", "grimstoneMaskPath", "guzzlrQuestClient", "guzzlrQuestTier", "harvestGardenHardcore", "harvestGardenSoftcore", "hpAutoRecoveryItems", "invalidBuffMessage", "jickSwordModifier", "juneCleaverQueue", "kingLiberatedScript", "lassoTraining", "lastAdventureContainer", "lastAdventureTrail", "lastBangPotion819", "lastBangPotion820", "lastBangPotion821", "lastBangPotion822", "lastBangPotion823", "lastBangPotion824", "lastBangPotion825", "lastBangPotion826", "lastBangPotion827", "lastChanceBurn", "lastChessboard", "lastCombatEnvironments", "lastDwarfDiceRolls", "lastDwarfDigitRunes", "lastDwarfEquipmentRunes", "lastDwarfFactoryItem118", "lastDwarfFactoryItem119", "lastDwarfFactoryItem120", "lastDwarfFactoryItem360", "lastDwarfFactoryItem361", "lastDwarfFactoryItem362", "lastDwarfFactoryItem363", "lastDwarfFactoryItem364", "lastDwarfFactoryItem365", "lastDwarfFactoryItem910", "lastDwarfFactoryItem3199", "lastDwarfOfficeItem3208", "lastDwarfOfficeItem3209", "lastDwarfOfficeItem3210", "lastDwarfOfficeItem3211", "lastDwarfOfficeItem3212", "lastDwarfOfficeItem3213", "lastDwarfOfficeItem3214", "lastDwarfOreRunes", "lastDwarfHopper1", "lastDwarfHopper2", "lastDwarfHopper3", "lastDwarfHopper4", "lastEncounter", "lastMacroError", "lastMessageId", "lastPaperStrip3144", "lastPaperStrip4138", "lastPaperStrip4139", "lastPaperStrip4140", "lastPaperStrip4141", "lastPaperStrip4142", "lastPaperStrip4143", "lastPaperStrip4144", "lastPirateEphemera", "lastPorkoBoard", "lastPorkoPayouts", "lastPorkoExpected", "lastSlimeVial3885", "lastSlimeVial3886", "lastSlimeVial3887", "lastSlimeVial3888", "lastSlimeVial3889", "lastSlimeVial3890", "lastSlimeVial3891", "lastSlimeVial3892", "lastSlimeVial3893", "lastSlimeVial3894", "lastSlimeVial3895", "lastSlimeVial3896", "lastSelectedFaxbot", "lastSuccessfulFaxbot", "latteIngredients", "latteModifier", "latteUnlocks", "ledCandleMode", "leprecondoCurrentNeed", "leprecondoDiscovered", "leprecondoInstalled", "leprecondoNeedOrder", "libramSkillsHardcore", "libramSkillsSoftcore", "louvreOverride", "lovePotion", "lttQuestName", "maximizerList", "maximizerMRUList", "mayoInMouth", "mayoMinderSetting", "merkinQuestPath", "mimicEggMonsters", "mineLayout1", "mineLayout2", "mineLayout3", "mineLayout4", "mineLayout5", "mineLayout6", "mineState1", "mineState2", "mineState3", "mineState4", "mineState5", "mineState6", "mpAutoRecoveryItems", "nextDistillateMods", "nextQuantumFamiliarName", "nextQuantumFamiliarOwner", "noncombatForcers", "nsChallenge2", "nsChallenge3", "nsChallenge4", "nsChallenge5", "nsTowerDoorKeysUsed", "oceanAction", "oceanDestination", "parkaMode", "pastaThrall1", "pastaThrall2", "pastaThrall3", "pastaThrall4", "pastaThrall5", "pastaThrall6", "pastaThrall7", "pastaThrall8", "peteMotorbikeTires", "peteMotorbikeGasTank", "peteMotorbikeHeadlight", "peteMotorbikeCowling", "peteMotorbikeMuffler", "peteMotorbikeSeat", "pieStuffing", "plantingDate", "plantingLength", "plantingScript", "plumberCostumeWorn", "pokefamBoosts", "postAscensionScript", "preAscensionScript", "questClumsinessGrove", "questDoctorBag", "questECoBucket", "questESlAudit", "questESlBacteria", "questESlCheeseburger", "questESlCocktail", "questESlDebt", "questESlFish", "questESlMushStash", "questESlSalt", "questESlSprinkles", "questESpClipper", "questESpEVE", "questESpFakeMedium", "questESpGore", "questESpJunglePun", "questESpOutOfOrder", "questESpSerum", "questESpSmokes", "questEStFishTrash", "questEStGiveMeFuel", "questEStNastyBears", "questEStSocialJusticeI", "questEStSocialJusticeII", "questEStSuperLuber", "questEStWorkWithFood", "questEStZippityDooDah", "questEUNewYou", "questF01Primordial", "questF02Hyboria", "questF03Future", "questF04Elves", "questF05Clancy", "questG01Meatcar", "questG02Whitecastle", "questG03Ego", "questG04Nemesis", "questG05Dark", "questG06Delivery", "questG07Myst", "questG08Moxie", "questG09Muscle", "questGlacierOfJerks", "questGuzzlr", "questI01Scapegoat", "questI02Beat", "questL02Larva", "questL03Rat", "questL04Bat", "questL05Goblin", "questL06Friar", "questL07Cyrptic", "questL08Trapper", "questL09Topping", "questL10Garbage", "questL11Black", "questL11Business", "questL11Curses", "questL11Desert", "questL11Doctor", "questL11MacGuffin", "questL11Manor", "questL11Palindome", "questL11Pyramid", "questL11Ron", "questL11Shen", "questL11Spare", "questL11Worship", "questL12HippyFrat", "questL12War", "questL13Final", "questL13Warehouse", "questLTTQuestByWire", "questM01Untinker", "questM02Artist", "questM03Bugbear", "questM05Toot", "questM06Gourd", "questM07Hammer", "questM08Baker", "questM09Rocks", "questM10Azazel", "questM11Postal", "questM12Pirate", "questM13Escape", "questM14Bounty", "questM15Lol", "questM16Temple", "questM17Babies", "questM18Swamp", "questM19Hippy", "questM20Necklace", "questM21Dance", "questM22Shirt", "questM23Meatsmith", "questM24Doc", "questM25Armorer", "questM26Oracle", "questMaelstromOfLovers", "questPAGhost", "questRufus", "questS01OldGuy", "questS02Monkees", "raveCombo1", "raveCombo2", "raveCombo3", "raveCombo4", "raveCombo5", "raveCombo6", "recoveryScript", "relayCounters", "retroCapeSuperhero", "retroCapeWashingInstructions", "royalty", "rufusQuestTarget", "rufusQuestType", "scriptMRUList", "seahorseName", "shadowLabyrinthGoal", "shadowRiftIngress", "shrubGarland", "shrubGifts", "shrubLights", "shrubTopper", "sideDefeated", "sidequestArenaCompleted", "sidequestFarmCompleted", "sidequestJunkyardCompleted", "sidequestLighthouseCompleted", "sidequestNunsCompleted", "sidequestOrchardCompleted", "skateParkStatus", "snowsuit", "sourceTerminalChips", "sourceTerminalEducate1", "sourceTerminalEducate2", "sourceTerminalEnquiry", "sourceTerminalEducateKnown", "sourceTerminalEnhanceKnown", "sourceTerminalEnquiryKnown", "sourceTerminalExtrudeKnown", "spadingData", "spadingScript", "speakeasyName", "spelunkyStatus", "spelunkyUpgrades", "spookyravenRecipeUsed", "stationaryButton1", "stationaryButton2", "stationaryButton3", "stationaryButton4", "stationaryButton5", "streamCrossDefaultTarget", "sweetSynthesisBlacklist", "telescope1", "telescope2", "telescope3", "telescope4", "telescope5", "testudinalTeachings", "textColors", "thanksMessage", "tomeSkillsHardcore", "tomeSkillsSoftcore", "trackVoteMonster", "trackedMonsters", "trackedPhyla", "trainsetConfiguration", "umbrellaState", "umdLastObtained", "vintnerWineEffect", "vintnerWineName", "vintnerWineType", "violetFogLayout", "volcanoMaze1", "volcanoMaze2", "volcanoMaze3", "volcanoMaze4", "volcanoMaze5", "warProgress", "watchedPreferences", "wereProfessorAdvancedResearch", "workteaClue", "yourFavoriteBird", "yourFavoriteBirdMods", "youRobotCPUUpgrades", "zootGraftedMods", "zootMilkCrueltyMods", "zootMilkKindnessMods", "_automatedFutureSide", "_bastilleBoosts", "_bastilleChoice1", "_bastilleChoice2", "_bastilleChoice3", "_bastilleCurrentStyles", "_bastilleEnemyCastle", "_bastilleEnemyName", "_bastilleLastBattleResults", "_bastilleLastEncounter", "_bastilleStats", "_beachHeadsUsed", "_beachLayout", "_beachMinutes", "_birdOfTheDay", "_birdOfTheDayMods", "_bittycar", "_campAwaySmileBuffSign", "_citizenZone", "_citizenZoneMods", "_cloudTalkMessage", "_cloudTalkSmoker", "_coatOfPaintModifier", "_cupidBowFamiliars", "_currentDartboard", "_cyberZone1Defense", "_cyberZone1Hacker", "_cyberZone1Owner", "_cyberZone2Defense", "_cyberZone2Hacker", "_cyberZone2Owner", "_cyberZone3Defense", "_cyberZone3Hacker", "_cyberZone3Owner", "_deckCardsSeen", "_feastedFamiliars", "_floristPlantsUsed", "_frAreasUnlocked", "_frHoursLeft", "_frMonstersKilled", "_futuristicCollarModifier", "_futuristicHatModifier", "_futuristicShirtModifier", "_horsery", "_horseryCrazyMox", "_horseryCrazyMus", "_horseryCrazyMys", "_horseryCrazyName", "_horseryCurrentName", "_horseryDarkName", "_horseryNormalName", "_horseryPaleName", "_jickJarAvailable", "_jiggleCheesedMonsters", "_lastCombatActions", "_lastCombatStarted", "_locketMonstersFought", "_mayamSymbolsUsed", "_mummeryMods", "_mummeryUses", "_newYouQuestSkill", "_noHatModifier", "_pantogramModifier", "_pirateRealmCrewmate", "_pirateRealmCrewmate1", "_pirateRealmCrewmate2", "_pirateRealmCrewmate3", "_pirateRealmShip", "_pottedPowerPlant", "_questESp", "_questPartyFair", "_questPartyFairProgress", "_questPartyFairQuest", "_questPirateRealm", "_roboDrinks", "_roninStoragePulls", "_savageBeastMods", "_spacegateAnimalLife", "_spacegateCoordinates", "_spacegateGear", "_spacegateHazards", "_spacegateIntelligentLife", "_spacegatePlanetName", "_spacegatePlantLife", "_stolenAccordions", "_tempRelayCounters", "_timeSpinnerFoodAvailable", "_trickOrTreatBlock", "_unknownEasyBountyItem", "_unknownHardBountyItem", "_unknownSpecialBountyItem", "_untakenEasyBountyItem", "_untakenHardBountyItem", "_untakenSpecialBountyItem", "_userMods", "_villainLairColor", "_villainLairKey", "_voteLocal1", "_voteLocal2", "_voteLocal3", "_voteLocal4", "_voteMonster1", "_voteMonster2", "_voteModifier", "_VYKEACompanionType", "_VYKEACompanionRune", "_VYKEACompanionName"];
const numericOrStringProperties = ["statusEngineering", "statusGalley", "statusMedbay", "statusMorgue", "statusNavigation", "statusScienceLab", "statusSonar", "statusSpecialOps", "statusWasteProcessing", "choiceAdventure2", "choiceAdventure3", "choiceAdventure4", "choiceAdventure5", "choiceAdventure6", "choiceAdventure7", "choiceAdventure8", "choiceAdventure9", "choiceAdventure10", "choiceAdventure11", "choiceAdventure12", "choiceAdventure14", "choiceAdventure15", "choiceAdventure16", "choiceAdventure17", "choiceAdventure18", "choiceAdventure19", "choiceAdventure20", "choiceAdventure21", "choiceAdventure22", "choiceAdventure23", "choiceAdventure24", "choiceAdventure25", "choiceAdventure26", "choiceAdventure27", "choiceAdventure28", "choiceAdventure29", "choiceAdventure40", "choiceAdventure41", "choiceAdventure42", "choiceAdventure45", "choiceAdventure46", "choiceAdventure47", "choiceAdventure71", "choiceAdventure72", "choiceAdventure73", "choiceAdventure74", "choiceAdventure75", "choiceAdventure76", "choiceAdventure77", "choiceAdventure86", "choiceAdventure87", "choiceAdventure88", "choiceAdventure89", "choiceAdventure90", "choiceAdventure91", "choiceAdventure105", "choiceAdventure106", "choiceAdventure107", "choiceAdventure108", "choiceAdventure109", "choiceAdventure110", "choiceAdventure111", "choiceAdventure112", "choiceAdventure113", "choiceAdventure114", "choiceAdventure115", "choiceAdventure116", "choiceAdventure117", "choiceAdventure118", "choiceAdventure120", "choiceAdventure123", "choiceAdventure125", "choiceAdventure126", "choiceAdventure127", "choiceAdventure129", "choiceAdventure131", "choiceAdventure132", "choiceAdventure135", "choiceAdventure136", "choiceAdventure137", "choiceAdventure138", "choiceAdventure139", "choiceAdventure140", "choiceAdventure141", "choiceAdventure142", "choiceAdventure143", "choiceAdventure144", "choiceAdventure145", "choiceAdventure146", "choiceAdventure147", "choiceAdventure148", "choiceAdventure149", "choiceAdventure151", "choiceAdventure152", "choiceAdventure153", "choiceAdventure154", "choiceAdventure155", "choiceAdventure156", "choiceAdventure157", "choiceAdventure158", "choiceAdventure159", "choiceAdventure160", "choiceAdventure161", "choiceAdventure162", "choiceAdventure163", "choiceAdventure164", "choiceAdventure165", "choiceAdventure166", "choiceAdventure167", "choiceAdventure168", "choiceAdventure169", "choiceAdventure170", "choiceAdventure171", "choiceAdventure172", "choiceAdventure177", "choiceAdventure178", "choiceAdventure180", "choiceAdventure181", "choiceAdventure182", "choiceAdventure184", "choiceAdventure185", "choiceAdventure186", "choiceAdventure187", "choiceAdventure188", "choiceAdventure189", "choiceAdventure191", "choiceAdventure197", "choiceAdventure198", "choiceAdventure199", "choiceAdventure200", "choiceAdventure201", "choiceAdventure202", "choiceAdventure203", "choiceAdventure204", "choiceAdventure205", "choiceAdventure206", "choiceAdventure207", "choiceAdventure208", "choiceAdventure211", "choiceAdventure212", "choiceAdventure213", "choiceAdventure214", "choiceAdventure215", "choiceAdventure216", "choiceAdventure217", "choiceAdventure218", "choiceAdventure219", "choiceAdventure220", "choiceAdventure221", "choiceAdventure222", "choiceAdventure223", "choiceAdventure224", "choiceAdventure225", "choiceAdventure230", "choiceAdventure272", "choiceAdventure273", "choiceAdventure276", "choiceAdventure277", "choiceAdventure278", "choiceAdventure279", "choiceAdventure280", "choiceAdventure281", "choiceAdventure282", "choiceAdventure283", "choiceAdventure284", "choiceAdventure285", "choiceAdventure286", "choiceAdventure287", "choiceAdventure288", "choiceAdventure289", "choiceAdventure290", "choiceAdventure291", "choiceAdventure292", "choiceAdventure293", "choiceAdventure294", "choiceAdventure295", "choiceAdventure296", "choiceAdventure297", "choiceAdventure298", "choiceAdventure299", "choiceAdventure302", "choiceAdventure303", "choiceAdventure304", "choiceAdventure305", "choiceAdventure306", "choiceAdventure307", "choiceAdventure308", "choiceAdventure309", "choiceAdventure310", "choiceAdventure311", "choiceAdventure317", "choiceAdventure318", "choiceAdventure319", "choiceAdventure320", "choiceAdventure321", "choiceAdventure322", "choiceAdventure326", "choiceAdventure327", "choiceAdventure328", "choiceAdventure329", "choiceAdventure330", "choiceAdventure331", "choiceAdventure332", "choiceAdventure333", "choiceAdventure334", "choiceAdventure335", "choiceAdventure336", "choiceAdventure337", "choiceAdventure338", "choiceAdventure339", "choiceAdventure340", "choiceAdventure341", "choiceAdventure342", "choiceAdventure343", "choiceAdventure344", "choiceAdventure345", "choiceAdventure346", "choiceAdventure347", "choiceAdventure348", "choiceAdventure349", "choiceAdventure350", "choiceAdventure351", "choiceAdventure352", "choiceAdventure353", "choiceAdventure354", "choiceAdventure355", "choiceAdventure356", "choiceAdventure357", "choiceAdventure358", "choiceAdventure360", "choiceAdventure361", "choiceAdventure362", "choiceAdventure363", "choiceAdventure364", "choiceAdventure365", "choiceAdventure366", "choiceAdventure367", "choiceAdventure372", "choiceAdventure376", "choiceAdventure387", "choiceAdventure388", "choiceAdventure389", "choiceAdventure390", "choiceAdventure391", "choiceAdventure392", "choiceAdventure393", "choiceAdventure395", "choiceAdventure396", "choiceAdventure397", "choiceAdventure398", "choiceAdventure399", "choiceAdventure400", "choiceAdventure401", "choiceAdventure402", "choiceAdventure403", "choiceAdventure423", "choiceAdventure424", "choiceAdventure425", "choiceAdventure426", "choiceAdventure427", "choiceAdventure428", "choiceAdventure429", "choiceAdventure430", "choiceAdventure431", "choiceAdventure432", "choiceAdventure433", "choiceAdventure435", "choiceAdventure438", "choiceAdventure439", "choiceAdventure442", "choiceAdventure444", "choiceAdventure445", "choiceAdventure446", "choiceAdventure447", "choiceAdventure448", "choiceAdventure449", "choiceAdventure451", "choiceAdventure452", "choiceAdventure453", "choiceAdventure454", "choiceAdventure455", "choiceAdventure456", "choiceAdventure457", "choiceAdventure458", "choiceAdventure460", "choiceAdventure461", "choiceAdventure462", "choiceAdventure463", "choiceAdventure464", "choiceAdventure465", "choiceAdventure467", "choiceAdventure468", "choiceAdventure469", "choiceAdventure470", "choiceAdventure471", "choiceAdventure472", "choiceAdventure473", "choiceAdventure474", "choiceAdventure475", "choiceAdventure477", "choiceAdventure478", "choiceAdventure480", "choiceAdventure483", "choiceAdventure484", "choiceAdventure485", "choiceAdventure486", "choiceAdventure488", "choiceAdventure489", "choiceAdventure490", "choiceAdventure491", "choiceAdventure496", "choiceAdventure497", "choiceAdventure502", "choiceAdventure503", "choiceAdventure504", "choiceAdventure505", "choiceAdventure506", "choiceAdventure507", "choiceAdventure509", "choiceAdventure510", "choiceAdventure511", "choiceAdventure512", "choiceAdventure513", "choiceAdventure514", "choiceAdventure515", "choiceAdventure517", "choiceAdventure518", "choiceAdventure519", "choiceAdventure521", "choiceAdventure522", "choiceAdventure523", "choiceAdventure527", "choiceAdventure528", "choiceAdventure529", "choiceAdventure530", "choiceAdventure531", "choiceAdventure532", "choiceAdventure533", "choiceAdventure534", "choiceAdventure535", "choiceAdventure536", "choiceAdventure538", "choiceAdventure539", "choiceAdventure542", "choiceAdventure543", "choiceAdventure544", "choiceAdventure546", "choiceAdventure548", "choiceAdventure549", "choiceAdventure550", "choiceAdventure551", "choiceAdventure552", "choiceAdventure553", "choiceAdventure554", "choiceAdventure556", "choiceAdventure557", "choiceAdventure558", "choiceAdventure559", "choiceAdventure560", "choiceAdventure561", "choiceAdventure562", "choiceAdventure563", "choiceAdventure564", "choiceAdventure565", "choiceAdventure566", "choiceAdventure567", "choiceAdventure568", "choiceAdventure569", "choiceAdventure571", "choiceAdventure572", "choiceAdventure573", "choiceAdventure574", "choiceAdventure575", "choiceAdventure576", "choiceAdventure577", "choiceAdventure578", "choiceAdventure579", "choiceAdventure581", "choiceAdventure582", "choiceAdventure583", "choiceAdventure584", "choiceAdventure594", "choiceAdventure595", "choiceAdventure596", "choiceAdventure597", "choiceAdventure598", "choiceAdventure599", "choiceAdventure600", "choiceAdventure603", "choiceAdventure604", "choiceAdventure616", "choiceAdventure634", "choiceAdventure640", "choiceAdventure654", "choiceAdventure655", "choiceAdventure656", "choiceAdventure657", "choiceAdventure658", "choiceAdventure664", "choiceAdventure669", "choiceAdventure670", "choiceAdventure671", "choiceAdventure672", "choiceAdventure673", "choiceAdventure674", "choiceAdventure675", "choiceAdventure676", "choiceAdventure677", "choiceAdventure678", "choiceAdventure679", "choiceAdventure681", "choiceAdventure683", "choiceAdventure684", "choiceAdventure685", "choiceAdventure686", "choiceAdventure687", "choiceAdventure688", "choiceAdventure689", "choiceAdventure690", "choiceAdventure691", "choiceAdventure692", "choiceAdventure693", "choiceAdventure694", "choiceAdventure695", "choiceAdventure696", "choiceAdventure697", "choiceAdventure698", "choiceAdventure700", "choiceAdventure701", "choiceAdventure705", "choiceAdventure706", "choiceAdventure707", "choiceAdventure708", "choiceAdventure709", "choiceAdventure710", "choiceAdventure711", "choiceAdventure712", "choiceAdventure713", "choiceAdventure714", "choiceAdventure715", "choiceAdventure716", "choiceAdventure717", "choiceAdventure721", "choiceAdventure725", "choiceAdventure729", "choiceAdventure733", "choiceAdventure737", "choiceAdventure741", "choiceAdventure745", "choiceAdventure749", "choiceAdventure753", "choiceAdventure771", "choiceAdventure778", "choiceAdventure780", "choiceAdventure781", "choiceAdventure783", "choiceAdventure784", "choiceAdventure785", "choiceAdventure786", "choiceAdventure787", "choiceAdventure788", "choiceAdventure789", "choiceAdventure791", "choiceAdventure793", "choiceAdventure794", "choiceAdventure795", "choiceAdventure796", "choiceAdventure797", "choiceAdventure803", "choiceAdventure805", "choiceAdventure808", "choiceAdventure809", "choiceAdventure813", "choiceAdventure815", "choiceAdventure830", "choiceAdventure832", "choiceAdventure833", "choiceAdventure834", "choiceAdventure835", "choiceAdventure837", "choiceAdventure838", "choiceAdventure839", "choiceAdventure840", "choiceAdventure841", "choiceAdventure842", "choiceAdventure851", "choiceAdventure852", "choiceAdventure853", "choiceAdventure854", "choiceAdventure855", "choiceAdventure856", "choiceAdventure857", "choiceAdventure858", "choiceAdventure866", "choiceAdventure873", "choiceAdventure875", "choiceAdventure876", "choiceAdventure877", "choiceAdventure878", "choiceAdventure879", "choiceAdventure880", "choiceAdventure881", "choiceAdventure882", "choiceAdventure888", "choiceAdventure889", "choiceAdventure918", "choiceAdventure919", "choiceAdventure920", "choiceAdventure921", "choiceAdventure923", "choiceAdventure924", "choiceAdventure925", "choiceAdventure926", "choiceAdventure927", "choiceAdventure928", "choiceAdventure929", "choiceAdventure930", "choiceAdventure931", "choiceAdventure932", "choiceAdventure940", "choiceAdventure941", "choiceAdventure942", "choiceAdventure943", "choiceAdventure944", "choiceAdventure945", "choiceAdventure946", "choiceAdventure950", "choiceAdventure955", "choiceAdventure957", "choiceAdventure958", "choiceAdventure959", "choiceAdventure960", "choiceAdventure961", "choiceAdventure962", "choiceAdventure963", "choiceAdventure964", "choiceAdventure965", "choiceAdventure966", "choiceAdventure970", "choiceAdventure973", "choiceAdventure974", "choiceAdventure975", "choiceAdventure976", "choiceAdventure977", "choiceAdventure979", "choiceAdventure980", "choiceAdventure981", "choiceAdventure982", "choiceAdventure983", "choiceAdventure988", "choiceAdventure989", "choiceAdventure993", "choiceAdventure998", "choiceAdventure1000", "choiceAdventure1003", "choiceAdventure1005", "choiceAdventure1006", "choiceAdventure1007", "choiceAdventure1008", "choiceAdventure1009", "choiceAdventure1010", "choiceAdventure1011", "choiceAdventure1012", "choiceAdventure1013", "choiceAdventure1015", "choiceAdventure1016", "choiceAdventure1017", "choiceAdventure1018", "choiceAdventure1019", "choiceAdventure1020", "choiceAdventure1021", "choiceAdventure1022", "choiceAdventure1023", "choiceAdventure1026", "choiceAdventure1027", "choiceAdventure1028", "choiceAdventure1029", "choiceAdventure1030", "choiceAdventure1031", "choiceAdventure1032", "choiceAdventure1033", "choiceAdventure1034", "choiceAdventure1035", "choiceAdventure1036", "choiceAdventure1037", "choiceAdventure1038", "choiceAdventure1039", "choiceAdventure1040", "choiceAdventure1041", "choiceAdventure1042", "choiceAdventure1044", "choiceAdventure1045", "choiceAdventure1046", "choiceAdventure1048", "choiceAdventure1051", "choiceAdventure1052", "choiceAdventure1053", "choiceAdventure1054", "choiceAdventure1055", "choiceAdventure1056", "choiceAdventure1057", "choiceAdventure1059", "choiceAdventure1060", "choiceAdventure1061", "choiceAdventure1062", "choiceAdventure1065", "choiceAdventure1067", "choiceAdventure1068", "choiceAdventure1069", "choiceAdventure1070", "choiceAdventure1071", "choiceAdventure1073", "choiceAdventure1077", "choiceAdventure1080", "choiceAdventure1081", "choiceAdventure1082", "choiceAdventure1083", "choiceAdventure1084", "choiceAdventure1085", "choiceAdventure1091", "choiceAdventure1094", "choiceAdventure1095", "choiceAdventure1096", "choiceAdventure1097", "choiceAdventure1102", "choiceAdventure1106", "choiceAdventure1107", "choiceAdventure1108", "choiceAdventure1110", "choiceAdventure1114", "choiceAdventure1115", "choiceAdventure1116", "choiceAdventure1118", "choiceAdventure1119", "choiceAdventure1120", "choiceAdventure1121", "choiceAdventure1122", "choiceAdventure1123", "choiceAdventure1171", "choiceAdventure1172", "choiceAdventure1173", "choiceAdventure1174", "choiceAdventure1175", "choiceAdventure1193", "choiceAdventure1195", "choiceAdventure1196", "choiceAdventure1197", "choiceAdventure1198", "choiceAdventure1199", "choiceAdventure1202", "choiceAdventure1203", "choiceAdventure1204", "choiceAdventure1205", "choiceAdventure1206", "choiceAdventure1207", "choiceAdventure1208", "choiceAdventure1209", "choiceAdventure1210", "choiceAdventure1211", "choiceAdventure1212", "choiceAdventure1213", "choiceAdventure1214", "choiceAdventure1215", "choiceAdventure1219", "choiceAdventure1222", "choiceAdventure1223", "choiceAdventure1224", "choiceAdventure1225", "choiceAdventure1226", "choiceAdventure1227", "choiceAdventure1228", "choiceAdventure1229", "choiceAdventure1236", "choiceAdventure1237", "choiceAdventure1238", "choiceAdventure1239", "choiceAdventure1240", "choiceAdventure1241", "choiceAdventure1242", "choiceAdventure1243", "choiceAdventure1244", "choiceAdventure1245", "choiceAdventure1246", "choiceAdventure1247", "choiceAdventure1248", "choiceAdventure1249", "choiceAdventure1250", "choiceAdventure1251", "choiceAdventure1252", "choiceAdventure1253", "choiceAdventure1254", "choiceAdventure1255", "choiceAdventure1256", "choiceAdventure1266", "choiceAdventure1280", "choiceAdventure1281", "choiceAdventure1282", "choiceAdventure1283", "choiceAdventure1284", "choiceAdventure1285", "choiceAdventure1286", "choiceAdventure1287", "choiceAdventure1288", "choiceAdventure1289", "choiceAdventure1290", "choiceAdventure1291", "choiceAdventure1292", "choiceAdventure1293", "choiceAdventure1294", "choiceAdventure1295", "choiceAdventure1296", "choiceAdventure1297", "choiceAdventure1298", "choiceAdventure1299", "choiceAdventure1300", "choiceAdventure1301", "choiceAdventure1302", "choiceAdventure1303", "choiceAdventure1304", "choiceAdventure1305", "choiceAdventure1307", "choiceAdventure1310", "choiceAdventure1312", "choiceAdventure1313", "choiceAdventure1314", "choiceAdventure1315", "choiceAdventure1316", "choiceAdventure1317", "choiceAdventure1318", "choiceAdventure1319", "choiceAdventure1321", "choiceAdventure1322", "choiceAdventure1323", "choiceAdventure1324", "choiceAdventure1325", "choiceAdventure1326", "choiceAdventure1327", "choiceAdventure1328", "choiceAdventure1332", "choiceAdventure1333", "choiceAdventure1335", "choiceAdventure1340", "choiceAdventure1341", "choiceAdventure1345", "choiceAdventure1389", "choiceAdventure1392", "choiceAdventure1397", "choiceAdventure1399", "choiceAdventure1405", "choiceAdventure1411", "choiceAdventure1415", "choiceAdventure1427", "choiceAdventure1428", "choiceAdventure1429", "choiceAdventure1430", "choiceAdventure1431", "choiceAdventure1432", "choiceAdventure1433", "choiceAdventure1434", "choiceAdventure1436", "choiceAdventure1460", "choiceAdventure1461", "choiceAdventure1467", "choiceAdventure1468", "choiceAdventure1469", "choiceAdventure1470", "choiceAdventure1471", "choiceAdventure1472", "choiceAdventure1473", "choiceAdventure1474", "choiceAdventure1475", "choiceAdventure1486", "choiceAdventure1487", "choiceAdventure1488", "choiceAdventure1489", "choiceAdventure1491", "choiceAdventure1494", "choiceAdventure1505", "choiceAdventure1528", "choiceAdventure1534", "choiceAdventure1538", "choiceAdventure1539", "choiceAdventure1540", "choiceAdventure1541", "choiceAdventure1542", "choiceAdventure1545", "choiceAdventure1546", "choiceAdventure1547", "choiceAdventure1548", "choiceAdventure1549", "choiceAdventure1550"];
const familiarProperties = ["commaFamiliar", "cupidBowLastFamiliar", "nextQuantumFamiliar", "stillsuitFamiliar", "zootGraftedButtCheekLeftFamiliar", "zootGraftedButtCheekRightFamiliar", "zootGraftedFootLeftFamiliar", "zootGraftedFootRightFamiliar", "zootGraftedHandLeftFamiliar", "zootGraftedHandRightFamiliar", "zootGraftedHeadFamiliar", "zootGraftedNippleLeftFamiliar", "zootGraftedNippleRightFamiliar", "zootGraftedShoulderLeftFamiliar", "zootGraftedShoulderRightFamiliar"];
const familiarNumericProperties = ["cupidBowLastFamiliar", "zootGraftedButtCheekLeftFamiliar", "zootGraftedButtCheekRightFamiliar", "zootGraftedFootLeftFamiliar", "zootGraftedFootRightFamiliar", "zootGraftedHandLeftFamiliar", "zootGraftedHandRightFamiliar", "zootGraftedHeadFamiliar", "zootGraftedNippleLeftFamiliar", "zootGraftedNippleRightFamiliar", "zootGraftedShoulderLeftFamiliar", "zootGraftedShoulderRightFamiliar"];
const statProperties = ["nsChallenge1", "snojoSetting"];
const phylumProperties = ["dnaSyringe", "locketPhylum", "redSnapperPhylum", "_circadianRhythmsPhylum"];
const itemProperties = ["commerceGhostItem", "daycareInstructorItem", "doctorBagQuestItem", "dolphinItem", "guzzlrQuestBooze", "implementGlitchItem", "muffinOnOrder", "rufusDesiredArtifact", "rufusDesiredItems", "shenQuestItem", "trapperOre", "walfordBucketItem", "_cookbookbatQuestIngredient", "_dailySpecial", "_pirateRealmCurio"];
const itemNumericProperties = ["daycareInstructorItem"];
const booleanPropertiesSet = new Set(booleanProperties);
const numericPropertiesSet = new Set(numericProperties);
const numericOrStringPropertiesSet = new Set(numericOrStringProperties);
const stringPropertiesSet = new Set(stringProperties);
const locationPropertiesSet = new Set(locationProperties);
const monsterPropertiesSet = new Set(monsterProperties);
const familiarPropertiesSet = new Set(familiarProperties);
const statPropertiesSet = new Set(statProperties);
const phylumPropertiesSet = new Set(phylumProperties);
const itemPropertiesSet = new Set(itemProperties);
function isBooleanProperty(property) {
  return booleanPropertiesSet.has(property);
}
function isNumericProperty(property) {
  return numericPropertiesSet.has(property);
}
function isNumericOrStringProperty(property) {
  return numericOrStringPropertiesSet.has(property);
}
function isStringProperty(property) {
  return stringPropertiesSet.has(property);
}
function isLocationProperty(property) {
  return locationPropertiesSet.has(property);
}
function isMonsterProperty(property) {
  return monsterPropertiesSet.has(property);
}
function isFamiliarProperty(property) {
  return familiarPropertiesSet.has(property);
}
function isStatProperty(property) {
  return statPropertiesSet.has(property);
}
function isPhylumProperty(property) {
  return phylumPropertiesSet.has(property);
}
function isItemProperty(property) {
  return itemPropertiesSet.has(property);
}
const createPropertyGetter = (transform2) => (property, default_) => {
  const value = getProperty(property);
  if (default_ !== void 0 && value === "") {
    return default_;
  }
  return transform2(value, property);
};
function createMafiaClassPropertyGetter(Type, toType, numericPropertyNames = []) {
  return createPropertyGetter((value, property) => {
    if (value === "")
      return null;
    const v2 = numericPropertyNames.includes(property) ? value.match(/^[0-9]+$/) ? toType(parseInt(value)) : null : toType(value);
    return v2 === Type.none ? null : v2;
  });
}
const getString = createPropertyGetter((value) => value);
const getBoolean = createPropertyGetter((value) => value === "true");
const getNumber = createPropertyGetter((value) => Number(value));
const getFamiliar = createMafiaClassPropertyGetter(Familiar, toFamiliar, familiarNumericProperties);
const getItem = createMafiaClassPropertyGetter(Item, toItem, itemNumericProperties);
const getLocation = createMafiaClassPropertyGetter(Location, toLocation);
const getMonster = createMafiaClassPropertyGetter(Monster, toMonster, monsterNumericProperties);
const getPhylum = createMafiaClassPropertyGetter(Phylum, toPhylum);
const getStat = createMafiaClassPropertyGetter(Stat, toStat);
function get$1(property, _default) {
  const value = getString(property);
  if (isBooleanProperty(property)) {
    return getBoolean(property, _default) ?? false;
  } else if (isNumericProperty(property)) {
    return getNumber(property, _default) ?? 0;
  } else if (isNumericOrStringProperty(property)) {
    return value.match(/^\d+$/) ? parseInt(value) : value;
  } else if (isLocationProperty(property)) {
    return getLocation(property, _default);
  } else if (isMonsterProperty(property)) {
    return getMonster(property, _default);
  } else if (isFamiliarProperty(property)) {
    return getFamiliar(property, _default);
  } else if (isStatProperty(property)) {
    return getStat(property, _default);
  } else if (isPhylumProperty(property)) {
    return getPhylum(property, _default);
  } else if (isItemProperty(property)) {
    return getItem(property, _default);
  } else if (isStringProperty(property)) {
    return value === "" && _default !== void 0 ? _default : value;
  }
  if (_default instanceof Location) {
    return getLocation(property, _default);
  } else if (_default instanceof Monster) {
    return getMonster(property, _default);
  } else if (_default instanceof Familiar) {
    return getFamiliar(property, _default);
  } else if (_default instanceof Stat) {
    return getStat(property, _default);
  } else if (_default instanceof Phylum) {
    return getPhylum(property, _default);
  } else if (_default instanceof Item) {
    return getItem(property, _default);
  } else if (typeof _default === "boolean") {
    return value === "true" ? true : value === "false" ? false : _default;
  } else if (typeof _default === "number") {
    return value === "" ? _default : parseInt(value);
  } else if (value === "") {
    return _default === void 0 ? "" : _default;
  } else {
    return value;
  }
}
function clamp(n2, min2, max2) {
  return Math.max(min2, Math.min(max2, n2));
}
function chunk(array, chunkSize) {
  const result = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    result.push(array.slice(i, i + chunkSize));
  }
  return result;
}
function sum(addends, x2) {
  return addends.reduce((subtotal, element) => subtotal + (typeof x2 === "function" ? x2(element) : element[x2]), 0);
}
function sumNumbers(addends) {
  return sum(addends, (x2) => x2);
}
function splitByCommasWithEscapes(str) {
  const returnValue = [];
  let ignoreNext = false;
  let currentString = "";
  for (const char2 of str.split("")) {
    if (char2 === "\\") {
      ignoreNext = true;
    } else {
      if (char2 == "," && !ignoreNext) {
        returnValue.push(currentString.trim());
        currentString = "";
      } else {
        currentString += char2;
      }
      ignoreNext = false;
    }
  }
  returnValue.push(currentString.trim());
  return returnValue;
}
function maxBy(array, optimizer, reverse = false) {
  if (!array.length)
    throw new Error("Cannot call maxBy on an empty array!");
  if (typeof optimizer === "function") {
    return [...array].reduce(({ value, item: item2 }, other) => {
      const otherValue = optimizer(other);
      return value >= otherValue !== reverse ? { value, item: item2 } : { value: otherValue, item: other };
    }, { item: array[0], value: optimizer(array[0]) }).item;
  } else {
    return array.reduce((a, b2) => a[optimizer] >= b2[optimizer] !== reverse ? a : b2);
  }
}
function tuple(...args) {
  return args;
}
function undelay(delayedObject, ...args) {
  return typeof delayedObject === "function" ? delayedObject(...args) : delayedObject;
}
function makeByXFunction(source) {
  return function(options, alternateSource) {
    const val = undelay(alternateSource ?? source);
    if ("default" in options)
      return options[val] ?? options.default;
    return options[val];
  };
}
const concatTemplateString = (literals, ...placeholders) => literals.raw.reduce((acc, literal, i) => acc + literal + (placeholders[i] ?? ""), "");
const handleTypeGetError = (Type, error) => {
  const message = `${error}`;
  const match2 = message.match(RegExp(`Bad ${Type.name.toLowerCase()} value: .*`));
  if (match2) {
    print(`${match2[0]}; if you're certain that this ${Type.name} exists and is spelled correctly, please update KoLMafia`, "red");
  } else {
    print(message);
  }
};
const createSingleConstant = (Type, converter) => {
  const tagFunction = (literals, ...placeholders) => {
    const input = concatTemplateString(literals, ...placeholders);
    try {
      return Type.get(input);
    } catch (error) {
      handleTypeGetError(Type, error);
    }
    abort();
  };
  tagFunction.cls = Type;
  tagFunction.none = Type.none;
  tagFunction.get = (name) => {
    const value = converter(name);
    return value === Type.none ? null : value;
  };
  return tagFunction;
};
const createPluralConstant = (Type) => {
  const tagFunction = (literals, ...placeholders) => {
    const input = concatTemplateString(literals, ...placeholders);
    if (input === "") {
      return Type.all();
    }
    try {
      return Type.get(splitByCommasWithEscapes(input));
    } catch (error) {
      handleTypeGetError(Type, error);
    }
    abort();
  };
  tagFunction.all = () => Type.all();
  return tagFunction;
};
createSingleConstant(Bounty, toBounty);
createPluralConstant(Bounty);
const $class = createSingleConstant(Class, toClass);
const $classes = createPluralConstant(Class);
createSingleConstant(Coinmaster, toCoinmaster);
createPluralConstant(Coinmaster);
const $effect = createSingleConstant(Effect, toEffect);
const $effects = createPluralConstant(Effect);
const $element = createSingleConstant(Element$1, toElement);
createPluralConstant(Element$1);
const $familiar = createSingleConstant(Familiar, toFamiliar);
const $familiars = createPluralConstant(Familiar);
const $item = createSingleConstant(Item, toItem);
const $items = createPluralConstant(Item);
const $location = createSingleConstant(Location, toLocation);
const $locations = createPluralConstant(Location);
createSingleConstant(Modifier, toModifier);
createPluralConstant(Modifier);
const $monster = createSingleConstant(Monster, toMonster);
const $monsters = createPluralConstant(Monster);
const $path = createSingleConstant(Path, toPath);
const $paths = createPluralConstant(Path);
createSingleConstant(Phylum, toPhylum);
createPluralConstant(Phylum);
createSingleConstant(Servant, toServant);
createPluralConstant(Servant);
const $skill = createSingleConstant(Skill, toSkill);
const $skills = createPluralConstant(Skill);
const $slot = createSingleConstant(Slot, toSlot);
createPluralConstant(Slot);
const $stat = createSingleConstant(Stat, toStat);
createPluralConstant(Stat);
createSingleConstant(Thrall, toThrall);
createPluralConstant(Thrall);
function getMonsterLocations(monster) {
  return Location.all().filter((location) => monster.name in appearanceRates(location));
}
function have$b(thing, quantity = 1) {
  if (thing instanceof Effect) {
    return haveEffect(thing) >= quantity;
  }
  if (thing instanceof Familiar) {
    return haveFamiliar(thing);
  }
  if (thing instanceof Item) {
    return availableAmount(thing) >= quantity;
  }
  if (thing instanceof Servant) {
    return haveServant(thing);
  }
  if (thing instanceof Skill) {
    return haveSkill(thing);
  }
  if (thing instanceof Thrall) {
    const thrall = myThrall();
    return thrall.id === thing.id && thrall.level >= quantity;
  }
  return false;
}
function haveInCampground(item2) {
  return Object.keys(getCampground()).map((i) => Item.get(i)).includes(item2);
}
var Wanderer;
(function(Wanderer2) {
  Wanderer2["Digitize"] = "Digitize Monster";
  Wanderer2["Enamorang"] = "Enamorang Monster";
  Wanderer2["Familiar"] = "Familiar";
  Wanderer2["Holiday"] = "Holiday Monster";
  Wanderer2["Kramco"] = "Kramco";
  Wanderer2["Nemesis"] = "Nemesis Assassin";
  Wanderer2["Portscan"] = "portscan.edu";
  Wanderer2["Romantic"] = "Romantic Monster";
  Wanderer2["Vote"] = "Vote Monster";
})(Wanderer || (Wanderer = {}));
[Wanderer.Digitize, Wanderer.Portscan];
function getKramcoWandererChance() {
  const fights = get$1("_sausageFights");
  const lastFight = get$1("_lastSausageMonsterTurn");
  const totalTurns = totalTurnsPlayed();
  if (fights < 1) {
    return lastFight === totalTurns && myTurncount() < 1 ? 0.5 : 1;
  }
  const turnsSinceLastFight = totalTurns - lastFight;
  return Math.min(1, (turnsSinceLastFight + 1) / (5 + fights * 3 + Math.max(0, fights - 5) ** 3));
}
function isCurrentFamiliar(familiar) {
  return myFamiliar() === familiar;
}
const banishSource = (banisher) => {
  if (banisher.toLowerCase() === "saber force")
    return $skill`Use the Force`;
  if (banisher.toLowerCase() === "nanorhino")
    return $skill`Unleash Nanites`;
  const item2 = toItem(banisher);
  if ($items`none, training scroll:  Snokebomb, tomayohawk-style reflex hammer`.includes(item2)) {
    return toSkill(banisher);
  }
  return item2;
};
function multiSplit(prop, outerDelimiter, innerDelimiter, mappers) {
  const initialSplit = get$1(prop).split(outerDelimiter).filter(Boolean);
  const multiDimensionalArray = chunk(initialSplit, mappers.length);
  return multiDimensionalArray.map((tup) => mappers.map((func, index) => func(tup[index])));
}
function getBanishedMonsters() {
  return new Map(multiSplit("banishedMonsters", ":", ":", [
    toMonster,
    banishSource,
    Number
  ]).map(([monster, source]) => [source, monster]));
}
function questStep(questName) {
  const stringStep = get$1(questName);
  if (stringStep === "unstarted")
    return -1;
  else if (stringStep === "started")
    return 0;
  else if (stringStep === "finished" || stringStep === "")
    return 999;
  else {
    if (stringStep.substring(0, 4) !== "step") {
      throw new Error("Quest state parsing error.");
    }
    return parseInt(stringStep.substring(4), 10);
  }
}
const holidayWanderers = /* @__PURE__ */ new Map([
  [
    "El Dia De Los Muertos Borrachos",
    $monsters`Novia Cadver, Novio Cadver, Padre Cadver, Persona Inocente Cadver`
  ],
  [
    "Feast of Boris",
    $monsters`Candied Yam Golem, Malevolent Tofurkey, Possessed Can of Cranberry Sauce, Stuffing Golem`
  ],
  [
    "Talk Like a Pirate Day",
    $monsters`ambulatory pirate, migratory pirate, peripatetic pirate`
  ]
]);
function getTodaysHolidayWanderers() {
  return holiday().split("/").flatMap((holiday2) => holidayWanderers.get(holiday2) ?? []);
}
/* @__PURE__ */ new Map([
  [
    "standing around flexing their muscles and using grip exercisers",
    $stat`Muscle`
  ],
  [
    "sitting around playing chess and solving complicated-looking logic puzzles",
    $stat`Mysticality`
  ],
  ["all wearing sunglasses and dancing", $stat`Moxie`]
]);
/* @__PURE__ */ new Map([
  ["people, all of whom appear to be on fire", $element`hot`],
  ["people, surrounded by a cloud of eldritch mist", $element`spooky`],
  ["greasy-looking people furtively skulking around", $element`sleaze`],
  ["people, surrounded by garbage and clouds of flies", $element`stench`],
  ["people, clustered around a group of igloos", $element`cold`]
]);
/* @__PURE__ */ new Map([
  ["smoldering bushes on the outskirts of a hedge maze", $element`hot`],
  [
    "creepy-looking black bushes on the outskirts of a hedge maze",
    $element`spooky`
  ],
  ["purplish, greasy-looking hedges", $element`sleaze`],
  [
    "nasty-looking, dripping green bushes on the outskirts of a hedge maze",
    $element`stench`
  ],
  ["frost-rimed bushes on the outskirts of a hedge maze", $element`cold`]
]);
/* @__PURE__ */ new Map([
  ["smoke rising from deeper within the maze", $element`hot`],
  [
    "a miasma of eldritch vapors rising from deeper within the maze",
    $element`spooky`
  ],
  [
    "a greasy purple cloud hanging over the center of the maze",
    $element`sleaze`
  ],
  ["a cloud of green gas hovering over the maze", $element`stench`],
  ["wintry mists rising from deeper within the maze", $element`cold`]
]);
/* @__PURE__ */ new Map([
  ["with lava slowly oozing out of it", $element`hot`],
  ["surrounded by creepy black mist", $element`spooky`],
  ["that occasionally vomits out a greasy ball of hair", $element`sleaze`],
  ["disgorging a really surprising amount of sewage", $element`stench`],
  ["occasionally disgorging a bunch of ice cubes", $element`cold`]
]);
const byStat = makeByXFunction(() => myPrimestat().toString());
function gameDay() {
  const [, year, month, day] = (todayToString().match(/(\d{4})(\d{2})(\d{2})/) ?? []).map(Number);
  return new Date(year, month - 1, day, 0, 0, 0);
}
function freeCrafts(type = "all") {
  const effectCrafts = (effect2) => Math.floor(haveEffect(effect2) / 5);
  const all = (have$b($skill`Rapid Prototyping`) ? 5 - get$1("_rapidPrototypingUsed") : 0) + (have$b($skill`Expert Corner-Cutter`) ? 5 - get$1("_expertCornerCutterUsed") : 0) + effectCrafts($effect`Inigo's Incantation of Inspiration`) + effectCrafts($effect`Craft Tea`) + effectCrafts($effect`Cooking Concentrate`);
  const food = type === "food" ? 5 - get$1("_cookbookbatCrafting") : 0;
  const smith = type === "smith" ? 5 - get$1("_thorsPliersCrafting") : 0;
  const booze = 0;
  return all + food + smith + booze;
}
function totalFamiliarWeight(familiar = myFamiliar(), considerAdjustment = true) {
  return clamp(familiarWeight(familiar), have$b($effect`Fidoxene`) ? 20 : 0, Infinity) + familiar.soupWeight + (considerAdjustment ? weightAdjustment() : 0) + (familiar.feasted ? 10 : 0);
}
const regularFamiliarTags = Object.freeze([
  "animal",
  "insect",
  "haseyes",
  "haswings",
  "fast",
  "bite",
  "flies",
  "hashands",
  "wearsclothes",
  "organic",
  "vegetable",
  "hovers",
  "edible",
  "food",
  "sentient",
  "cute",
  "mineral",
  "polygonal",
  "object",
  "undead",
  "cantalk",
  "evil",
  "orb",
  "spooky",
  "sleaze",
  "aquatic",
  "swims",
  "isclothes",
  "phallic",
  "stench",
  "hot",
  "hasbeak",
  "haslegs",
  "robot",
  "technological",
  "hard",
  "cold",
  "hasbones",
  "hasclaws",
  "reallyevil",
  "good",
  "person",
  "humanoid",
  "animatedart",
  "software",
  "hasshell",
  "hasstinger"
]);
new Set(regularFamiliarTags);
/* @__PURE__ */ new Map([
  [$familiar`Nursine`, ["ult_bearhug"]],
  [$familiar`Caramel`, ["ult_sticktreats"]],
  [$familiar`Smashmoth`, ["ult_owlstare"]],
  [$familiar`Slotter`, ["ult_bloodbath"]],
  [$familiar`Cornbeefadon`, ["ult_pepperscorn"]],
  [$familiar`Mu`, ["ult_rainbowstorm"]]
]);
const stringModifiers = ["Class", "Intrinsic Effect", "Equalize", "Wiki Name", "Modifiers", "Outfit", "Stat Tuning", "Effect", "Equips On", "Familiar Effect", "Jiggle", "Equalize Muscle", "Equalize Mysticality", "Equalize Moxie", "Avatar", "Rollover Effect", "Skill", "Floor Buffed Muscle", "Floor Buffed Mysticality", "Floor Buffed Moxie", "Plumber Stat", "Recipe", "Evaluated Modifiers"];
const stringModifiersSet = new Set(stringModifiers);
const booleanModifiers = ["Softcore Only", "Single Equip", "Always Fumble", "Never Fumble", "Weakens Monster", "Free Pull", "Variable", "Nonstackable Watch", "Cold Immunity", "Hot Immunity", "Sleaze Immunity", "Spooky Immunity", "Stench Immunity", "Cold Vulnerability", "Hot Vulnerability", "Sleaze Vulnerability", "Spooky Vulnerability", "Stench Vulnerability", "Moxie Controls MP", "Moxie May Control MP", "Four Songs", "Adventure Randomly", "Adventure Underwater", "Underwater Familiar", "Generic", "Unarmed", "No Pull", "Lasts Until Rollover", "Alters Page Text", "Attacks Can't Miss", "Pirate", "Blind", "Breakable", "Drops Items", "Drops Meat", "Volleyball or Sombrero", "Extra Pickpocket", "Negative Status Resist"];
const booleanModifiersSet = new Set(booleanModifiers);
const numericModifiers = ["Familiar Weight", "Monster Level", "Combat Rate", "Initiative", "Experience", "Item Drop", "Meat Drop", "Damage Absorption", "Damage Reduction", "Cold Resistance", "Hot Resistance", "Sleaze Resistance", "Spooky Resistance", "Stench Resistance", "Mana Cost", "Moxie", "Moxie Percent", "Muscle", "Muscle Percent", "Mysticality", "Mysticality Percent", "Maximum HP", "Maximum HP Percent", "Maximum MP", "Maximum MP Percent", "Weapon Damage", "Ranged Damage", "Spell Damage", "Spell Damage Percent", "Cold Damage", "Hot Damage", "Sleaze Damage", "Spooky Damage", "Stench Damage", "Cold Spell Damage", "Hot Spell Damage", "Sleaze Spell Damage", "Spooky Spell Damage", "Stench Spell Damage", "Underwater Combat Rate", "Fumble", "HP Regen Min", "HP Regen Max", "MP Regen Min", "MP Regen Max", "Adventures", "Familiar Weight Percent", "Weapon Damage Percent", "Ranged Damage Percent", "Stackable Mana Cost", "Hobo Power", "Base Resting HP", "Resting HP Percent", "Bonus Resting HP", "Base Resting MP", "Resting MP Percent", "Bonus Resting MP", "Critical Hit Percent", "PvP Fights", "Volleyball", "Sombrero", "Leprechaun", "Fairy", "Meat Drop Penalty", "Hidden Familiar Weight", "Item Drop Penalty", "Initiative Penalty", "Food Drop", "Booze Drop", "Hat Drop", "Weapon Drop", "Offhand Drop", "Shirt Drop", "Pants Drop", "Accessory Drop", "Volleyball Effectiveness", "Sombrero Effectiveness", "Leprechaun Effectiveness", "Fairy Effectiveness", "Familiar Weight Cap", "Slime Resistance", "Slime Hates It", "Spell Critical Percent", "Muscle Experience", "Mysticality Experience", "Moxie Experience", "Effect Duration", "Candy Drop", "DB Combat Damage", "Sombrero Bonus", "Familiar Experience", "Sporadic Meat Drop", "Sporadic Item Drop", "Meat Bonus", "Pickpocket Chance", "Combat Mana Cost", "Muscle Experience Percent", "Mysticality Experience Percent", "Moxie Experience Percent", "Minstrel Level", "Muscle Limit", "Mysticality Limit", "Moxie Limit", "Song Duration", "Prismatic Damage", "Smithsness", "Supercold Resistance", "Reduce Enemy Defense", "Pool Skill", "Familiar Damage", "Gear Drop", "Maximum Hooch", "Water Level", "Crimbot Outfit Power", "Familiar Tuning Muscle", "Familiar Tuning Mysticality", "Familiar Tuning Moxie", "Random Monster Modifiers", "Luck", "Othello Skill", "Disco Style", "Rollover Effect Duration", "Sixgun Damage", "Fishing Skill", "Additional Song", "Sprinkle Drop", "Absorb Adventures", "Absorb Stats", "Rubee Drop", "Kruegerand Drop", "WarBear Armor Penetration", "Maximum PP", "Plumber Power", "Drippy Damage", "Drippy Resistance", "Energy", "Scrap", "Familiar Action Bonus", "Water", "Spleen Drop", "Potion Drop", "Sauce Spell Damage", "Monster Level Percent", "Food Fairy", "Booze Fairy", "Candy Fairy", "Food Fairy Effectiveness", "Booze Fairy Effectiveness", "Candy Fairy Effectiveness", "Damage Aura", "Sporadic Damage Aura", "Thorns", "Sporadic Thorns", "Stomach Capacity", "Liver Capacity", "Spleen Capacity", "Free Rests", "Leaves", "Elf Warfare Effectiveness", "Pirate Warfare Effectiveness", "MPC Drop", "Piece of Twelve Drop", "Combat Item Damage Percent", "Avoid Attack", "Damage vs. Bugbears", "Damage vs. Werewolves", "Damage vs. Zombies", "Damage vs. Ghosts", "Damage vs. Vampires", "Damage vs. Skeletons", "Damage vs. Undead"];
const numericModifiersSet = new Set(numericModifiers);
function isBooleanModifier(modifier) {
  return booleanModifiersSet.has(modifier);
}
function isNumericModifier(modifier) {
  return numericModifiersSet.has(modifier);
}
function isStringModifier(modifier) {
  return stringModifiersSet.has(modifier);
}
function get(name, subject) {
  if (isBooleanModifier(name)) {
    return subject === void 0 ? booleanModifier(name) : booleanModifier(subject, name);
  }
  if (isNumericModifier(name)) {
    return subject === void 0 ? numericModifier(name) : numericModifier(subject, name);
  }
  if (isStringModifier(name)) {
    return subject === void 0 ? stringModifier(name) : stringModifier(subject, name);
  }
}
function have$a() {
  return get$1("chateauAvailable");
}
function getCardsDrawn() {
  return clamp(get$1("_deckCardsDrawn"), 0, 15);
}
function getRemainingDraws() {
  return 15 - getCardsDrawn();
}
function getRemainingCheats() {
  return Math.floor(getRemainingDraws() / 5);
}
function getCardsSeen() {
  return get$1("_deckCardsSeen") ? get$1("_deckCardsSeen").split("|") : [];
}
$item`Source terminal`;
({
  Items: $effect`items.enh`,
  Meat: $effect`meat.enh`,
  Init: $effect`init.enh`,
  Critical: $effect`critical.enh`,
  Damage: $effect`damage.enh`,
  Substats: $effect`substats.enh`
});
({
  /** +5 Familiar Weight */
  Familiar: $effect`familiar.enq`,
  /** +25 ML */
  Monsters: $effect`monsters.enq`,
  /** +5 Prismatic Resistance */
  Protect: $effect`protect.enq`,
  /** +100% Muscle, +100% Mysticality, +100% Moxie */
  Stats: $effect`stats.enq`
});
const Skills = {
  /** Collect Source essence from enemies once per combat */
  Extract: $skill`Extract`,
  /** Stagger and create a wandering monster 1-3 times per day */
  Digitize: $skill`Digitize`,
  /** Stagger and deal 25% of enemy HP in damage once per combat */
  Compress: $skill`Compress`,
  /** Double monster's HP, attack, defence, attacks per round and item drops once per fight and once per day (five in The Source) */
  Duplicate: $skill`Duplicate`,
  /** Causes government agent/Source Agent wanderer next turn once per combat and three times per day */
  Portscan: $skill`Portscan`,
  /** Increase Max MP by 100% and recover 1000 MP once per combat with a 30 turn cooldown */
  Turbo: $skill`Turbo`
};
function getSkills() {
  return ["sourceTerminalEducate1", "sourceTerminalEducate2"].map((p2) => get$1(p2)).filter(Boolean).map((s) => Skill.get(s.slice(0, -4)));
}
/* @__PURE__ */ new Map([
  [$item`browser cookie`, "food.ext"],
  [$item`hacked gibson`, "booze.ext"],
  [$item`Source shades`, "goggles.ext"],
  [$item`Source terminal GRAM chip`, "gram.ext"],
  [$item`Source terminal PRAM chip`, "pram.ext"],
  [$item`Source terminal SPAM chip`, "spam.ext"],
  [$item`Source terminal CRAM chip`, "cram.ext"],
  [$item`Source terminal DRAM chip`, "dram.ext"],
  [$item`Source terminal TRAM chip`, "tram.ext"],
  [$item`software bug`, "familiar.ext"]
]);
function getChips() {
  return get$1("sourceTerminalChips").split(",");
}
function getDigitizeUses() {
  return get$1("_sourceTerminalDigitizeUses");
}
function getDigitizeMonster() {
  return get$1("_sourceTerminalDigitizeMonster");
}
function getMaximumDigitizeUses() {
  const chips = getChips();
  return 1 + (chips.includes("TRAM") ? 1 : 0) + (chips.includes("TRIGRAM") ? 1 : 0);
}
function getDigitizeUsesRemaining() {
  return getMaximumDigitizeUses() - getDigitizeUses();
}
function getEnhanceUses() {
  return get$1("_sourceTerminalEnhanceUses");
}
function maximumEnhanceUses() {
  return 1 + getChips().filter((chip) => ["CRAM", "SCRAM"].includes(chip)).length;
}
function enhanceUsesRemaining() {
  return maximumEnhanceUses() - getEnhanceUses();
}
function enhanceBuffDuration() {
  return 25 + get$1("sourceTerminalPram") * 5 + (getChips().includes("INGRAM") ? 25 : 0);
}
const item$4 = $item`Witchess Set`;
function have$9() {
  return haveInCampground(item$4);
}
Monster.get([
  "Witchess Pawn",
  "Witchess Knight",
  "Witchess Bishop",
  "Witchess Rook",
  "Witchess Queen",
  "Witchess King",
  "Witchess Witch",
  "Witchess Ox"
]);
function have$8() {
  return get$1("loveTunnelAvailable");
}
function isUsed() {
  return get$1("_loveTunnelUsed");
}
const item$3 = $item`SongBoom BoomBox`;
function have$7() {
  return have$b(item$3);
}
const keywords = {
  "Eye of the Giger": "spooky",
  "Food Vibrations": "food",
  "Remainin' Alive": "dr",
  "These Fists Were Made for Punchin'": "damage",
  "Total Eclipse of Your Meat": "meat"
};
const songBoomSongs = new Set(Object.keys(keywords));
function song() {
  const stored = get$1("boomBoxSong");
  return songBoomSongs.has(stored) ? stored : null;
}
function songChangesLeft() {
  return get$1("_boomBoxSongsLeft");
}
$item`Daylight Shavings Helmet`;
const buffs = $effects`Spectacle Moustache, Toiletbrush Moustache, Barbell Moustache, Grizzly Beard, Surrealist's Moustache, Musician's Musician's Moustache, Gull-Wing Moustache, Space Warlord's Beard, Pointy Wizard Beard, Cowboy Stache, Friendly Chops`;
function buffCycle(playerclass = myClass()) {
  const cycle = tuple(Effect.none, Effect.none, Effect.none, Effect.none, Effect.none, Effect.none, Effect.none, Effect.none, Effect.none, Effect.none, Effect.none);
  if (playerclass.id <= 0)
    return cycle;
  const id2 = playerclass.id;
  const seed = id2 > 6 ? id2 % 6 + 1 : id2;
  for (let i = 1; i < 12; i++) {
    const index = i * seed % 11;
    cycle[i - 1] = buffs[index];
  }
  return cycle;
}
function nextBuff() {
  const currentBuff = toEffect(get$1("lastBeardBuff").toFixed(0));
  const cycle = buffCycle();
  const index = cycle.indexOf(currentBuff);
  const newIndex = (1 + index) % 11;
  return cycle[newIndex];
}
function buffsUntil(buff) {
  if (!buffs.includes(buff))
    return null;
  const currentIndex = buffs.indexOf(nextBuff()) - 1;
  const newIndex = buffs.indexOf(buff);
  const diff = (newIndex - currentIndex) % 11;
  return diff === 0 ? 11 : diff;
}
const item$2 = Item.get("autumn-aton");
function available$1() {
  return availableAmount(item$2) > 0;
}
function have$6() {
  return get$1("hasAutumnaton") || available$1();
}
function currentlyIn() {
  return get$1("autumnatonQuestLocation");
}
function currentUpgrades() {
  return get$1("autumnatonUpgrades").split(",");
}
function turnsLeft() {
  return get$1("autumnatonQuestTurn") - totalTurnsPlayed();
}
function legs() {
  return currentUpgrades().filter((u2) => u2.includes("leg")).length;
}
function turnsForQuest() {
  return 11 * Math.max(1, get$1("_autumnatonQuests") - legs());
}
function zoneItems() {
  return 3 + currentUpgrades().filter((u2) => u2.includes("arm")).length;
}
({
  outdoor: {
    low: { index: 4, item: $item`autumn leaf` },
    mid: { index: 2, item: $item`autumn debris shield` },
    high: { index: 6, item: $item`autumn leaf pendant` }
  },
  indoor: {
    low: { index: 0, item: $item`AutumnFest ale` },
    mid: { index: 3, item: $item`autumn-spice donut` },
    high: { index: 7, item: $item`autumn breeze` }
  },
  underground: {
    low: { index: 1, item: $item`autumn sweater-weather sweater` },
    mid: { index: 5, item: $item`autumn dollar` },
    high: { index: 8, item: $item`autumn years wisdom` }
  }
});
const locket = $item`combat lover's locket`;
function have$5() {
  return have$b(locket);
}
function parseLocketProperty() {
  return get$1("_locketMonstersFought").split(",").filter((id2) => id2.trim().length > 0);
}
function reminiscesLeft() {
  return have$5() ? clamp(3 - parseLocketProperty().length, 0, 3) : 0;
}
function have$4() {
  return have$b($item`august scepter`);
}
Object.freeze($skills`Aug. 1st: Mountain Climbing Day!, Aug. 2nd: Find an Eleven-Leaf Clover Day, Aug. 3rd: Watermelon Day!, Aug. 4th: Water Balloon Day!, Aug. 5th: Oyster Day!, Aug. 6th: Fresh Breath Day!, Aug. 7th: Lighthouse Day!, Aug. 8th: Cat Day!, Aug. 9th: Hand Holding Day!, Aug. 10th: World Lion Day!, Aug. 11th: Presidential Joke Day!, Aug. 12th: Elephant Day!, Aug. 13th: Left/Off Hander's Day!, Aug. 14th: Financial Awareness  Day!, Aug. 15th: Relaxation Day!, Aug. 16th: Roller Coaster Day!, Aug. 17th: Thriftshop Day!, Aug. 18th: Serendipity Day!, Aug. 19th: Honey Bee Awareness Day!, Aug. 20th: Mosquito Day!, Aug. 21st: Spumoni Day!, Aug. 22nd: Tooth Fairy Day!, Aug. 23rd: Ride the Wind Day!, Aug. 24th: Waffle Day!, Aug. 25th: Banana Split Day!, Aug. 26th: Toilet Paper Day!, Aug. 27th: Just Because Day!, Aug. 28th: Race Your Mouse Day!, Aug. 29th: More Herbs\, Less Salt  Day!, Aug. 30th: Beach Day!, Aug. 31st: Cabernet Sauvignon  Day!`);
function getTodayCast() {
  return get$1("_augTodayCast");
}
function canCast(skillNum) {
  return have$4() && !get$1(`_aug${skillNum}Cast`) && (gameDay().getDate() === skillNum && !getTodayCast() || get$1(`_augSkillsCast`) < 5);
}
const item$1 = $item`A Guide to Burning Leaves`;
/* @__PURE__ */ new Map([
  [$monster`flaming leaflet`, 11],
  [$item`autumnic bomb`, 37],
  [$item`impromptu torch`, 42],
  [$item`flaming fig leaf`, 43],
  [$item`smoldering drape`, 44],
  [$item`distilled resin`, 50],
  [$item`autumnal aegis`, 66],
  [$item`lit leaf lasso`, 69],
  [$item`forest canopy bed`, 74],
  [$item`autumnic balm`, 99],
  [$monster`flaming monstera`, 111],
  [$item`day shortener`, 222],
  [$monster`leaviathan`, 666],
  [$item`coping juice`, 1111],
  [$item`smoldering leafcutter ant egg`, 6666],
  [$item`super-heated leaf`, 11111]
]);
function have$3() {
  return haveInCampground(item$1);
}
const cincho = $item`Cincho de Mayo`;
function have$2() {
  return have$b(cincho);
}
function currentCinch() {
  return have$2() ? clamp(100 - get$1("_cinchUsed"), 0, 100) : 0;
}
function cinchRestoredBy(currentRests = get$1("_cinchoRests")) {
  return have$2() ? clamp(50 - currentRests * 5, 5, 30) : 0;
}
function totalAvailableCinch() {
  const remainingRests = Math.max(0, totalFreeRests() - get$1("timesRested"));
  return have$2() ? currentCinch() + sum(new Array(remainingRests).fill(null).map((_, i) => i + get$1("_cinchoRests")), (restNumber) => cinchRestoredBy(restNumber)) : 0;
}
({
  SaltAndLime: $skill`Cincho: Dispense Salt and Lime`,
  PartySoundtrack: $skill`Cincho: Party Soundtrack`,
  FiestaExit: $skill`Cincho: Fiesta Exit`,
  ProjectilePiata: $skill`Cincho: Projectile Piata`,
  PartyFoul: $skill`Cincho: Party Foul`,
  ConfettiExtrava: $skill`Cincho: Confetti Extravaganza`
});
const item = $item`cursed monkey's paw`;
function have$1() {
  return have$b(item);
}
function wishes() {
  return clamp(5 - get$1("_monkeyPawWishesUsed"), 0, 5);
}
const RINGS = Object.freeze([
  ["yam1", "sword", "eye", "chair", "fur", "vessel"],
  ["lightning", "bottle", "meat", "wood", "yam2"],
  ["yam3", "wall", "cheese", "eyepatch"],
  ["explosion", "clock", "yam4"]
]);
function have() {
  return have$b($item`Mayam Calendar`);
}
function symbolsUsed() {
  return get$1("_mayamSymbolsUsed").split(",");
}
function available(...symbols) {
  return symbols.every((symbol) => !symbolsUsed().includes(symbol));
}
function remainingUses() {
  return RINGS[3].filter((symbol) => available(symbol)).length;
}
Object.freeze({
  "eye yam2 eyepatch yam4": $item`Mayam spinach`,
  "vessel yam2 cheese explosion": $item`stuffed yam stinkbomb`,
  "yam1 meat cheese yam4": $item`yam and swiss`,
  "sword yam2 eyepatch explosion": $item`yam cannon`,
  "fur lightning eyepatch yam4": $item`tiny yam cannon`,
  "yam1 lightning yam3 clock": $item`yam battery`,
  "fur yam2 wall yam4": $item`furry yam buckler`,
  "yam1 yam2 yam3 explosion": $item`thanksgiving bomb`,
  "yam1 meat eyepatch yam4": $item`yamtility belt`,
  "chair yam2 yam3 clock": $effect`Caught Yam-Handed`,
  "yam1 yam2 cheese clock": $effect`Memories of Cheesier Age`
});
const NEEDS = Object.freeze([
  "exercise",
  "mental stimulation",
  "dumb entertainment",
  "food",
  "booze",
  "sleep"
]);
const FURNITURE_PIECES = Object.freeze([
  "empty",
  "buckets of concrete",
  "thrift store oil painting",
  "boxes of old comic books",
  "second-hand hot plate",
  "beer cooler",
  "free mattress",
  "gigantic chess set",
  "UltraDance karaoke machine",
  "cupcake treadmill",
  "beer pong table",
  "padded weight bench",
  "internet-connected laptop",
  "sous vide laboratory",
  "programmable blender",
  "sensory deprivation tank",
  "fruit-smashing robot",
  "ManCave sports bar set",
  "couch and flatscreen",
  "kegerator",
  "fine upholstered dining set",
  "whiskeybed",
  "high-end home workout system",
  "complete classics library",
  "ultimate retro game console",
  "Omnipot",
  "fully-stocked wet bar",
  "four-poster bed"
]);
const Furniture = Object.freeze({
  "beer cooler": {
    booze: $items`beer bomb, bloody beer, ice-cold fotie, ice-cold Sir Schlitz, ice-cold Willer, overpriced "imported" beer, plain old beer`
  },
  "beer pong table": {
    booze: $items`beer bomb, bloody beer, ice-cold fotie, ice-cold Sir Schlitz, ice-cold Willer, overpriced "imported" beer, plain old beer`,
    exercise: $item`table tennis ball`
  },
  "boxes of old comic books": {
    "dumb entertainment": { effect: $effect`Wasting Time`, duration: 10 }
  },
  "buckets of concrete": {
    exercise: { effect: $effect`Gym Bros`, duration: 10 }
  },
  "complete classics library": {
    "mental stimulation": $item`leprechaun antidepressant pill`
  },
  "couch and flatscreen": {
    "dumb entertainment": {
      effect: $effect`Your Days Are Numbed`,
      duration: 10
    },
    sleep: { effect: $effect`Good Night's Sleep`, duration: 10 }
  },
  "cupcake treadmill": {
    exercise: { effect: $effect`Your Days Are Numbed`, duration: 10 },
    food: $item`standard-issue cupcake`
  },
  "fine upholstered dining set": {
    food: $items`boring spaghetti, delicious noodles, goat cheese pizza, sausage pizza, spicy bean burrito, spicy noodles`,
    sleep: { effect: $effect`Sur La Table`, duration: 10 }
  },
  empty: {},
  "four-poster bed": {
    sleep: { effect: $effect`Spacious Night's Sleep`, duration: 10 }
  },
  "free mattress": {
    sleep: { effect: $effect`Good Night's Sleep`, duration: 10 }
  },
  "fruit-smashing robot": {
    "dumb entertainment": {
      effect: $effect`You Might Have Gotten Wet`,
      duration: 10
    },
    food: $items`cherry, cranberries, grapefruit, grapes, kiwi, kumquat, lemon, lime, orange, papaya, raspberry, strawberry, tangerine`
  },
  "fully-stocked wet bar": {
    booze: $items`Divine sidecar, prussian cathouse sidecar, tangarita sidecar`
  },
  "gigantic chess set": {
    exercise: { effect: $effect`Work Out Smarter, Not Harder`, duration: 10 },
    "mental stimulation": { effect: $effect`Well Stimulated`, duration: 10 }
  },
  "high-end home workout system": {
    exercise: $item`scoop of pre-workout powder`
  },
  "internet-connected laptop": {
    "dumb entertainment": { effect: $effect`Wasting Time`, duration: 10 },
    "mental stimulation": $item`crafting plans`
  },
  kegerator: {
    booze: $item`pint of Leprechaun Stout`,
    food: $items`bean burrito, plain pizza, spicy mushroom quesadilla, tofu casserole, Trollhouse cookies`
  },
  "ManCave sports bar set": {
    booze: $items`melted Jell-o shot, shot of blackberry schnapps, shot of nepenthe schnapps, shot of peach schnapps, shot of pear schnapps, shot of rotgut`,
    "dumb entertainment": $item`bar dart`
  },
  Omnipot: {
    food: $items`Heck ramen, incredible mini-pizza, small beer brat, tiny burrito, tiny peach pie, savoy truffle, white chocolate chip brownies`
  },
  "padded weight bench": {
    exercise: { effect: $effect`Gym Bros`, duration: 10 },
    sleep: { effect: $effect`Tired Muscles`, duration: 10 }
  },
  "programmable blender": {
    booze: $items`eggnog, extra-spicy bloody mary, grog, white lightning`,
    "mental stimulation": {
      effect: $effect`Counter Intelligence`,
      duration: 10
    }
  },
  "second-hand hot plate": {
    food: $items`bean burrito, chorizo taco, plain pizza, spicy mushroom quesadilla, tofu casserole, Trollhouse cookies`
  },
  "sensory deprivation tank": {
    "mental stimulation": {
      effect: $effect`Alone with Your Thoughts`,
      duration: 10
    },
    sleep: { effect: $effect`Quiet Night's Sleep`, duration: 10 }
  },
  "sous vide laboratory": {
    food: $items`tiny burrito, black forest ham, fishy fish, ham steak, Knoll stir-fry, spooky stir-fry`,
    "mental stimulation": {
      effect: $effect`Counter Intelligence`,
      duration: 10
    }
  },
  "thrift store oil painting": {
    "mental stimulation": { effect: $effect`Well Stimulated`, duration: 10 }
  },
  "ultimate retro game console": {
    "dumb entertainment": $item`phosphor traces`
  },
  "UltraDance karaoke machine": {
    "dumb entertainment": {
      effect: $effect`Your Days Are Numbed`,
      duration: 10
    },
    exercise: { effect: $effect`Vicarious Sweat`, duration: 10 }
  },
  whiskeybed: {
    booze: $items`Divine sidecar, lumbering jack, old-fashioned, whiskey and cola, whiskey and soda, whiskey bittersweet, whiskey sour`,
    sleep: { effect: $effect`Moist Night's Sleep`, duration: 10 }
  }
});
function rearrangesRemaining() {
  return clamp(3 - get$1("_leprecondoRearrangements"), 0, 3);
}
function currentNeed() {
  return get$1("leprecondoCurrentNeed");
}
function needOrder() {
  return get$1("leprecondoNeedOrder").split(",");
}
function installedFurniture() {
  return get$1("leprecondoInstalled").split(",").map((id2) => FURNITURE_PIECES[Number(id2)]).reverse();
}
function furnitureBonuses(furniture = installedFurniture()) {
  return furniture.reduce((acc, piece) => ({
    ...Furniture[piece],
    ...acc
  }), {});
}
var lib = {};
var namedReferences = {};
Object.defineProperty(namedReferences, "__esModule", { value: true });
namedReferences.bodyRegExps = { xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g };
namedReferences.namedReferences = { xml: { entities: { "&lt;": "<", "&gt;": ">", "&quot;": '"', "&apos;": "'", "&amp;": "&" }, characters: { "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&apos;", "&": "&amp;" } }, html4: { entities: { "&apos;": "'", "&nbsp": "", "&nbsp;": "", "&iexcl": "", "&iexcl;": "", "&cent": "", "&cent;": "", "&pound": "", "&pound;": "", "&curren": "", "&curren;": "", "&yen": "", "&yen;": "", "&brvbar": "", "&brvbar;": "", "&sect": "", "&sect;": "", "&uml": "", "&uml;": "", "&copy": "", "&copy;": "", "&ordf": "", "&ordf;": "", "&laquo": "", "&laquo;": "", "&not": "", "&not;": "", "&shy": "", "&shy;": "", "&reg": "", "&reg;": "", "&macr": "", "&macr;": "", "&deg": "", "&deg;": "", "&plusmn": "", "&plusmn;": "", "&sup2": "", "&sup2;": "", "&sup3": "", "&sup3;": "", "&acute": "", "&acute;": "", "&micro": "", "&micro;": "", "&para": "", "&para;": "", "&middot": "", "&middot;": "", "&cedil": "", "&cedil;": "", "&sup1": "", "&sup1;": "", "&ordm": "", "&ordm;": "", "&raquo": "", "&raquo;": "", "&frac14": "", "&frac14;": "", "&frac12": "", "&frac12;": "", "&frac34": "", "&frac34;": "", "&iquest": "", "&iquest;": "", "&Agrave": "", "&Agrave;": "", "&Aacute": "", "&Aacute;": "", "&Acirc": "", "&Acirc;": "", "&Atilde": "", "&Atilde;": "", "&Auml": "", "&Auml;": "", "&Aring": "", "&Aring;": "", "&AElig": "", "&AElig;": "", "&Ccedil": "", "&Ccedil;": "", "&Egrave": "", "&Egrave;": "", "&Eacute": "", "&Eacute;": "", "&Ecirc": "", "&Ecirc;": "", "&Euml": "", "&Euml;": "", "&Igrave": "", "&Igrave;": "", "&Iacute": "", "&Iacute;": "", "&Icirc": "", "&Icirc;": "", "&Iuml": "", "&Iuml;": "", "&ETH": "", "&ETH;": "", "&Ntilde": "", "&Ntilde;": "", "&Ograve": "", "&Ograve;": "", "&Oacute": "", "&Oacute;": "", "&Ocirc": "", "&Ocirc;": "", "&Otilde": "", "&Otilde;": "", "&Ouml": "", "&Ouml;": "", "&times": "", "&times;": "", "&Oslash": "", "&Oslash;": "", "&Ugrave": "", "&Ugrave;": "", "&Uacute": "", "&Uacute;": "", "&Ucirc": "", "&Ucirc;": "", "&Uuml": "", "&Uuml;": "", "&Yacute": "", "&Yacute;": "", "&THORN": "", "&THORN;": "", "&szlig": "", "&szlig;": "", "&agrave": "", "&agrave;": "", "&aacute": "", "&aacute;": "", "&acirc": "", "&acirc;": "", "&atilde": "", "&atilde;": "", "&auml": "", "&auml;": "", "&aring": "", "&aring;": "", "&aelig": "", "&aelig;": "", "&ccedil": "", "&ccedil;": "", "&egrave": "", "&egrave;": "", "&eacute": "", "&eacute;": "", "&ecirc": "", "&ecirc;": "", "&euml": "", "&euml;": "", "&igrave": "", "&igrave;": "", "&iacute": "", "&iacute;": "", "&icirc": "", "&icirc;": "", "&iuml": "", "&iuml;": "", "&eth": "", "&eth;": "", "&ntilde": "", "&ntilde;": "", "&ograve": "", "&ograve;": "", "&oacute": "", "&oacute;": "", "&ocirc": "", "&ocirc;": "", "&otilde": "", "&otilde;": "", "&ouml": "", "&ouml;": "", "&divide": "", "&divide;": "", "&oslash": "", "&oslash;": "", "&ugrave": "", "&ugrave;": "", "&uacute": "", "&uacute;": "", "&ucirc": "", "&ucirc;": "", "&uuml": "", "&uuml;": "", "&yacute": "", "&yacute;": "", "&thorn": "", "&thorn;": "", "&yuml": "", "&yuml;": "", "&quot": '"', "&quot;": '"', "&amp": "&", "&amp;": "&", "&lt": "<", "&lt;": "<", "&gt": ">", "&gt;": ">", "&OElig;": "", "&oelig;": "", "&Scaron;": "", "&scaron;": "", "&Yuml;": "", "&circ;": "", "&tilde;": "", "&ensp;": "", "&emsp;": "", "&thinsp;": "", "&zwnj;": "", "&zwj;": "", "&lrm;": "", "&rlm;": "", "&ndash;": "", "&mdash;": "", "&lsquo;": "", "&rsquo;": "", "&sbquo;": "", "&ldquo;": "", "&rdquo;": "", "&bdquo;": "", "&dagger;": "", "&Dagger;": "", "&permil;": "", "&lsaquo;": "", "&rsaquo;": "", "&euro;": "", "&fnof;": "", "&Alpha;": "", "&Beta;": "", "&Gamma;": "", "&Delta;": "", "&Epsilon;": "", "&Zeta;": "", "&Eta;": "", "&Theta;": "", "&Iota;": "", "&Kappa;": "", "&Lambda;": "", "&Mu;": "", "&Nu;": "", "&Xi;": "", "&Omicron;": "", "&Pi;": "", "&Rho;": "", "&Sigma;": "", "&Tau;": "", "&Upsilon;": "", "&Phi;": "", "&Chi;": "", "&Psi;": "", "&Omega;": "", "&alpha;": "", "&beta;": "", "&gamma;": "", "&delta;": "", "&epsilon;": "", "&zeta;": "", "&eta;": "", "&theta;": "", "&iota;": "", "&kappa;": "", "&lambda;": "", "&mu;": "", "&nu;": "", "&xi;": "", "&omicron;": "", "&pi;": "", "&rho;": "", "&sigmaf;": "", "&sigma;": "", "&tau;": "", "&upsilon;": "", "&phi;": "", "&chi;": "", "&psi;": "", "&omega;": "", "&thetasym;": "", "&upsih;": "", "&piv;": "", "&bull;": "", "&hellip;": "", "&prime;": "", "&Prime;": "", "&oline;": "", "&frasl;": "", "&weierp;": "", "&image;": "", "&real;": "", "&trade;": "", "&alefsym;": "", "&larr;": "", "&uarr;": "", "&rarr;": "", "&darr;": "", "&harr;": "", "&crarr;": "", "&lArr;": "", "&uArr;": "", "&rArr;": "", "&dArr;": "", "&hArr;": "", "&forall;": "", "&part;": "", "&exist;": "", "&empty;": "", "&nabla;": "", "&isin;": "", "&notin;": "", "&ni;": "", "&prod;": "", "&sum;": "", "&minus;": "", "&lowast;": "", "&radic;": "", "&prop;": "", "&infin;": "", "&ang;": "", "&and;": "", "&or;": "", "&cap;": "", "&cup;": "", "&int;": "", "&there4;": "", "&sim;": "", "&cong;": "", "&asymp;": "", "&ne;": "", "&equiv;": "", "&le;": "", "&ge;": "", "&sub;": "", "&sup;": "", "&nsub;": "", "&sube;": "", "&supe;": "", "&oplus;": "", "&otimes;": "", "&perp;": "", "&sdot;": "", "&lceil;": "", "&rceil;": "", "&lfloor;": "", "&rfloor;": "", "&lang;": "", "&rang;": "", "&loz;": "", "&spades;": "", "&clubs;": "", "&hearts;": "", "&diams;": "" }, characters: { "'": "&apos;", "": "&nbsp;", "": "&iexcl;", "": "&cent;", "": "&pound;", "": "&curren;", "": "&yen;", "": "&brvbar;", "": "&sect;", "": "&uml;", "": "&copy;", "": "&ordf;", "": "&laquo;", "": "&not;", "": "&shy;", "": "&reg;", "": "&macr;", "": "&deg;", "": "&plusmn;", "": "&sup2;", "": "&sup3;", "": "&acute;", "": "&micro;", "": "&para;", "": "&middot;", "": "&cedil;", "": "&sup1;", "": "&ordm;", "": "&raquo;", "": "&frac14;", "": "&frac12;", "": "&frac34;", "": "&iquest;", "": "&Agrave;", "": "&Aacute;", "": "&Acirc;", "": "&Atilde;", "": "&Auml;", "": "&Aring;", "": "&AElig;", "": "&Ccedil;", "": "&Egrave;", "": "&Eacute;", "": "&Ecirc;", "": "&Euml;", "": "&Igrave;", "": "&Iacute;", "": "&Icirc;", "": "&Iuml;", "": "&ETH;", "": "&Ntilde;", "": "&Ograve;", "": "&Oacute;", "": "&Ocirc;", "": "&Otilde;", "": "&Ouml;", "": "&times;", "": "&Oslash;", "": "&Ugrave;", "": "&Uacute;", "": "&Ucirc;", "": "&Uuml;", "": "&Yacute;", "": "&THORN;", "": "&szlig;", "": "&agrave;", "": "&aacute;", "": "&acirc;", "": "&atilde;", "": "&auml;", "": "&aring;", "": "&aelig;", "": "&ccedil;", "": "&egrave;", "": "&eacute;", "": "&ecirc;", "": "&euml;", "": "&igrave;", "": "&iacute;", "": "&icirc;", "": "&iuml;", "": "&eth;", "": "&ntilde;", "": "&ograve;", "": "&oacute;", "": "&ocirc;", "": "&otilde;", "": "&ouml;", "": "&divide;", "": "&oslash;", "": "&ugrave;", "": "&uacute;", "": "&ucirc;", "": "&uuml;", "": "&yacute;", "": "&thorn;", "": "&yuml;", '"': "&quot;", "&": "&amp;", "<": "&lt;", ">": "&gt;", "": "&OElig;", "": "&oelig;", "": "&Scaron;", "": "&scaron;", "": "&Yuml;", "": "&circ;", "": "&tilde;", "": "&ensp;", "": "&emsp;", "": "&thinsp;", "": "&zwnj;", "": "&zwj;", "": "&lrm;", "": "&rlm;", "": "&ndash;", "": "&mdash;", "": "&lsquo;", "": "&rsquo;", "": "&sbquo;", "": "&ldquo;", "": "&rdquo;", "": "&bdquo;", "": "&dagger;", "": "&Dagger;", "": "&permil;", "": "&lsaquo;", "": "&rsaquo;", "": "&euro;", "": "&fnof;", "": "&Alpha;", "": "&Beta;", "": "&Gamma;", "": "&Delta;", "": "&Epsilon;", "": "&Zeta;", "": "&Eta;", "": "&Theta;", "": "&Iota;", "": "&Kappa;", "": "&Lambda;", "": "&Mu;", "": "&Nu;", "": "&Xi;", "": "&Omicron;", "": "&Pi;", "": "&Rho;", "": "&Sigma;", "": "&Tau;", "": "&Upsilon;", "": "&Phi;", "": "&Chi;", "": "&Psi;", "": "&Omega;", "": "&alpha;", "": "&beta;", "": "&gamma;", "": "&delta;", "": "&epsilon;", "": "&zeta;", "": "&eta;", "": "&theta;", "": "&iota;", "": "&kappa;", "": "&lambda;", "": "&mu;", "": "&nu;", "": "&xi;", "": "&omicron;", "": "&pi;", "": "&rho;", "": "&sigmaf;", "": "&sigma;", "": "&tau;", "": "&upsilon;", "": "&phi;", "": "&chi;", "": "&psi;", "": "&omega;", "": "&thetasym;", "": "&upsih;", "": "&piv;", "": "&bull;", "": "&hellip;", "": "&prime;", "": "&Prime;", "": "&oline;", "": "&frasl;", "": "&weierp;", "": "&image;", "": "&real;", "": "&trade;", "": "&alefsym;", "": "&larr;", "": "&uarr;", "": "&rarr;", "": "&darr;", "": "&harr;", "": "&crarr;", "": "&lArr;", "": "&uArr;", "": "&rArr;", "": "&dArr;", "": "&hArr;", "": "&forall;", "": "&part;", "": "&exist;", "": "&empty;", "": "&nabla;", "": "&isin;", "": "&notin;", "": "&ni;", "": "&prod;", "": "&sum;", "": "&minus;", "": "&lowast;", "": "&radic;", "": "&prop;", "": "&infin;", "": "&ang;", "": "&and;", "": "&or;", "": "&cap;", "": "&cup;", "": "&int;", "": "&there4;", "": "&sim;", "": "&cong;", "": "&asymp;", "": "&ne;", "": "&equiv;", "": "&le;", "": "&ge;", "": "&sub;", "": "&sup;", "": "&nsub;", "": "&sube;", "": "&supe;", "": "&oplus;", "": "&otimes;", "": "&perp;", "": "&sdot;", "": "&lceil;", "": "&rceil;", "": "&lfloor;", "": "&rfloor;", "": "&lang;", "": "&rang;", "": "&loz;", "": "&spades;", "": "&clubs;", "": "&hearts;", "": "&diams;" } }, html5: { entities: { "&AElig": "", "&AElig;": "", "&AMP": "&", "&AMP;": "&", "&Aacute": "", "&Aacute;": "", "&Abreve;": "", "&Acirc": "", "&Acirc;": "", "&Acy;": "", "&Afr;": "", "&Agrave": "", "&Agrave;": "", "&Alpha;": "", "&Amacr;": "", "&And;": "", "&Aogon;": "", "&Aopf;": "", "&ApplyFunction;": "", "&Aring": "", "&Aring;": "", "&Ascr;": "", "&Assign;": "", "&Atilde": "", "&Atilde;": "", "&Auml": "", "&Auml;": "", "&Backslash;": "", "&Barv;": "", "&Barwed;": "", "&Bcy;": "", "&Because;": "", "&Bernoullis;": "", "&Beta;": "", "&Bfr;": "", "&Bopf;": "", "&Breve;": "", "&Bscr;": "", "&Bumpeq;": "", "&CHcy;": "", "&COPY": "", "&COPY;": "", "&Cacute;": "", "&Cap;": "", "&CapitalDifferentialD;": "", "&Cayleys;": "", "&Ccaron;": "", "&Ccedil": "", "&Ccedil;": "", "&Ccirc;": "", "&Cconint;": "", "&Cdot;": "", "&Cedilla;": "", "&CenterDot;": "", "&Cfr;": "", "&Chi;": "", "&CircleDot;": "", "&CircleMinus;": "", "&CirclePlus;": "", "&CircleTimes;": "", "&ClockwiseContourIntegral;": "", "&CloseCurlyDoubleQuote;": "", "&CloseCurlyQuote;": "", "&Colon;": "", "&Colone;": "", "&Congruent;": "", "&Conint;": "", "&ContourIntegral;": "", "&Copf;": "", "&Coproduct;": "", "&CounterClockwiseContourIntegral;": "", "&Cross;": "", "&Cscr;": "", "&Cup;": "", "&CupCap;": "", "&DD;": "", "&DDotrahd;": "", "&DJcy;": "", "&DScy;": "", "&DZcy;": "", "&Dagger;": "", "&Darr;": "", "&Dashv;": "", "&Dcaron;": "", "&Dcy;": "", "&Del;": "", "&Delta;": "", "&Dfr;": "", "&DiacriticalAcute;": "", "&DiacriticalDot;": "", "&DiacriticalDoubleAcute;": "", "&DiacriticalGrave;": "`", "&DiacriticalTilde;": "", "&Diamond;": "", "&DifferentialD;": "", "&Dopf;": "", "&Dot;": "", "&DotDot;": "", "&DotEqual;": "", "&DoubleContourIntegral;": "", "&DoubleDot;": "", "&DoubleDownArrow;": "", "&DoubleLeftArrow;": "", "&DoubleLeftRightArrow;": "", "&DoubleLeftTee;": "", "&DoubleLongLeftArrow;": "", "&DoubleLongLeftRightArrow;": "", "&DoubleLongRightArrow;": "", "&DoubleRightArrow;": "", "&DoubleRightTee;": "", "&DoubleUpArrow;": "", "&DoubleUpDownArrow;": "", "&DoubleVerticalBar;": "", "&DownArrow;": "", "&DownArrowBar;": "", "&DownArrowUpArrow;": "", "&DownBreve;": "", "&DownLeftRightVector;": "", "&DownLeftTeeVector;": "", "&DownLeftVector;": "", "&DownLeftVectorBar;": "", "&DownRightTeeVector;": "", "&DownRightVector;": "", "&DownRightVectorBar;": "", "&DownTee;": "", "&DownTeeArrow;": "", "&Downarrow;": "", "&Dscr;": "", "&Dstrok;": "", "&ENG;": "", "&ETH": "", "&ETH;": "", "&Eacute": "", "&Eacute;": "", "&Ecaron;": "", "&Ecirc": "", "&Ecirc;": "", "&Ecy;": "", "&Edot;": "", "&Efr;": "", "&Egrave": "", "&Egrave;": "", "&Element;": "", "&Emacr;": "", "&EmptySmallSquare;": "", "&EmptyVerySmallSquare;": "", "&Eogon;": "", "&Eopf;": "", "&Epsilon;": "", "&Equal;": "", "&EqualTilde;": "", "&Equilibrium;": "", "&Escr;": "", "&Esim;": "", "&Eta;": "", "&Euml": "", "&Euml;": "", "&Exists;": "", "&ExponentialE;": "", "&Fcy;": "", "&Ffr;": "", "&FilledSmallSquare;": "", "&FilledVerySmallSquare;": "", "&Fopf;": "", "&ForAll;": "", "&Fouriertrf;": "", "&Fscr;": "", "&GJcy;": "", "&GT": ">", "&GT;": ">", "&Gamma;": "", "&Gammad;": "", "&Gbreve;": "", "&Gcedil;": "", "&Gcirc;": "", "&Gcy;": "", "&Gdot;": "", "&Gfr;": "", "&Gg;": "", "&Gopf;": "", "&GreaterEqual;": "", "&GreaterEqualLess;": "", "&GreaterFullEqual;": "", "&GreaterGreater;": "", "&GreaterLess;": "", "&GreaterSlantEqual;": "", "&GreaterTilde;": "", "&Gscr;": "", "&Gt;": "", "&HARDcy;": "", "&Hacek;": "", "&Hat;": "^", "&Hcirc;": "", "&Hfr;": "", "&HilbertSpace;": "", "&Hopf;": "", "&HorizontalLine;": "", "&Hscr;": "", "&Hstrok;": "", "&HumpDownHump;": "", "&HumpEqual;": "", "&IEcy;": "", "&IJlig;": "", "&IOcy;": "", "&Iacute": "", "&Iacute;": "", "&Icirc": "", "&Icirc;": "", "&Icy;": "", "&Idot;": "", "&Ifr;": "", "&Igrave": "", "&Igrave;": "", "&Im;": "", "&Imacr;": "", "&ImaginaryI;": "", "&Implies;": "", "&Int;": "", "&Integral;": "", "&Intersection;": "", "&InvisibleComma;": "", "&InvisibleTimes;": "", "&Iogon;": "", "&Iopf;": "", "&Iota;": "", "&Iscr;": "", "&Itilde;": "", "&Iukcy;": "", "&Iuml": "", "&Iuml;": "", "&Jcirc;": "", "&Jcy;": "", "&Jfr;": "", "&Jopf;": "", "&Jscr;": "", "&Jsercy;": "", "&Jukcy;": "", "&KHcy;": "", "&KJcy;": "", "&Kappa;": "", "&Kcedil;": "", "&Kcy;": "", "&Kfr;": "", "&Kopf;": "", "&Kscr;": "", "&LJcy;": "", "&LT": "<", "&LT;": "<", "&Lacute;": "", "&Lambda;": "", "&Lang;": "", "&Laplacetrf;": "", "&Larr;": "", "&Lcaron;": "", "&Lcedil;": "", "&Lcy;": "", "&LeftAngleBracket;": "", "&LeftArrow;": "", "&LeftArrowBar;": "", "&LeftArrowRightArrow;": "", "&LeftCeiling;": "", "&LeftDoubleBracket;": "", "&LeftDownTeeVector;": "", "&LeftDownVector;": "", "&LeftDownVectorBar;": "", "&LeftFloor;": "", "&LeftRightArrow;": "", "&LeftRightVector;": "", "&LeftTee;": "", "&LeftTeeArrow;": "", "&LeftTeeVector;": "", "&LeftTriangle;": "", "&LeftTriangleBar;": "", "&LeftTriangleEqual;": "", "&LeftUpDownVector;": "", "&LeftUpTeeVector;": "", "&LeftUpVector;": "", "&LeftUpVectorBar;": "", "&LeftVector;": "", "&LeftVectorBar;": "", "&Leftarrow;": "", "&Leftrightarrow;": "", "&LessEqualGreater;": "", "&LessFullEqual;": "", "&LessGreater;": "", "&LessLess;": "", "&LessSlantEqual;": "", "&LessTilde;": "", "&Lfr;": "", "&Ll;": "", "&Lleftarrow;": "", "&Lmidot;": "", "&LongLeftArrow;": "", "&LongLeftRightArrow;": "", "&LongRightArrow;": "", "&Longleftarrow;": "", "&Longleftrightarrow;": "", "&Longrightarrow;": "", "&Lopf;": "", "&LowerLeftArrow;": "", "&LowerRightArrow;": "", "&Lscr;": "", "&Lsh;": "", "&Lstrok;": "", "&Lt;": "", "&Map;": "", "&Mcy;": "", "&MediumSpace;": "", "&Mellintrf;": "", "&Mfr;": "", "&MinusPlus;": "", "&Mopf;": "", "&Mscr;": "", "&Mu;": "", "&NJcy;": "", "&Nacute;": "", "&Ncaron;": "", "&Ncedil;": "", "&Ncy;": "", "&NegativeMediumSpace;": "", "&NegativeThickSpace;": "", "&NegativeThinSpace;": "", "&NegativeVeryThinSpace;": "", "&NestedGreaterGreater;": "", "&NestedLessLess;": "", "&NewLine;": "\n", "&Nfr;": "", "&NoBreak;": "", "&NonBreakingSpace;": "", "&Nopf;": "", "&Not;": "", "&NotCongruent;": "", "&NotCupCap;": "", "&NotDoubleVerticalBar;": "", "&NotElement;": "", "&NotEqual;": "", "&NotEqualTilde;": "", "&NotExists;": "", "&NotGreater;": "", "&NotGreaterEqual;": "", "&NotGreaterFullEqual;": "", "&NotGreaterGreater;": "", "&NotGreaterLess;": "", "&NotGreaterSlantEqual;": "", "&NotGreaterTilde;": "", "&NotHumpDownHump;": "", "&NotHumpEqual;": "", "&NotLeftTriangle;": "", "&NotLeftTriangleBar;": "", "&NotLeftTriangleEqual;": "", "&NotLess;": "", "&NotLessEqual;": "", "&NotLessGreater;": "", "&NotLessLess;": "", "&NotLessSlantEqual;": "", "&NotLessTilde;": "", "&NotNestedGreaterGreater;": "", "&NotNestedLessLess;": "", "&NotPrecedes;": "", "&NotPrecedesEqual;": "", "&NotPrecedesSlantEqual;": "", "&NotReverseElement;": "", "&NotRightTriangle;": "", "&NotRightTriangleBar;": "", "&NotRightTriangleEqual;": "", "&NotSquareSubset;": "", "&NotSquareSubsetEqual;": "", "&NotSquareSuperset;": "", "&NotSquareSupersetEqual;": "", "&NotSubset;": "", "&NotSubsetEqual;": "", "&NotSucceeds;": "", "&NotSucceedsEqual;": "", "&NotSucceedsSlantEqual;": "", "&NotSucceedsTilde;": "", "&NotSuperset;": "", "&NotSupersetEqual;": "", "&NotTilde;": "", "&NotTildeEqual;": "", "&NotTildeFullEqual;": "", "&NotTildeTilde;": "", "&NotVerticalBar;": "", "&Nscr;": "", "&Ntilde": "", "&Ntilde;": "", "&Nu;": "", "&OElig;": "", "&Oacute": "", "&Oacute;": "", "&Ocirc": "", "&Ocirc;": "", "&Ocy;": "", "&Odblac;": "", "&Ofr;": "", "&Ograve": "", "&Ograve;": "", "&Omacr;": "", "&Omega;": "", "&Omicron;": "", "&Oopf;": "", "&OpenCurlyDoubleQuote;": "", "&OpenCurlyQuote;": "", "&Or;": "", "&Oscr;": "", "&Oslash": "", "&Oslash;": "", "&Otilde": "", "&Otilde;": "", "&Otimes;": "", "&Ouml": "", "&Ouml;": "", "&OverBar;": "", "&OverBrace;": "", "&OverBracket;": "", "&OverParenthesis;": "", "&PartialD;": "", "&Pcy;": "", "&Pfr;": "", "&Phi;": "", "&Pi;": "", "&PlusMinus;": "", "&Poincareplane;": "", "&Popf;": "", "&Pr;": "", "&Precedes;": "", "&PrecedesEqual;": "", "&PrecedesSlantEqual;": "", "&PrecedesTilde;": "", "&Prime;": "", "&Product;": "", "&Proportion;": "", "&Proportional;": "", "&Pscr;": "", "&Psi;": "", "&QUOT": '"', "&QUOT;": '"', "&Qfr;": "", "&Qopf;": "", "&Qscr;": "", "&RBarr;": "", "&REG": "", "&REG;": "", "&Racute;": "", "&Rang;": "", "&Rarr;": "", "&Rarrtl;": "", "&Rcaron;": "", "&Rcedil;": "", "&Rcy;": "", "&Re;": "", "&ReverseElement;": "", "&ReverseEquilibrium;": "", "&ReverseUpEquilibrium;": "", "&Rfr;": "", "&Rho;": "", "&RightAngleBracket;": "", "&RightArrow;": "", "&RightArrowBar;": "", "&RightArrowLeftArrow;": "", "&RightCeiling;": "", "&RightDoubleBracket;": "", "&RightDownTeeVector;": "", "&RightDownVector;": "", "&RightDownVectorBar;": "", "&RightFloor;": "", "&RightTee;": "", "&RightTeeArrow;": "", "&RightTeeVector;": "", "&RightTriangle;": "", "&RightTriangleBar;": "", "&RightTriangleEqual;": "", "&RightUpDownVector;": "", "&RightUpTeeVector;": "", "&RightUpVector;": "", "&RightUpVectorBar;": "", "&RightVector;": "", "&RightVectorBar;": "", "&Rightarrow;": "", "&Ropf;": "", "&RoundImplies;": "", "&Rrightarrow;": "", "&Rscr;": "", "&Rsh;": "", "&RuleDelayed;": "", "&SHCHcy;": "", "&SHcy;": "", "&SOFTcy;": "", "&Sacute;": "", "&Sc;": "", "&Scaron;": "", "&Scedil;": "", "&Scirc;": "", "&Scy;": "", "&Sfr;": "", "&ShortDownArrow;": "", "&ShortLeftArrow;": "", "&ShortRightArrow;": "", "&ShortUpArrow;": "", "&Sigma;": "", "&SmallCircle;": "", "&Sopf;": "", "&Sqrt;": "", "&Square;": "", "&SquareIntersection;": "", "&SquareSubset;": "", "&SquareSubsetEqual;": "", "&SquareSuperset;": "", "&SquareSupersetEqual;": "", "&SquareUnion;": "", "&Sscr;": "", "&Star;": "", "&Sub;": "", "&Subset;": "", "&SubsetEqual;": "", "&Succeeds;": "", "&SucceedsEqual;": "", "&SucceedsSlantEqual;": "", "&SucceedsTilde;": "", "&SuchThat;": "", "&Sum;": "", "&Sup;": "", "&Superset;": "", "&SupersetEqual;": "", "&Supset;": "", "&THORN": "", "&THORN;": "", "&TRADE;": "", "&TSHcy;": "", "&TScy;": "", "&Tab;": "	", "&Tau;": "", "&Tcaron;": "", "&Tcedil;": "", "&Tcy;": "", "&Tfr;": "", "&Therefore;": "", "&Theta;": "", "&ThickSpace;": "", "&ThinSpace;": "", "&Tilde;": "", "&TildeEqual;": "", "&TildeFullEqual;": "", "&TildeTilde;": "", "&Topf;": "", "&TripleDot;": "", "&Tscr;": "", "&Tstrok;": "", "&Uacute": "", "&Uacute;": "", "&Uarr;": "", "&Uarrocir;": "", "&Ubrcy;": "", "&Ubreve;": "", "&Ucirc": "", "&Ucirc;": "", "&Ucy;": "", "&Udblac;": "", "&Ufr;": "", "&Ugrave": "", "&Ugrave;": "", "&Umacr;": "", "&UnderBar;": "_", "&UnderBrace;": "", "&UnderBracket;": "", "&UnderParenthesis;": "", "&Union;": "", "&UnionPlus;": "", "&Uogon;": "", "&Uopf;": "", "&UpArrow;": "", "&UpArrowBar;": "", "&UpArrowDownArrow;": "", "&UpDownArrow;": "", "&UpEquilibrium;": "", "&UpTee;": "", "&UpTeeArrow;": "", "&Uparrow;": "", "&Updownarrow;": "", "&UpperLeftArrow;": "", "&UpperRightArrow;": "", "&Upsi;": "", "&Upsilon;": "", "&Uring;": "", "&Uscr;": "", "&Utilde;": "", "&Uuml": "", "&Uuml;": "", "&VDash;": "", "&Vbar;": "", "&Vcy;": "", "&Vdash;": "", "&Vdashl;": "", "&Vee;": "", "&Verbar;": "", "&Vert;": "", "&VerticalBar;": "", "&VerticalLine;": "|", "&VerticalSeparator;": "", "&VerticalTilde;": "", "&VeryThinSpace;": "", "&Vfr;": "", "&Vopf;": "", "&Vscr;": "", "&Vvdash;": "", "&Wcirc;": "", "&Wedge;": "", "&Wfr;": "", "&Wopf;": "", "&Wscr;": "", "&Xfr;": "", "&Xi;": "", "&Xopf;": "", "&Xscr;": "", "&YAcy;": "", "&YIcy;": "", "&YUcy;": "", "&Yacute": "", "&Yacute;": "", "&Ycirc;": "", "&Ycy;": "", "&Yfr;": "", "&Yopf;": "", "&Yscr;": "", "&Yuml;": "", "&ZHcy;": "", "&Zacute;": "", "&Zcaron;": "", "&Zcy;": "", "&Zdot;": "", "&ZeroWidthSpace;": "", "&Zeta;": "", "&Zfr;": "", "&Zopf;": "", "&Zscr;": "", "&aacute": "", "&aacute;": "", "&abreve;": "", "&ac;": "", "&acE;": "", "&acd;": "", "&acirc": "", "&acirc;": "", "&acute": "", "&acute;": "", "&acy;": "", "&aelig": "", "&aelig;": "", "&af;": "", "&afr;": "", "&agrave": "", "&agrave;": "", "&alefsym;": "", "&aleph;": "", "&alpha;": "", "&amacr;": "", "&amalg;": "", "&amp": "&", "&amp;": "&", "&and;": "", "&andand;": "", "&andd;": "", "&andslope;": "", "&andv;": "", "&ang;": "", "&ange;": "", "&angle;": "", "&angmsd;": "", "&angmsdaa;": "", "&angmsdab;": "", "&angmsdac;": "", "&angmsdad;": "", "&angmsdae;": "", "&angmsdaf;": "", "&angmsdag;": "", "&angmsdah;": "", "&angrt;": "", "&angrtvb;": "", "&angrtvbd;": "", "&angsph;": "", "&angst;": "", "&angzarr;": "", "&aogon;": "", "&aopf;": "", "&ap;": "", "&apE;": "", "&apacir;": "", "&ape;": "", "&apid;": "", "&apos;": "'", "&approx;": "", "&approxeq;": "", "&aring": "", "&aring;": "", "&ascr;": "", "&ast;": "*", "&asymp;": "", "&asympeq;": "", "&atilde": "", "&atilde;": "", "&auml": "", "&auml;": "", "&awconint;": "", "&awint;": "", "&bNot;": "", "&backcong;": "", "&backepsilon;": "", "&backprime;": "", "&backsim;": "", "&backsimeq;": "", "&barvee;": "", "&barwed;": "", "&barwedge;": "", "&bbrk;": "", "&bbrktbrk;": "", "&bcong;": "", "&bcy;": "", "&bdquo;": "", "&becaus;": "", "&because;": "", "&bemptyv;": "", "&bepsi;": "", "&bernou;": "", "&beta;": "", "&beth;": "", "&between;": "", "&bfr;": "", "&bigcap;": "", "&bigcirc;": "", "&bigcup;": "", "&bigodot;": "", "&bigoplus;": "", "&bigotimes;": "", "&bigsqcup;": "", "&bigstar;": "", "&bigtriangledown;": "", "&bigtriangleup;": "", "&biguplus;": "", "&bigvee;": "", "&bigwedge;": "", "&bkarow;": "", "&blacklozenge;": "", "&blacksquare;": "", "&blacktriangle;": "", "&blacktriangledown;": "", "&blacktriangleleft;": "", "&blacktriangleright;": "", "&blank;": "", "&blk12;": "", "&blk14;": "", "&blk34;": "", "&block;": "", "&bne;": "=", "&bnequiv;": "", "&bnot;": "", "&bopf;": "", "&bot;": "", "&bottom;": "", "&bowtie;": "", "&boxDL;": "", "&boxDR;": "", "&boxDl;": "", "&boxDr;": "", "&boxH;": "", "&boxHD;": "", "&boxHU;": "", "&boxHd;": "", "&boxHu;": "", "&boxUL;": "", "&boxUR;": "", "&boxUl;": "", "&boxUr;": "", "&boxV;": "", "&boxVH;": "", "&boxVL;": "", "&boxVR;": "", "&boxVh;": "", "&boxVl;": "", "&boxVr;": "", "&boxbox;": "", "&boxdL;": "", "&boxdR;": "", "&boxdl;": "", "&boxdr;": "", "&boxh;": "", "&boxhD;": "", "&boxhU;": "", "&boxhd;": "", "&boxhu;": "", "&boxminus;": "", "&boxplus;": "", "&boxtimes;": "", "&boxuL;": "", "&boxuR;": "", "&boxul;": "", "&boxur;": "", "&boxv;": "", "&boxvH;": "", "&boxvL;": "", "&boxvR;": "", "&boxvh;": "", "&boxvl;": "", "&boxvr;": "", "&bprime;": "", "&breve;": "", "&brvbar": "", "&brvbar;": "", "&bscr;": "", "&bsemi;": "", "&bsim;": "", "&bsime;": "", "&bsol;": "\\", "&bsolb;": "", "&bsolhsub;": "", "&bull;": "", "&bullet;": "", "&bump;": "", "&bumpE;": "", "&bumpe;": "", "&bumpeq;": "", "&cacute;": "", "&cap;": "", "&capand;": "", "&capbrcup;": "", "&capcap;": "", "&capcup;": "", "&capdot;": "", "&caps;": "", "&caret;": "", "&caron;": "", "&ccaps;": "", "&ccaron;": "", "&ccedil": "", "&ccedil;": "", "&ccirc;": "", "&ccups;": "", "&ccupssm;": "", "&cdot;": "", "&cedil": "", "&cedil;": "", "&cemptyv;": "", "&cent": "", "&cent;": "", "&centerdot;": "", "&cfr;": "", "&chcy;": "", "&check;": "", "&checkmark;": "", "&chi;": "", "&cir;": "", "&cirE;": "", "&circ;": "", "&circeq;": "", "&circlearrowleft;": "", "&circlearrowright;": "", "&circledR;": "", "&circledS;": "", "&circledast;": "", "&circledcirc;": "", "&circleddash;": "", "&cire;": "", "&cirfnint;": "", "&cirmid;": "", "&cirscir;": "", "&clubs;": "", "&clubsuit;": "", "&colon;": ":", "&colone;": "", "&coloneq;": "", "&comma;": ",", "&commat;": "@", "&comp;": "", "&compfn;": "", "&complement;": "", "&complexes;": "", "&cong;": "", "&congdot;": "", "&conint;": "", "&copf;": "", "&coprod;": "", "&copy": "", "&copy;": "", "&copysr;": "", "&crarr;": "", "&cross;": "", "&cscr;": "", "&csub;": "", "&csube;": "", "&csup;": "", "&csupe;": "", "&ctdot;": "", "&cudarrl;": "", "&cudarrr;": "", "&cuepr;": "", "&cuesc;": "", "&cularr;": "", "&cularrp;": "", "&cup;": "", "&cupbrcap;": "", "&cupcap;": "", "&cupcup;": "", "&cupdot;": "", "&cupor;": "", "&cups;": "", "&curarr;": "", "&curarrm;": "", "&curlyeqprec;": "", "&curlyeqsucc;": "", "&curlyvee;": "", "&curlywedge;": "", "&curren": "", "&curren;": "", "&curvearrowleft;": "", "&curvearrowright;": "", "&cuvee;": "", "&cuwed;": "", "&cwconint;": "", "&cwint;": "", "&cylcty;": "", "&dArr;": "", "&dHar;": "", "&dagger;": "", "&daleth;": "", "&darr;": "", "&dash;": "", "&dashv;": "", "&dbkarow;": "", "&dblac;": "", "&dcaron;": "", "&dcy;": "", "&dd;": "", "&ddagger;": "", "&ddarr;": "", "&ddotseq;": "", "&deg": "", "&deg;": "", "&delta;": "", "&demptyv;": "", "&dfisht;": "", "&dfr;": "", "&dharl;": "", "&dharr;": "", "&diam;": "", "&diamond;": "", "&diamondsuit;": "", "&diams;": "", "&die;": "", "&digamma;": "", "&disin;": "", "&div;": "", "&divide": "", "&divide;": "", "&divideontimes;": "", "&divonx;": "", "&djcy;": "", "&dlcorn;": "", "&dlcrop;": "", "&dollar;": "$", "&dopf;": "", "&dot;": "", "&doteq;": "", "&doteqdot;": "", "&dotminus;": "", "&dotplus;": "", "&dotsquare;": "", "&doublebarwedge;": "", "&downarrow;": "", "&downdownarrows;": "", "&downharpoonleft;": "", "&downharpoonright;": "", "&drbkarow;": "", "&drcorn;": "", "&drcrop;": "", "&dscr;": "", "&dscy;": "", "&dsol;": "", "&dstrok;": "", "&dtdot;": "", "&dtri;": "", "&dtrif;": "", "&duarr;": "", "&duhar;": "", "&dwangle;": "", "&dzcy;": "", "&dzigrarr;": "", "&eDDot;": "", "&eDot;": "", "&eacute": "", "&eacute;": "", "&easter;": "", "&ecaron;": "", "&ecir;": "", "&ecirc": "", "&ecirc;": "", "&ecolon;": "", "&ecy;": "", "&edot;": "", "&ee;": "", "&efDot;": "", "&efr;": "", "&eg;": "", "&egrave": "", "&egrave;": "", "&egs;": "", "&egsdot;": "", "&el;": "", "&elinters;": "", "&ell;": "", "&els;": "", "&elsdot;": "", "&emacr;": "", "&empty;": "", "&emptyset;": "", "&emptyv;": "", "&emsp13;": "", "&emsp14;": "", "&emsp;": "", "&eng;": "", "&ensp;": "", "&eogon;": "", "&eopf;": "", "&epar;": "", "&eparsl;": "", "&eplus;": "", "&epsi;": "", "&epsilon;": "", "&epsiv;": "", "&eqcirc;": "", "&eqcolon;": "", "&eqsim;": "", "&eqslantgtr;": "", "&eqslantless;": "", "&equals;": "=", "&equest;": "", "&equiv;": "", "&equivDD;": "", "&eqvparsl;": "", "&erDot;": "", "&erarr;": "", "&escr;": "", "&esdot;": "", "&esim;": "", "&eta;": "", "&eth": "", "&eth;": "", "&euml": "", "&euml;": "", "&euro;": "", "&excl;": "!", "&exist;": "", "&expectation;": "", "&exponentiale;": "", "&fallingdotseq;": "", "&fcy;": "", "&female;": "", "&ffilig;": "", "&fflig;": "", "&ffllig;": "", "&ffr;": "", "&filig;": "", "&fjlig;": "fj", "&flat;": "", "&fllig;": "", "&fltns;": "", "&fnof;": "", "&fopf;": "", "&forall;": "", "&fork;": "", "&forkv;": "", "&fpartint;": "", "&frac12": "", "&frac12;": "", "&frac13;": "", "&frac14": "", "&frac14;": "", "&frac15;": "", "&frac16;": "", "&frac18;": "", "&frac23;": "", "&frac25;": "", "&frac34": "", "&frac34;": "", "&frac35;": "", "&frac38;": "", "&frac45;": "", "&frac56;": "", "&frac58;": "", "&frac78;": "", "&frasl;": "", "&frown;": "", "&fscr;": "", "&gE;": "", "&gEl;": "", "&gacute;": "", "&gamma;": "", "&gammad;": "", "&gap;": "", "&gbreve;": "", "&gcirc;": "", "&gcy;": "", "&gdot;": "", "&ge;": "", "&gel;": "", "&geq;": "", "&geqq;": "", "&geqslant;": "", "&ges;": "", "&gescc;": "", "&gesdot;": "", "&gesdoto;": "", "&gesdotol;": "", "&gesl;": "", "&gesles;": "", "&gfr;": "", "&gg;": "", "&ggg;": "", "&gimel;": "", "&gjcy;": "", "&gl;": "", "&glE;": "", "&gla;": "", "&glj;": "", "&gnE;": "", "&gnap;": "", "&gnapprox;": "", "&gne;": "", "&gneq;": "", "&gneqq;": "", "&gnsim;": "", "&gopf;": "", "&grave;": "`", "&gscr;": "", "&gsim;": "", "&gsime;": "", "&gsiml;": "", "&gt": ">", "&gt;": ">", "&gtcc;": "", "&gtcir;": "", "&gtdot;": "", "&gtlPar;": "", "&gtquest;": "", "&gtrapprox;": "", "&gtrarr;": "", "&gtrdot;": "", "&gtreqless;": "", "&gtreqqless;": "", "&gtrless;": "", "&gtrsim;": "", "&gvertneqq;": "", "&gvnE;": "", "&hArr;": "", "&hairsp;": "", "&half;": "", "&hamilt;": "", "&hardcy;": "", "&harr;": "", "&harrcir;": "", "&harrw;": "", "&hbar;": "", "&hcirc;": "", "&hearts;": "", "&heartsuit;": "", "&hellip;": "", "&hercon;": "", "&hfr;": "", "&hksearow;": "", "&hkswarow;": "", "&hoarr;": "", "&homtht;": "", "&hookleftarrow;": "", "&hookrightarrow;": "", "&hopf;": "", "&horbar;": "", "&hscr;": "", "&hslash;": "", "&hstrok;": "", "&hybull;": "", "&hyphen;": "", "&iacute": "", "&iacute;": "", "&ic;": "", "&icirc": "", "&icirc;": "", "&icy;": "", "&iecy;": "", "&iexcl": "", "&iexcl;": "", "&iff;": "", "&ifr;": "", "&igrave": "", "&igrave;": "", "&ii;": "", "&iiiint;": "", "&iiint;": "", "&iinfin;": "", "&iiota;": "", "&ijlig;": "", "&imacr;": "", "&image;": "", "&imagline;": "", "&imagpart;": "", "&imath;": "", "&imof;": "", "&imped;": "", "&in;": "", "&incare;": "", "&infin;": "", "&infintie;": "", "&inodot;": "", "&int;": "", "&intcal;": "", "&integers;": "", "&intercal;": "", "&intlarhk;": "", "&intprod;": "", "&iocy;": "", "&iogon;": "", "&iopf;": "", "&iota;": "", "&iprod;": "", "&iquest": "", "&iquest;": "", "&iscr;": "", "&isin;": "", "&isinE;": "", "&isindot;": "", "&isins;": "", "&isinsv;": "", "&isinv;": "", "&it;": "", "&itilde;": "", "&iukcy;": "", "&iuml": "", "&iuml;": "", "&jcirc;": "", "&jcy;": "", "&jfr;": "", "&jmath;": "", "&jopf;": "", "&jscr;": "", "&jsercy;": "", "&jukcy;": "", "&kappa;": "", "&kappav;": "", "&kcedil;": "", "&kcy;": "", "&kfr;": "", "&kgreen;": "", "&khcy;": "", "&kjcy;": "", "&kopf;": "", "&kscr;": "", "&lAarr;": "", "&lArr;": "", "&lAtail;": "", "&lBarr;": "", "&lE;": "", "&lEg;": "", "&lHar;": "", "&lacute;": "", "&laemptyv;": "", "&lagran;": "", "&lambda;": "", "&lang;": "", "&langd;": "", "&langle;": "", "&lap;": "", "&laquo": "", "&laquo;": "", "&larr;": "", "&larrb;": "", "&larrbfs;": "", "&larrfs;": "", "&larrhk;": "", "&larrlp;": "", "&larrpl;": "", "&larrsim;": "", "&larrtl;": "", "&lat;": "", "&latail;": "", "&late;": "", "&lates;": "", "&lbarr;": "", "&lbbrk;": "", "&lbrace;": "{", "&lbrack;": "[", "&lbrke;": "", "&lbrksld;": "", "&lbrkslu;": "", "&lcaron;": "", "&lcedil;": "", "&lceil;": "", "&lcub;": "{", "&lcy;": "", "&ldca;": "", "&ldquo;": "", "&ldquor;": "", "&ldrdhar;": "", "&ldrushar;": "", "&ldsh;": "", "&le;": "", "&leftarrow;": "", "&leftarrowtail;": "", "&leftharpoondown;": "", "&leftharpoonup;": "", "&leftleftarrows;": "", "&leftrightarrow;": "", "&leftrightarrows;": "", "&leftrightharpoons;": "", "&leftrightsquigarrow;": "", "&leftthreetimes;": "", "&leg;": "", "&leq;": "", "&leqq;": "", "&leqslant;": "", "&les;": "", "&lescc;": "", "&lesdot;": "", "&lesdoto;": "", "&lesdotor;": "", "&lesg;": "", "&lesges;": "", "&lessapprox;": "", "&lessdot;": "", "&lesseqgtr;": "", "&lesseqqgtr;": "", "&lessgtr;": "", "&lesssim;": "", "&lfisht;": "", "&lfloor;": "", "&lfr;": "", "&lg;": "", "&lgE;": "", "&lhard;": "", "&lharu;": "", "&lharul;": "", "&lhblk;": "", "&ljcy;": "", "&ll;": "", "&llarr;": "", "&llcorner;": "", "&llhard;": "", "&lltri;": "", "&lmidot;": "", "&lmoust;": "", "&lmoustache;": "", "&lnE;": "", "&lnap;": "", "&lnapprox;": "", "&lne;": "", "&lneq;": "", "&lneqq;": "", "&lnsim;": "", "&loang;": "", "&loarr;": "", "&lobrk;": "", "&longleftarrow;": "", "&longleftrightarrow;": "", "&longmapsto;": "", "&longrightarrow;": "", "&looparrowleft;": "", "&looparrowright;": "", "&lopar;": "", "&lopf;": "", "&loplus;": "", "&lotimes;": "", "&lowast;": "", "&lowbar;": "_", "&loz;": "", "&lozenge;": "", "&lozf;": "", "&lpar;": "(", "&lparlt;": "", "&lrarr;": "", "&lrcorner;": "", "&lrhar;": "", "&lrhard;": "", "&lrm;": "", "&lrtri;": "", "&lsaquo;": "", "&lscr;": "", "&lsh;": "", "&lsim;": "", "&lsime;": "", "&lsimg;": "", "&lsqb;": "[", "&lsquo;": "", "&lsquor;": "", "&lstrok;": "", "&lt": "<", "&lt;": "<", "&ltcc;": "", "&ltcir;": "", "&ltdot;": "", "&lthree;": "", "&ltimes;": "", "&ltlarr;": "", "&ltquest;": "", "&ltrPar;": "", "&ltri;": "", "&ltrie;": "", "&ltrif;": "", "&lurdshar;": "", "&luruhar;": "", "&lvertneqq;": "", "&lvnE;": "", "&mDDot;": "", "&macr": "", "&macr;": "", "&male;": "", "&malt;": "", "&maltese;": "", "&map;": "", "&mapsto;": "", "&mapstodown;": "", "&mapstoleft;": "", "&mapstoup;": "", "&marker;": "", "&mcomma;": "", "&mcy;": "", "&mdash;": "", "&measuredangle;": "", "&mfr;": "", "&mho;": "", "&micro": "", "&micro;": "", "&mid;": "", "&midast;": "*", "&midcir;": "", "&middot": "", "&middot;": "", "&minus;": "", "&minusb;": "", "&minusd;": "", "&minusdu;": "", "&mlcp;": "", "&mldr;": "", "&mnplus;": "", "&models;": "", "&mopf;": "", "&mp;": "", "&mscr;": "", "&mstpos;": "", "&mu;": "", "&multimap;": "", "&mumap;": "", "&nGg;": "", "&nGt;": "", "&nGtv;": "", "&nLeftarrow;": "", "&nLeftrightarrow;": "", "&nLl;": "", "&nLt;": "", "&nLtv;": "", "&nRightarrow;": "", "&nVDash;": "", "&nVdash;": "", "&nabla;": "", "&nacute;": "", "&nang;": "", "&nap;": "", "&napE;": "", "&napid;": "", "&napos;": "", "&napprox;": "", "&natur;": "", "&natural;": "", "&naturals;": "", "&nbsp": "", "&nbsp;": "", "&nbump;": "", "&nbumpe;": "", "&ncap;": "", "&ncaron;": "", "&ncedil;": "", "&ncong;": "", "&ncongdot;": "", "&ncup;": "", "&ncy;": "", "&ndash;": "", "&ne;": "", "&neArr;": "", "&nearhk;": "", "&nearr;": "", "&nearrow;": "", "&nedot;": "", "&nequiv;": "", "&nesear;": "", "&nesim;": "", "&nexist;": "", "&nexists;": "", "&nfr;": "", "&ngE;": "", "&nge;": "", "&ngeq;": "", "&ngeqq;": "", "&ngeqslant;": "", "&nges;": "", "&ngsim;": "", "&ngt;": "", "&ngtr;": "", "&nhArr;": "", "&nharr;": "", "&nhpar;": "", "&ni;": "", "&nis;": "", "&nisd;": "", "&niv;": "", "&njcy;": "", "&nlArr;": "", "&nlE;": "", "&nlarr;": "", "&nldr;": "", "&nle;": "", "&nleftarrow;": "", "&nleftrightarrow;": "", "&nleq;": "", "&nleqq;": "", "&nleqslant;": "", "&nles;": "", "&nless;": "", "&nlsim;": "", "&nlt;": "", "&nltri;": "", "&nltrie;": "", "&nmid;": "", "&nopf;": "", "&not": "", "&not;": "", "&notin;": "", "&notinE;": "", "&notindot;": "", "&notinva;": "", "&notinvb;": "", "&notinvc;": "", "&notni;": "", "&notniva;": "", "&notnivb;": "", "&notnivc;": "", "&npar;": "", "&nparallel;": "", "&nparsl;": "", "&npart;": "", "&npolint;": "", "&npr;": "", "&nprcue;": "", "&npre;": "", "&nprec;": "", "&npreceq;": "", "&nrArr;": "", "&nrarr;": "", "&nrarrc;": "", "&nrarrw;": "", "&nrightarrow;": "", "&nrtri;": "", "&nrtrie;": "", "&nsc;": "", "&nsccue;": "", "&nsce;": "", "&nscr;": "", "&nshortmid;": "", "&nshortparallel;": "", "&nsim;": "", "&nsime;": "", "&nsimeq;": "", "&nsmid;": "", "&nspar;": "", "&nsqsube;": "", "&nsqsupe;": "", "&nsub;": "", "&nsubE;": "", "&nsube;": "", "&nsubset;": "", "&nsubseteq;": "", "&nsubseteqq;": "", "&nsucc;": "", "&nsucceq;": "", "&nsup;": "", "&nsupE;": "", "&nsupe;": "", "&nsupset;": "", "&nsupseteq;": "", "&nsupseteqq;": "", "&ntgl;": "", "&ntilde": "", "&ntilde;": "", "&ntlg;": "", "&ntriangleleft;": "", "&ntrianglelefteq;": "", "&ntriangleright;": "", "&ntrianglerighteq;": "", "&nu;": "", "&num;": "#", "&numero;": "", "&numsp;": "", "&nvDash;": "", "&nvHarr;": "", "&nvap;": "", "&nvdash;": "", "&nvge;": "", "&nvgt;": ">", "&nvinfin;": "", "&nvlArr;": "", "&nvle;": "", "&nvlt;": "<", "&nvltrie;": "", "&nvrArr;": "", "&nvrtrie;": "", "&nvsim;": "", "&nwArr;": "", "&nwarhk;": "", "&nwarr;": "", "&nwarrow;": "", "&nwnear;": "", "&oS;": "", "&oacute": "", "&oacute;": "", "&oast;": "", "&ocir;": "", "&ocirc": "", "&ocirc;": "", "&ocy;": "", "&odash;": "", "&odblac;": "", "&odiv;": "", "&odot;": "", "&odsold;": "", "&oelig;": "", "&ofcir;": "", "&ofr;": "", "&ogon;": "", "&ograve": "", "&ograve;": "", "&ogt;": "", "&ohbar;": "", "&ohm;": "", "&oint;": "", "&olarr;": "", "&olcir;": "", "&olcross;": "", "&oline;": "", "&olt;": "", "&omacr;": "", "&omega;": "", "&omicron;": "", "&omid;": "", "&ominus;": "", "&oopf;": "", "&opar;": "", "&operp;": "", "&oplus;": "", "&or;": "", "&orarr;": "", "&ord;": "", "&order;": "", "&orderof;": "", "&ordf": "", "&ordf;": "", "&ordm": "", "&ordm;": "", "&origof;": "", "&oror;": "", "&orslope;": "", "&orv;": "", "&oscr;": "", "&oslash": "", "&oslash;": "", "&osol;": "", "&otilde": "", "&otilde;": "", "&otimes;": "", "&otimesas;": "", "&ouml": "", "&ouml;": "", "&ovbar;": "", "&par;": "", "&para": "", "&para;": "", "&parallel;": "", "&parsim;": "", "&parsl;": "", "&part;": "", "&pcy;": "", "&percnt;": "%", "&period;": ".", "&permil;": "", "&perp;": "", "&pertenk;": "", "&pfr;": "", "&phi;": "", "&phiv;": "", "&phmmat;": "", "&phone;": "", "&pi;": "", "&pitchfork;": "", "&piv;": "", "&planck;": "", "&planckh;": "", "&plankv;": "", "&plus;": "+", "&plusacir;": "", "&plusb;": "", "&pluscir;": "", "&plusdo;": "", "&plusdu;": "", "&pluse;": "", "&plusmn": "", "&plusmn;": "", "&plussim;": "", "&plustwo;": "", "&pm;": "", "&pointint;": "", "&popf;": "", "&pound": "", "&pound;": "", "&pr;": "", "&prE;": "", "&prap;": "", "&prcue;": "", "&pre;": "", "&prec;": "", "&precapprox;": "", "&preccurlyeq;": "", "&preceq;": "", "&precnapprox;": "", "&precneqq;": "", "&precnsim;": "", "&precsim;": "", "&prime;": "", "&primes;": "", "&prnE;": "", "&prnap;": "", "&prnsim;": "", "&prod;": "", "&profalar;": "", "&profline;": "", "&profsurf;": "", "&prop;": "", "&propto;": "", "&prsim;": "", "&prurel;": "", "&pscr;": "", "&psi;": "", "&puncsp;": "", "&qfr;": "", "&qint;": "", "&qopf;": "", "&qprime;": "", "&qscr;": "", "&quaternions;": "", "&quatint;": "", "&quest;": "?", "&questeq;": "", "&quot": '"', "&quot;": '"', "&rAarr;": "", "&rArr;": "", "&rAtail;": "", "&rBarr;": "", "&rHar;": "", "&race;": "", "&racute;": "", "&radic;": "", "&raemptyv;": "", "&rang;": "", "&rangd;": "", "&range;": "", "&rangle;": "", "&raquo": "", "&raquo;": "", "&rarr;": "", "&rarrap;": "", "&rarrb;": "", "&rarrbfs;": "", "&rarrc;": "", "&rarrfs;": "", "&rarrhk;": "", "&rarrlp;": "", "&rarrpl;": "", "&rarrsim;": "", "&rarrtl;": "", "&rarrw;": "", "&ratail;": "", "&ratio;": "", "&rationals;": "", "&rbarr;": "", "&rbbrk;": "", "&rbrace;": "}", "&rbrack;": "]", "&rbrke;": "", "&rbrksld;": "", "&rbrkslu;": "", "&rcaron;": "", "&rcedil;": "", "&rceil;": "", "&rcub;": "}", "&rcy;": "", "&rdca;": "", "&rdldhar;": "", "&rdquo;": "", "&rdquor;": "", "&rdsh;": "", "&real;": "", "&realine;": "", "&realpart;": "", "&reals;": "", "&rect;": "", "&reg": "", "&reg;": "", "&rfisht;": "", "&rfloor;": "", "&rfr;": "", "&rhard;": "", "&rharu;": "", "&rharul;": "", "&rho;": "", "&rhov;": "", "&rightarrow;": "", "&rightarrowtail;": "", "&rightharpoondown;": "", "&rightharpoonup;": "", "&rightleftarrows;": "", "&rightleftharpoons;": "", "&rightrightarrows;": "", "&rightsquigarrow;": "", "&rightthreetimes;": "", "&ring;": "", "&risingdotseq;": "", "&rlarr;": "", "&rlhar;": "", "&rlm;": "", "&rmoust;": "", "&rmoustache;": "", "&rnmid;": "", "&roang;": "", "&roarr;": "", "&robrk;": "", "&ropar;": "", "&ropf;": "", "&roplus;": "", "&rotimes;": "", "&rpar;": ")", "&rpargt;": "", "&rppolint;": "", "&rrarr;": "", "&rsaquo;": "", "&rscr;": "", "&rsh;": "", "&rsqb;": "]", "&rsquo;": "", "&rsquor;": "", "&rthree;": "", "&rtimes;": "", "&rtri;": "", "&rtrie;": "", "&rtrif;": "", "&rtriltri;": "", "&ruluhar;": "", "&rx;": "", "&sacute;": "", "&sbquo;": "", "&sc;": "", "&scE;": "", "&scap;": "", "&scaron;": "", "&sccue;": "", "&sce;": "", "&scedil;": "", "&scirc;": "", "&scnE;": "", "&scnap;": "", "&scnsim;": "", "&scpolint;": "", "&scsim;": "", "&scy;": "", "&sdot;": "", "&sdotb;": "", "&sdote;": "", "&seArr;": "", "&searhk;": "", "&searr;": "", "&searrow;": "", "&sect": "", "&sect;": "", "&semi;": ";", "&seswar;": "", "&setminus;": "", "&setmn;": "", "&sext;": "", "&sfr;": "", "&sfrown;": "", "&sharp;": "", "&shchcy;": "", "&shcy;": "", "&shortmid;": "", "&shortparallel;": "", "&shy": "", "&shy;": "", "&sigma;": "", "&sigmaf;": "", "&sigmav;": "", "&sim;": "", "&simdot;": "", "&sime;": "", "&simeq;": "", "&simg;": "", "&simgE;": "", "&siml;": "", "&simlE;": "", "&simne;": "", "&simplus;": "", "&simrarr;": "", "&slarr;": "", "&smallsetminus;": "", "&smashp;": "", "&smeparsl;": "", "&smid;": "", "&smile;": "", "&smt;": "", "&smte;": "", "&smtes;": "", "&softcy;": "", "&sol;": "/", "&solb;": "", "&solbar;": "", "&sopf;": "", "&spades;": "", "&spadesuit;": "", "&spar;": "", "&sqcap;": "", "&sqcaps;": "", "&sqcup;": "", "&sqcups;": "", "&sqsub;": "", "&sqsube;": "", "&sqsubset;": "", "&sqsubseteq;": "", "&sqsup;": "", "&sqsupe;": "", "&sqsupset;": "", "&sqsupseteq;": "", "&squ;": "", "&square;": "", "&squarf;": "", "&squf;": "", "&srarr;": "", "&sscr;": "", "&ssetmn;": "", "&ssmile;": "", "&sstarf;": "", "&star;": "", "&starf;": "", "&straightepsilon;": "", "&straightphi;": "", "&strns;": "", "&sub;": "", "&subE;": "", "&subdot;": "", "&sube;": "", "&subedot;": "", "&submult;": "", "&subnE;": "", "&subne;": "", "&subplus;": "", "&subrarr;": "", "&subset;": "", "&subseteq;": "", "&subseteqq;": "", "&subsetneq;": "", "&subsetneqq;": "", "&subsim;": "", "&subsub;": "", "&subsup;": "", "&succ;": "", "&succapprox;": "", "&succcurlyeq;": "", "&succeq;": "", "&succnapprox;": "", "&succneqq;": "", "&succnsim;": "", "&succsim;": "", "&sum;": "", "&sung;": "", "&sup1": "", "&sup1;": "", "&sup2": "", "&sup2;": "", "&sup3": "", "&sup3;": "", "&sup;": "", "&supE;": "", "&supdot;": "", "&supdsub;": "", "&supe;": "", "&supedot;": "", "&suphsol;": "", "&suphsub;": "", "&suplarr;": "", "&supmult;": "", "&supnE;": "", "&supne;": "", "&supplus;": "", "&supset;": "", "&supseteq;": "", "&supseteqq;": "", "&supsetneq;": "", "&supsetneqq;": "", "&supsim;": "", "&supsub;": "", "&supsup;": "", "&swArr;": "", "&swarhk;": "", "&swarr;": "", "&swarrow;": "", "&swnwar;": "", "&szlig": "", "&szlig;": "", "&target;": "", "&tau;": "", "&tbrk;": "", "&tcaron;": "", "&tcedil;": "", "&tcy;": "", "&tdot;": "", "&telrec;": "", "&tfr;": "", "&there4;": "", "&therefore;": "", "&theta;": "", "&thetasym;": "", "&thetav;": "", "&thickapprox;": "", "&thicksim;": "", "&thinsp;": "", "&thkap;": "", "&thksim;": "", "&thorn": "", "&thorn;": "", "&tilde;": "", "&times": "", "&times;": "", "&timesb;": "", "&timesbar;": "", "&timesd;": "", "&tint;": "", "&toea;": "", "&top;": "", "&topbot;": "", "&topcir;": "", "&topf;": "", "&topfork;": "", "&tosa;": "", "&tprime;": "", "&trade;": "", "&triangle;": "", "&triangledown;": "", "&triangleleft;": "", "&trianglelefteq;": "", "&triangleq;": "", "&triangleright;": "", "&trianglerighteq;": "", "&tridot;": "", "&trie;": "", "&triminus;": "", "&triplus;": "", "&trisb;": "", "&tritime;": "", "&trpezium;": "", "&tscr;": "", "&tscy;": "", "&tshcy;": "", "&tstrok;": "", "&twixt;": "", "&twoheadleftarrow;": "", "&twoheadrightarrow;": "", "&uArr;": "", "&uHar;": "", "&uacute": "", "&uacute;": "", "&uarr;": "", "&ubrcy;": "", "&ubreve;": "", "&ucirc": "", "&ucirc;": "", "&ucy;": "", "&udarr;": "", "&udblac;": "", "&udhar;": "", "&ufisht;": "", "&ufr;": "", "&ugrave": "", "&ugrave;": "", "&uharl;": "", "&uharr;": "", "&uhblk;": "", "&ulcorn;": "", "&ulcorner;": "", "&ulcrop;": "", "&ultri;": "", "&umacr;": "", "&uml": "", "&uml;": "", "&uogon;": "", "&uopf;": "", "&uparrow;": "", "&updownarrow;": "", "&upharpoonleft;": "", "&upharpoonright;": "", "&uplus;": "", "&upsi;": "", "&upsih;": "", "&upsilon;": "", "&upuparrows;": "", "&urcorn;": "", "&urcorner;": "", "&urcrop;": "", "&uring;": "", "&urtri;": "", "&uscr;": "", "&utdot;": "", "&utilde;": "", "&utri;": "", "&utrif;": "", "&uuarr;": "", "&uuml": "", "&uuml;": "", "&uwangle;": "", "&vArr;": "", "&vBar;": "", "&vBarv;": "", "&vDash;": "", "&vangrt;": "", "&varepsilon;": "", "&varkappa;": "", "&varnothing;": "", "&varphi;": "", "&varpi;": "", "&varpropto;": "", "&varr;": "", "&varrho;": "", "&varsigma;": "", "&varsubsetneq;": "", "&varsubsetneqq;": "", "&varsupsetneq;": "", "&varsupsetneqq;": "", "&vartheta;": "", "&vartriangleleft;": "", "&vartriangleright;": "", "&vcy;": "", "&vdash;": "", "&vee;": "", "&veebar;": "", "&veeeq;": "", "&vellip;": "", "&verbar;": "|", "&vert;": "|", "&vfr;": "", "&vltri;": "", "&vnsub;": "", "&vnsup;": "", "&vopf;": "", "&vprop;": "", "&vrtri;": "", "&vscr;": "", "&vsubnE;": "", "&vsubne;": "", "&vsupnE;": "", "&vsupne;": "", "&vzigzag;": "", "&wcirc;": "", "&wedbar;": "", "&wedge;": "", "&wedgeq;": "", "&weierp;": "", "&wfr;": "", "&wopf;": "", "&wp;": "", "&wr;": "", "&wreath;": "", "&wscr;": "", "&xcap;": "", "&xcirc;": "", "&xcup;": "", "&xdtri;": "", "&xfr;": "", "&xhArr;": "", "&xharr;": "", "&xi;": "", "&xlArr;": "", "&xlarr;": "", "&xmap;": "", "&xnis;": "", "&xodot;": "", "&xopf;": "", "&xoplus;": "", "&xotime;": "", "&xrArr;": "", "&xrarr;": "", "&xscr;": "", "&xsqcup;": "", "&xuplus;": "", "&xutri;": "", "&xvee;": "", "&xwedge;": "", "&yacute": "", "&yacute;": "", "&yacy;": "", "&ycirc;": "", "&ycy;": "", "&yen": "", "&yen;": "", "&yfr;": "", "&yicy;": "", "&yopf;": "", "&yscr;": "", "&yucy;": "", "&yuml": "", "&yuml;": "", "&zacute;": "", "&zcaron;": "", "&zcy;": "", "&zdot;": "", "&zeetrf;": "", "&zeta;": "", "&zfr;": "", "&zhcy;": "", "&zigrarr;": "", "&zopf;": "", "&zscr;": "", "&zwj;": "", "&zwnj;": "" }, characters: { "": "&AElig;", "&": "&amp;", "": "&Aacute;", "": "&Abreve;", "": "&Acirc;", "": "&Acy;", "": "&Afr;", "": "&Agrave;", "": "&Alpha;", "": "&Amacr;", "": "&And;", "": "&Aogon;", "": "&Aopf;", "": "&af;", "": "&angst;", "": "&Ascr;", "": "&coloneq;", "": "&Atilde;", "": "&Auml;", "": "&ssetmn;", "": "&Barv;", "": "&doublebarwedge;", "": "&Bcy;", "": "&because;", "": "&bernou;", "": "&Beta;", "": "&Bfr;", "": "&Bopf;", "": "&breve;", "": "&bump;", "": "&CHcy;", "": "&copy;", "": "&Cacute;", "": "&Cap;", "": "&DD;", "": "&Cfr;", "": "&Ccaron;", "": "&Ccedil;", "": "&Ccirc;", "": "&Cconint;", "": "&Cdot;", "": "&cedil;", "": "&middot;", "": "&Chi;", "": "&odot;", "": "&ominus;", "": "&oplus;", "": "&otimes;", "": "&cwconint;", "": "&rdquor;", "": "&rsquor;", "": "&Proportion;", "": "&Colone;", "": "&equiv;", "": "&DoubleContourIntegral;", "": "&oint;", "": "&complexes;", "": "&coprod;", "": "&awconint;", "": "&Cross;", "": "&Cscr;", "": "&Cup;", "": "&asympeq;", "": "&DDotrahd;", "": "&DJcy;", "": "&DScy;", "": "&DZcy;", "": "&ddagger;", "": "&Darr;", "": "&DoubleLeftTee;", "": "&Dcaron;", "": "&Dcy;", "": "&nabla;", "": "&Delta;", "": "&Dfr;", "": "&acute;", "": "&dot;", "": "&dblac;", "`": "&grave;", "": "&tilde;", "": "&diamond;", "": "&dd;", "": "&Dopf;", "": "&uml;", "": "&DotDot;", "": "&esdot;", "": "&dArr;", "": "&lArr;", "": "&iff;", "": "&xlArr;", "": "&xhArr;", "": "&xrArr;", "": "&rArr;", "": "&vDash;", "": "&uArr;", "": "&vArr;", "": "&spar;", "": "&downarrow;", "": "&DownArrowBar;", "": "&duarr;", "": "&DownBreve;", "": "&DownLeftRightVector;", "": "&DownLeftTeeVector;", "": "&lhard;", "": "&DownLeftVectorBar;", "": "&DownRightTeeVector;", "": "&rightharpoondown;", "": "&DownRightVectorBar;", "": "&top;", "": "&mapstodown;", "": "&Dscr;", "": "&Dstrok;", "": "&ENG;", "": "&ETH;", "": "&Eacute;", "": "&Ecaron;", "": "&Ecirc;", "": "&Ecy;", "": "&Edot;", "": "&Efr;", "": "&Egrave;", "": "&isinv;", "": "&Emacr;", "": "&EmptySmallSquare;", "": "&EmptyVerySmallSquare;", "": "&Eogon;", "": "&Eopf;", "": "&Epsilon;", "": "&Equal;", "": "&esim;", "": "&rlhar;", "": "&expectation;", "": "&Esim;", "": "&Eta;", "": "&Euml;", "": "&exist;", "": "&exponentiale;", "": "&Fcy;", "": "&Ffr;", "": "&FilledSmallSquare;", "": "&squf;", "": "&Fopf;", "": "&forall;", "": "&Fscr;", "": "&GJcy;", ">": "&gt;", "": "&Gamma;", "": "&Gammad;", "": "&Gbreve;", "": "&Gcedil;", "": "&Gcirc;", "": "&Gcy;", "": "&Gdot;", "": "&Gfr;", "": "&ggg;", "": "&Gopf;", "": "&geq;", "": "&gtreqless;", "": "&geqq;", "": "&GreaterGreater;", "": "&gtrless;", "": "&ges;", "": "&gtrsim;", "": "&Gscr;", "": "&gg;", "": "&HARDcy;", "": "&caron;", "^": "&Hat;", "": "&Hcirc;", "": "&Poincareplane;", "": "&hamilt;", "": "&quaternions;", "": "&boxh;", "": "&Hstrok;", "": "&bumpeq;", "": "&IEcy;", "": "&IJlig;", "": "&IOcy;", "": "&Iacute;", "": "&Icirc;", "": "&Icy;", "": "&Idot;", "": "&imagpart;", "": "&Igrave;", "": "&Imacr;", "": "&ii;", "": "&Int;", "": "&int;", "": "&xcap;", "": "&ic;", "": "&it;", "": "&Iogon;", "": "&Iopf;", "": "&Iota;", "": "&imagline;", "": "&Itilde;", "": "&Iukcy;", "": "&Iuml;", "": "&Jcirc;", "": "&Jcy;", "": "&Jfr;", "": "&Jopf;", "": "&Jscr;", "": "&Jsercy;", "": "&Jukcy;", "": "&KHcy;", "": "&KJcy;", "": "&Kappa;", "": "&Kcedil;", "": "&Kcy;", "": "&Kfr;", "": "&Kopf;", "": "&Kscr;", "": "&LJcy;", "<": "&lt;", "": "&Lacute;", "": "&Lambda;", "": "&Lang;", "": "&lagran;", "": "&twoheadleftarrow;", "": "&Lcaron;", "": "&Lcedil;", "": "&Lcy;", "": "&langle;", "": "&slarr;", "": "&larrb;", "": "&lrarr;", "": "&lceil;", "": "&lobrk;", "": "&LeftDownTeeVector;", "": "&downharpoonleft;", "": "&LeftDownVectorBar;", "": "&lfloor;", "": "&leftrightarrow;", "": "&LeftRightVector;", "": "&dashv;", "": "&mapstoleft;", "": "&LeftTeeVector;", "": "&vltri;", "": "&LeftTriangleBar;", "": "&trianglelefteq;", "": "&LeftUpDownVector;", "": "&LeftUpTeeVector;", "": "&upharpoonleft;", "": "&LeftUpVectorBar;", "": "&lharu;", "": "&LeftVectorBar;", "": "&lesseqgtr;", "": "&leqq;", "": "&lg;", "": "&LessLess;", "": "&les;", "": "&lsim;", "": "&Lfr;", "": "&Ll;", "": "&lAarr;", "": "&Lmidot;", "": "&xlarr;", "": "&xharr;", "": "&xrarr;", "": "&Lopf;", "": "&swarrow;", "": "&searrow;", "": "&lsh;", "": "&Lstrok;", "": "&ll;", "": "&Map;", "": "&Mcy;", "": "&MediumSpace;", "": "&phmmat;", "": "&Mfr;", "": "&mp;", "": "&Mopf;", "": "&Mu;", "": "&NJcy;", "": "&Nacute;", "": "&Ncaron;", "": "&Ncedil;", "": "&Ncy;", "": "&ZeroWidthSpace;", "\n": "&NewLine;", "": "&Nfr;", "": "&NoBreak;", "": "&nbsp;", "": "&naturals;", "": "&Not;", "": "&nequiv;", "": "&NotCupCap;", "": "&nspar;", "": "&notinva;", "": "&ne;", "": "&nesim;", "": "&nexists;", "": "&ngtr;", "": "&ngeq;", "": "&ngeqq;", "": "&nGtv;", "": "&ntgl;", "": "&nges;", "": "&ngsim;", "": "&nbump;", "": "&nbumpe;", "": "&ntriangleleft;", "": "&NotLeftTriangleBar;", "": "&ntrianglelefteq;", "": "&nlt;", "": "&nleq;", "": "&ntlg;", "": "&nLtv;", "": "&nles;", "": "&nlsim;", "": "&NotNestedGreaterGreater;", "": "&NotNestedLessLess;", "": "&nprec;", "": "&npreceq;", "": "&nprcue;", "": "&notniva;", "": "&ntriangleright;", "": "&NotRightTriangleBar;", "": "&ntrianglerighteq;", "": "&NotSquareSubset;", "": "&nsqsube;", "": "&NotSquareSuperset;", "": "&nsqsupe;", "": "&vnsub;", "": "&nsubseteq;", "": "&nsucc;", "": "&nsucceq;", "": "&nsccue;", "": "&NotSucceedsTilde;", "": "&vnsup;", "": "&nsupseteq;", "": "&nsim;", "": "&nsimeq;", "": "&ncong;", "": "&napprox;", "": "&nsmid;", "": "&Nscr;", "": "&Ntilde;", "": "&Nu;", "": "&OElig;", "": "&Oacute;", "": "&Ocirc;", "": "&Ocy;", "": "&Odblac;", "": "&Ofr;", "": "&Ograve;", "": "&Omacr;", "": "&ohm;", "": "&Omicron;", "": "&Oopf;", "": "&ldquo;", "": "&lsquo;", "": "&Or;", "": "&Oscr;", "": "&Oslash;", "": "&Otilde;", "": "&Otimes;", "": "&Ouml;", "": "&oline;", "": "&OverBrace;", "": "&tbrk;", "": "&OverParenthesis;", "": "&part;", "": "&Pcy;", "": "&Pfr;", "": "&Phi;", "": "&Pi;", "": "&pm;", "": "&primes;", "": "&Pr;", "": "&prec;", "": "&preceq;", "": "&preccurlyeq;", "": "&prsim;", "": "&Prime;", "": "&prod;", "": "&vprop;", "": "&Pscr;", "": "&Psi;", '"': "&quot;", "": "&Qfr;", "": "&rationals;", "": "&Qscr;", "": "&drbkarow;", "": "&reg;", "": "&Racute;", "": "&Rang;", "": "&twoheadrightarrow;", "": "&Rarrtl;", "": "&Rcaron;", "": "&Rcedil;", "": "&Rcy;", "": "&realpart;", "": "&niv;", "": "&lrhar;", "": "&duhar;", "": "&Rho;", "": "&rangle;", "": "&srarr;", "": "&rarrb;", "": "&rlarr;", "": "&rceil;", "": "&robrk;", "": "&RightDownTeeVector;", "": "&downharpoonright;", "": "&RightDownVectorBar;", "": "&rfloor;", "": "&vdash;", "": "&mapsto;", "": "&RightTeeVector;", "": "&vrtri;", "": "&RightTriangleBar;", "": "&trianglerighteq;", "": "&RightUpDownVector;", "": "&RightUpTeeVector;", "": "&upharpoonright;", "": "&RightUpVectorBar;", "": "&rightharpoonup;", "": "&RightVectorBar;", "": "&reals;", "": "&RoundImplies;", "": "&rAarr;", "": "&realine;", "": "&rsh;", "": "&RuleDelayed;", "": "&SHCHcy;", "": "&SHcy;", "": "&SOFTcy;", "": "&Sacute;", "": "&Sc;", "": "&Scaron;", "": "&Scedil;", "": "&Scirc;", "": "&Scy;", "": "&Sfr;", "": "&uparrow;", "": "&Sigma;", "": "&compfn;", "": "&Sopf;", "": "&radic;", "": "&square;", "": "&sqcap;", "": "&sqsubset;", "": "&sqsubseteq;", "": "&sqsupset;", "": "&sqsupseteq;", "": "&sqcup;", "": "&Sscr;", "": "&sstarf;", "": "&Subset;", "": "&subseteq;", "": "&succ;", "": "&succeq;", "": "&succcurlyeq;", "": "&succsim;", "": "&sum;", "": "&Supset;", "": "&supset;", "": "&supseteq;", "": "&THORN;", "": "&trade;", "": "&TSHcy;", "": "&TScy;", "	": "&Tab;", "": "&Tau;", "": "&Tcaron;", "": "&Tcedil;", "": "&Tcy;", "": "&Tfr;", "": "&therefore;", "": "&Theta;", "": "&ThickSpace;", "": "&thinsp;", "": "&thksim;", "": "&simeq;", "": "&cong;", "": "&thkap;", "": "&Topf;", "": "&tdot;", "": "&Tscr;", "": "&Tstrok;", "": "&Uacute;", "": "&Uarr;", "": "&Uarrocir;", "": "&Ubrcy;", "": "&Ubreve;", "": "&Ucirc;", "": "&Ucy;", "": "&Udblac;", "": "&Ufr;", "": "&Ugrave;", "": "&Umacr;", _: "&lowbar;", "": "&UnderBrace;", "": "&bbrk;", "": "&UnderParenthesis;", "": "&xcup;", "": "&uplus;", "": "&Uogon;", "": "&Uopf;", "": "&UpArrowBar;", "": "&udarr;", "": "&varr;", "": "&udhar;", "": "&perp;", "": "&mapstoup;", "": "&nwarrow;", "": "&nearrow;", "": "&upsih;", "": "&Upsilon;", "": "&Uring;", "": "&Uscr;", "": "&Utilde;", "": "&Uuml;", "": "&VDash;", "": "&Vbar;", "": "&Vcy;", "": "&Vdash;", "": "&Vdashl;", "": "&xvee;", "": "&Vert;", "": "&smid;", "|": "&vert;", "": "&VerticalSeparator;", "": "&wreath;", "": "&hairsp;", "": "&Vfr;", "": "&Vopf;", "": "&Vscr;", "": "&Vvdash;", "": "&Wcirc;", "": "&xwedge;", "": "&Wfr;", "": "&Wopf;", "": "&Wscr;", "": "&Xfr;", "": "&Xi;", "": "&Xopf;", "": "&Xscr;", "": "&YAcy;", "": "&YIcy;", "": "&YUcy;", "": "&Yacute;", "": "&Ycirc;", "": "&Ycy;", "": "&Yfr;", "": "&Yopf;", "": "&Yscr;", "": "&Yuml;", "": "&ZHcy;", "": "&Zacute;", "": "&Zcaron;", "": "&Zcy;", "": "&Zdot;", "": "&Zeta;", "": "&zeetrf;", "": "&integers;", "": "&Zscr;", "": "&aacute;", "": "&abreve;", "": "&mstpos;", "": "&acE;", "": "&acd;", "": "&acirc;", "": "&acy;", "": "&aelig;", "": "&afr;", "": "&agrave;", "": "&aleph;", "": "&alpha;", "": "&amacr;", "": "&amalg;", "": "&wedge;", "": "&andand;", "": "&andd;", "": "&andslope;", "": "&andv;", "": "&angle;", "": "&ange;", "": "&measuredangle;", "": "&angmsdaa;", "": "&angmsdab;", "": "&angmsdac;", "": "&angmsdad;", "": "&angmsdae;", "": "&angmsdaf;", "": "&angmsdag;", "": "&angmsdah;", "": "&angrt;", "": "&angrtvb;", "": "&angrtvbd;", "": "&angsph;", "": "&angzarr;", "": "&aogon;", "": "&aopf;", "": "&apE;", "": "&apacir;", "": "&approxeq;", "": "&apid;", "'": "&apos;", "": "&aring;", "": "&ascr;", "*": "&midast;", "": "&atilde;", "": "&auml;", "": "&awint;", "": "&bNot;", "": "&bcong;", "": "&bepsi;", "": "&bprime;", "": "&bsim;", "": "&bsime;", "": "&barvee;", "": "&barwedge;", "": "&bbrktbrk;", "": "&bcy;", "": "&ldquor;", "": "&bemptyv;", "": "&beta;", "": "&beth;", "": "&twixt;", "": "&bfr;", "": "&xcirc;", "": "&xodot;", "": "&xoplus;", "": "&xotime;", "": "&xsqcup;", "": "&starf;", "": "&xdtri;", "": "&xutri;", "": "&xuplus;", "": "&rbarr;", "": "&lozf;", "": "&utrif;", "": "&dtrif;", "": "&ltrif;", "": "&rtrif;", "": "&blank;", "": "&blk12;", "": "&blk14;", "": "&blk34;", "": "&block;", "=": "&bne;", "": "&bnequiv;", "": "&bnot;", "": "&bopf;", "": "&bowtie;", "": "&boxDL;", "": "&boxDR;", "": "&boxDl;", "": "&boxDr;", "": "&boxH;", "": "&boxHD;", "": "&boxHU;", "": "&boxHd;", "": "&boxHu;", "": "&boxUL;", "": "&boxUR;", "": "&boxUl;", "": "&boxUr;", "": "&boxV;", "": "&boxVH;", "": "&boxVL;", "": "&boxVR;", "": "&boxVh;", "": "&boxVl;", "": "&boxVr;", "": "&boxbox;", "": "&boxdL;", "": "&boxdR;", "": "&boxdl;", "": "&boxdr;", "": "&boxhD;", "": "&boxhU;", "": "&boxhd;", "": "&boxhu;", "": "&minusb;", "": "&plusb;", "": "&timesb;", "": "&boxuL;", "": "&boxuR;", "": "&boxul;", "": "&boxur;", "": "&boxv;", "": "&boxvH;", "": "&boxvL;", "": "&boxvR;", "": "&boxvh;", "": "&boxvl;", "": "&boxvr;", "": "&brvbar;", "": "&bscr;", "": "&bsemi;", "\\": "&bsol;", "": "&bsolb;", "": "&bsolhsub;", "": "&bullet;", "": "&bumpE;", "": "&cacute;", "": "&cap;", "": "&capand;", "": "&capbrcup;", "": "&capcap;", "": "&capcup;", "": "&capdot;", "": "&caps;", "": "&caret;", "": "&ccaps;", "": "&ccaron;", "": "&ccedil;", "": "&ccirc;", "": "&ccups;", "": "&ccupssm;", "": "&cdot;", "": "&cemptyv;", "": "&cent;", "": "&cfr;", "": "&chcy;", "": "&checkmark;", "": "&chi;", "": "&cir;", "": "&cirE;", "": "&circ;", "": "&cire;", "": "&olarr;", "": "&orarr;", "": "&oS;", "": "&oast;", "": "&ocir;", "": "&odash;", "": "&cirfnint;", "": "&cirmid;", "": "&cirscir;", "": "&clubsuit;", ":": "&colon;", ",": "&comma;", "@": "&commat;", "": "&complement;", "": "&congdot;", "": "&copf;", "": "&copysr;", "": "&crarr;", "": "&cross;", "": "&cscr;", "": "&csub;", "": "&csube;", "": "&csup;", "": "&csupe;", "": "&ctdot;", "": "&cudarrl;", "": "&cudarrr;", "": "&curlyeqprec;", "": "&curlyeqsucc;", "": "&curvearrowleft;", "": "&cularrp;", "": "&cup;", "": "&cupbrcap;", "": "&cupcap;", "": "&cupcup;", "": "&cupdot;", "": "&cupor;", "": "&cups;", "": "&curvearrowright;", "": "&curarrm;", "": "&cuvee;", "": "&cuwed;", "": "&curren;", "": "&cwint;", "": "&cylcty;", "": "&dHar;", "": "&dagger;", "": "&daleth;", "": "&hyphen;", "": "&rBarr;", "": "&dcaron;", "": "&dcy;", "": "&downdownarrows;", "": "&eDDot;", "": "&deg;", "": "&delta;", "": "&demptyv;", "": "&dfisht;", "": "&dfr;", "": "&diams;", "": "&gammad;", "": "&disin;", "": "&divide;", "": "&divonx;", "": "&djcy;", "": "&llcorner;", "": "&dlcrop;", $: "&dollar;", "": "&dopf;", "": "&eDot;", "": "&minusd;", "": "&plusdo;", "": "&sdotb;", "": "&lrcorner;", "": "&drcrop;", "": "&dscr;", "": "&dscy;", "": "&dsol;", "": "&dstrok;", "": "&dtdot;", "": "&triangledown;", "": "&dwangle;", "": "&dzcy;", "": "&dzigrarr;", "": "&eacute;", "": "&easter;", "": "&ecaron;", "": "&eqcirc;", "": "&ecirc;", "": "&eqcolon;", "": "&ecy;", "": "&edot;", "": "&fallingdotseq;", "": "&efr;", "": "&eg;", "": "&egrave;", "": "&eqslantgtr;", "": "&egsdot;", "": "&el;", "": "&elinters;", "": "&ell;", "": "&eqslantless;", "": "&elsdot;", "": "&emacr;", "": "&varnothing;", "": "&emsp13;", "": "&emsp14;", "": "&emsp;", "": "&eng;", "": "&ensp;", "": "&eogon;", "": "&eopf;", "": "&epar;", "": "&eparsl;", "": "&eplus;", "": "&epsilon;", "": "&varepsilon;", "=": "&equals;", "": "&questeq;", "": "&equivDD;", "": "&eqvparsl;", "": "&risingdotseq;", "": "&erarr;", "": "&escr;", "": "&eta;", "": "&eth;", "": "&euml;", "": "&euro;", "!": "&excl;", "": "&fcy;", "": "&female;", "": "&ffilig;", "": "&fflig;", "": "&ffllig;", "": "&ffr;", "": "&filig;", fj: "&fjlig;", "": "&flat;", "": "&fllig;", "": "&fltns;", "": "&fnof;", "": "&fopf;", "": "&pitchfork;", "": "&forkv;", "": "&fpartint;", "": "&half;", "": "&frac13;", "": "&frac14;", "": "&frac15;", "": "&frac16;", "": "&frac18;", "": "&frac23;", "": "&frac25;", "": "&frac34;", "": "&frac35;", "": "&frac38;", "": "&frac45;", "": "&frac56;", "": "&frac58;", "": "&frac78;", "": "&frasl;", "": "&sfrown;", "": "&fscr;", "": "&gtreqqless;", "": "&gacute;", "": "&gamma;", "": "&gtrapprox;", "": "&gbreve;", "": "&gcirc;", "": "&gcy;", "": "&gdot;", "": "&gescc;", "": "&gesdot;", "": "&gesdoto;", "": "&gesdotol;", "": "&gesl;", "": "&gesles;", "": "&gfr;", "": "&gimel;", "": "&gjcy;", "": "&glE;", "": "&gla;", "": "&glj;", "": "&gneqq;", "": "&gnapprox;", "": "&gneq;", "": "&gnsim;", "": "&gopf;", "": "&gscr;", "": "&gsime;", "": "&gsiml;", "": "&gtcc;", "": "&gtcir;", "": "&gtrdot;", "": "&gtlPar;", "": "&gtquest;", "": "&gtrarr;", "": "&gvnE;", "": "&hardcy;", "": "&harrcir;", "": "&leftrightsquigarrow;", "": "&plankv;", "": "&hcirc;", "": "&heartsuit;", "": "&mldr;", "": "&hercon;", "": "&hfr;", "": "&searhk;", "": "&swarhk;", "": "&hoarr;", "": "&homtht;", "": "&larrhk;", "": "&rarrhk;", "": "&hopf;", "": "&horbar;", "": "&hscr;", "": "&hstrok;", "": "&hybull;", "": "&iacute;", "": "&icirc;", "": "&icy;", "": "&iecy;", "": "&iexcl;", "": "&ifr;", "": "&igrave;", "": "&qint;", "": "&tint;", "": "&iinfin;", "": "&iiota;", "": "&ijlig;", "": "&imacr;", "": "&inodot;", "": "&imof;", "": "&imped;", "": "&incare;", "": "&infin;", "": "&infintie;", "": "&intercal;", "": "&intlarhk;", "": "&iprod;", "": "&iocy;", "": "&iogon;", "": "&iopf;", "": "&iota;", "": "&iquest;", "": "&iscr;", "": "&isinE;", "": "&isindot;", "": "&isins;", "": "&isinsv;", "": "&itilde;", "": "&iukcy;", "": "&iuml;", "": "&jcirc;", "": "&jcy;", "": "&jfr;", "": "&jmath;", "": "&jopf;", "": "&jscr;", "": "&jsercy;", "": "&jukcy;", "": "&kappa;", "": "&varkappa;", "": "&kcedil;", "": "&kcy;", "": "&kfr;", "": "&kgreen;", "": "&khcy;", "": "&kjcy;", "": "&kopf;", "": "&kscr;", "": "&lAtail;", "": "&lBarr;", "": "&lesseqqgtr;", "": "&lHar;", "": "&lacute;", "": "&laemptyv;", "": "&lambda;", "": "&langd;", "": "&lessapprox;", "": "&laquo;", "": "&larrbfs;", "": "&larrfs;", "": "&looparrowleft;", "": "&larrpl;", "": "&larrsim;", "": "&leftarrowtail;", "": "&lat;", "": "&latail;", "": "&late;", "": "&lates;", "": "&lbarr;", "": "&lbbrk;", "{": "&lcub;", "[": "&lsqb;", "": "&lbrke;", "": "&lbrksld;", "": "&lbrkslu;", "": "&lcaron;", "": "&lcedil;", "": "&lcy;", "": "&ldca;", "": "&ldrdhar;", "": "&ldrushar;", "": "&ldsh;", "": "&leq;", "": "&llarr;", "": "&lthree;", "": "&lescc;", "": "&lesdot;", "": "&lesdoto;", "": "&lesdotor;", "": "&lesg;", "": "&lesges;", "": "&ltdot;", "": "&lfisht;", "": "&lfr;", "": "&lgE;", "": "&lharul;", "": "&lhblk;", "": "&ljcy;", "": "&llhard;", "": "&lltri;", "": "&lmidot;", "": "&lmoustache;", "": "&lneqq;", "": "&lnapprox;", "": "&lneq;", "": "&lnsim;", "": "&loang;", "": "&loarr;", "": "&xmap;", "": "&rarrlp;", "": "&lopar;", "": "&lopf;", "": "&loplus;", "": "&lotimes;", "": "&lowast;", "": "&lozenge;", "(": "&lpar;", "": "&lparlt;", "": "&lrhard;", "": "&lrm;", "": "&lrtri;", "": "&lsaquo;", "": "&lscr;", "": "&lsime;", "": "&lsimg;", "": "&sbquo;", "": "&lstrok;", "": "&ltcc;", "": "&ltcir;", "": "&ltimes;", "": "&ltlarr;", "": "&ltquest;", "": "&ltrPar;", "": "&triangleleft;", "": "&lurdshar;", "": "&luruhar;", "": "&lvnE;", "": "&mDDot;", "": "&strns;", "": "&male;", "": "&maltese;", "": "&marker;", "": "&mcomma;", "": "&mcy;", "": "&mdash;", "": "&mfr;", "": "&mho;", "": "&micro;", "": "&midcir;", "": "&minus;", "": "&minusdu;", "": "&mlcp;", "": "&models;", "": "&mopf;", "": "&mscr;", "": "&mu;", "": "&mumap;", "": "&nGg;", "": "&nGt;", "": "&nlArr;", "": "&nhArr;", "": "&nLl;", "": "&nLt;", "": "&nrArr;", "": "&nVDash;", "": "&nVdash;", "": "&nacute;", "": "&nang;", "": "&napE;", "": "&napid;", "": "&napos;", "": "&natural;", "": "&ncap;", "": "&ncaron;", "": "&ncedil;", "": "&ncongdot;", "": "&ncup;", "": "&ncy;", "": "&ndash;", "": "&neArr;", "": "&nearhk;", "": "&nedot;", "": "&toea;", "": "&nfr;", "": "&nleftrightarrow;", "": "&nhpar;", "": "&nis;", "": "&nisd;", "": "&njcy;", "": "&nleqq;", "": "&nleftarrow;", "": "&nldr;", "": "&nopf;", "": "&not;", "": "&notinE;", "": "&notindot;", "": "&notinvb;", "": "&notinvc;", "": "&notnivb;", "": "&notnivc;", "": "&nparsl;", "": "&npart;", "": "&npolint;", "": "&nrightarrow;", "": "&nrarrc;", "": "&nrarrw;", "": "&nscr;", "": "&nsub;", "": "&nsubseteqq;", "": "&nsup;", "": "&nsupseteqq;", "": "&ntilde;", "": "&nu;", "#": "&num;", "": "&numero;", "": "&numsp;", "": "&nvDash;", "": "&nvHarr;", "": "&nvap;", "": "&nvdash;", "": "&nvge;", ">": "&nvgt;", "": "&nvinfin;", "": "&nvlArr;", "": "&nvle;", "<": "&nvlt;", "": "&nvltrie;", "": "&nvrArr;", "": "&nvrtrie;", "": "&nvsim;", "": "&nwArr;", "": "&nwarhk;", "": "&nwnear;", "": "&oacute;", "": "&ocirc;", "": "&ocy;", "": "&odblac;", "": "&odiv;", "": "&odsold;", "": "&oelig;", "": "&ofcir;", "": "&ofr;", "": "&ogon;", "": "&ograve;", "": "&ogt;", "": "&ohbar;", "": "&olcir;", "": "&olcross;", "": "&olt;", "": "&omacr;", "": "&omega;", "": "&omicron;", "": "&omid;", "": "&oopf;", "": "&opar;", "": "&operp;", "": "&vee;", "": "&ord;", "": "&oscr;", "": "&ordf;", "": "&ordm;", "": "&origof;", "": "&oror;", "": "&orslope;", "": "&orv;", "": "&oslash;", "": "&osol;", "": "&otilde;", "": "&otimesas;", "": "&ouml;", "": "&ovbar;", "": "&para;", "": "&parsim;", "": "&parsl;", "": "&pcy;", "%": "&percnt;", ".": "&period;", "": "&permil;", "": "&pertenk;", "": "&pfr;", "": "&phi;", "": "&varphi;", "": "&phone;", "": "&pi;", "": "&varpi;", "": "&planckh;", "+": "&plus;", "": "&plusacir;", "": "&pluscir;", "": "&plusdu;", "": "&pluse;", "": "&plussim;", "": "&plustwo;", "": "&pointint;", "": "&popf;", "": "&pound;", "": "&prE;", "": "&precapprox;", "": "&prnap;", "": "&prnE;", "": "&prnsim;", "": "&prime;", "": "&profalar;", "": "&profline;", "": "&profsurf;", "": "&prurel;", "": "&pscr;", "": "&psi;", "": "&puncsp;", "": "&qfr;", "": "&qopf;", "": "&qprime;", "": "&qscr;", "": "&quatint;", "?": "&quest;", "": "&rAtail;", "": "&rHar;", "": "&race;", "": "&racute;", "": "&raemptyv;", "": "&rangd;", "": "&range;", "": "&raquo;", "": "&rarrap;", "": "&rarrbfs;", "": "&rarrc;", "": "&rarrfs;", "": "&rarrpl;", "": "&rarrsim;", "": "&rightarrowtail;", "": "&rightsquigarrow;", "": "&ratail;", "": "&ratio;", "": "&rbbrk;", "}": "&rcub;", "]": "&rsqb;", "": "&rbrke;", "": "&rbrksld;", "": "&rbrkslu;", "": "&rcaron;", "": "&rcedil;", "": "&rcy;", "": "&rdca;", "": "&rdldhar;", "": "&rdsh;", "": "&rect;", "": "&rfisht;", "": "&rfr;", "": "&rharul;", "": "&rho;", "": "&varrho;", "": "&rrarr;", "": "&rthree;", "": "&ring;", "": "&rlm;", "": "&rmoustache;", "": "&rnmid;", "": "&roang;", "": "&roarr;", "": "&ropar;", "": "&ropf;", "": "&roplus;", "": "&rotimes;", ")": "&rpar;", "": "&rpargt;", "": "&rppolint;", "": "&rsaquo;", "": "&rscr;", "": "&rtimes;", "": "&triangleright;", "": "&rtriltri;", "": "&ruluhar;", "": "&rx;", "": "&sacute;", "": "&scE;", "": "&succapprox;", "": "&scaron;", "": "&scedil;", "": "&scirc;", "": "&succneqq;", "": "&succnapprox;", "": "&succnsim;", "": "&scpolint;", "": "&scy;", "": "&sdot;", "": "&sdote;", "": "&seArr;", "": "&sect;", ";": "&semi;", "": "&tosa;", "": "&sext;", "": "&sfr;", "": "&sharp;", "": "&shchcy;", "": "&shcy;", "": "&shy;", "": "&sigma;", "": "&varsigma;", "": "&simdot;", "": "&simg;", "": "&simgE;", "": "&siml;", "": "&simlE;", "": "&simne;", "": "&simplus;", "": "&simrarr;", "": "&smashp;", "": "&smeparsl;", "": "&ssmile;", "": "&smt;", "": "&smte;", "": "&smtes;", "": "&softcy;", "/": "&sol;", "": "&solb;", "": "&solbar;", "": "&sopf;", "": "&spadesuit;", "": "&sqcaps;", "": "&sqcups;", "": "&sscr;", "": "&star;", "": "&subset;", "": "&subseteqq;", "": "&subdot;", "": "&subedot;", "": "&submult;", "": "&subsetneqq;", "": "&subsetneq;", "": "&subplus;", "": "&subrarr;", "": "&subsim;", "": "&subsub;", "": "&subsup;", "": "&sung;", "": "&sup1;", "": "&sup2;", "": "&sup3;", "": "&supseteqq;", "": "&supdot;", "": "&supdsub;", "": "&supedot;", "": "&suphsol;", "": "&suphsub;", "": "&suplarr;", "": "&supmult;", "": "&supsetneqq;", "": "&supsetneq;", "": "&supplus;", "": "&supsim;", "": "&supsub;", "": "&supsup;", "": "&swArr;", "": "&swnwar;", "": "&szlig;", "": "&target;", "": "&tau;", "": "&tcaron;", "": "&tcedil;", "": "&tcy;", "": "&telrec;", "": "&tfr;", "": "&theta;", "": "&vartheta;", "": "&thorn;", "": "&times;", "": "&timesbar;", "": "&timesd;", "": "&topbot;", "": "&topcir;", "": "&topf;", "": "&topfork;", "": "&tprime;", "": "&utri;", "": "&trie;", "": "&tridot;", "": "&triminus;", "": "&triplus;", "": "&trisb;", "": "&tritime;", "": "&trpezium;", "": "&tscr;", "": "&tscy;", "": "&tshcy;", "": "&tstrok;", "": "&uHar;", "": "&uacute;", "": "&ubrcy;", "": "&ubreve;", "": "&ucirc;", "": "&ucy;", "": "&udblac;", "": "&ufisht;", "": "&ufr;", "": "&ugrave;", "": "&uhblk;", "": "&ulcorner;", "": "&ulcrop;", "": "&ultri;", "": "&umacr;", "": "&uogon;", "": "&uopf;", "": "&upsilon;", "": "&uuarr;", "": "&urcorner;", "": "&urcrop;", "": "&uring;", "": "&urtri;", "": "&uscr;", "": "&utdot;", "": "&utilde;", "": "&uuml;", "": "&uwangle;", "": "&vBar;", "": "&vBarv;", "": "&vangrt;", "": "&vsubne;", "": "&vsubnE;", "": "&vsupne;", "": "&vsupnE;", "": "&vcy;", "": "&veebar;", "": "&veeeq;", "": "&vellip;", "": "&vfr;", "": "&vopf;", "": "&vscr;", "": "&vzigzag;", "": "&wcirc;", "": "&wedbar;", "": "&wedgeq;", "": "&wp;", "": "&wfr;", "": "&wopf;", "": "&wscr;", "": "&xfr;", "": "&xi;", "": "&xnis;", "": "&xopf;", "": "&xscr;", "": "&yacute;", "": "&yacy;", "": "&ycirc;", "": "&ycy;", "": "&yen;", "": "&yfr;", "": "&yicy;", "": "&yopf;", "": "&yscr;", "": "&yucy;", "": "&yuml;", "": "&zacute;", "": "&zcaron;", "": "&zcy;", "": "&zdot;", "": "&zeta;", "": "&zfr;", "": "&zhcy;", "": "&zigrarr;", "": "&zopf;", "": "&zscr;", "": "&zwj;", "": "&zwnj;" } } };
var numericUnicodeMap = {};
Object.defineProperty(numericUnicodeMap, "__esModule", { value: true });
numericUnicodeMap.numericUnicodeMap = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
var surrogatePairs = {};
Object.defineProperty(surrogatePairs, "__esModule", { value: true });
surrogatePairs.fromCodePoint = String.fromCodePoint || function(astralCodePoint) {
  return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
};
surrogatePairs.getCodePoint = String.prototype.codePointAt ? function(input, position2) {
  return input.codePointAt(position2);
} : function(input, position2) {
  return (input.charCodeAt(position2) - 55296) * 1024 + input.charCodeAt(position2 + 1) - 56320 + 65536;
};
surrogatePairs.highSurrogateFrom = 55296;
surrogatePairs.highSurrogateTo = 56319;
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(lib, "__esModule", { value: true });
var named_references_1 = namedReferences;
var numeric_unicode_map_1 = numericUnicodeMap;
var surrogate_pairs_1 = surrogatePairs;
var allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), { all: named_references_1.namedReferences.html5 });
function replaceUsingRegExp(macroText, macroRegExp, macroReplacer) {
  macroRegExp.lastIndex = 0;
  var replaceMatch = macroRegExp.exec(macroText);
  var replaceResult;
  if (replaceMatch) {
    replaceResult = "";
    var replaceLastIndex = 0;
    do {
      if (replaceLastIndex !== replaceMatch.index) {
        replaceResult += macroText.substring(replaceLastIndex, replaceMatch.index);
      }
      var replaceInput = replaceMatch[0];
      replaceResult += macroReplacer(replaceInput);
      replaceLastIndex = replaceMatch.index + replaceInput.length;
    } while (replaceMatch = macroRegExp.exec(macroText));
    if (replaceLastIndex !== macroText.length) {
      replaceResult += macroText.substring(replaceLastIndex);
    }
  } else {
    replaceResult = macroText;
  }
  return replaceResult;
}
var encodeRegExps = { specialChars: /[<>'"&]/g, nonAscii: /[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, nonAsciiPrintable: /[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, nonAsciiPrintableOnly: /[\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, extensive: /[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g };
var defaultEncodeOptions = { mode: "specialChars", level: "all", numeric: "decimal" };
function encode(text, _a2) {
  var _b2 = _a2 === void 0 ? defaultEncodeOptions : _a2, _c2 = _b2.mode, mode = _c2 === void 0 ? "specialChars" : _c2, _d2 = _b2.numeric, numeric = _d2 === void 0 ? "decimal" : _d2, _e2 = _b2.level, level = _e2 === void 0 ? "all" : _e2;
  if (!text) {
    return "";
  }
  var encodeRegExp = encodeRegExps[mode];
  var references = allNamedReferences[level].characters;
  var isHex = numeric === "hexadecimal";
  return replaceUsingRegExp(text, encodeRegExp, function(input) {
    var result = references[input];
    if (!result) {
      var code = input.length > 1 ? surrogate_pairs_1.getCodePoint(input, 0) : input.charCodeAt(0);
      result = (isHex ? "&#x" + code.toString(16) : "&#" + code) + ";";
    }
    return result;
  });
}
lib.encode = encode;
var defaultDecodeOptions = { scope: "body", level: "all" };
var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
var baseDecodeRegExps = { xml: { strict, attribute, body: named_references_1.bodyRegExps.xml }, html4: { strict, attribute, body: named_references_1.bodyRegExps.html4 }, html5: { strict, attribute, body: named_references_1.bodyRegExps.html5 } };
var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
var fromCharCode = String.fromCharCode;
var outOfBoundsChar = fromCharCode(65533);
var defaultDecodeEntityOptions = { level: "all" };
function getDecodedEntity(entity, references, isAttribute, isStrict) {
  var decodeResult = entity;
  var decodeEntityLastChar = entity[entity.length - 1];
  if (isAttribute && decodeEntityLastChar === "=") {
    decodeResult = entity;
  } else if (isStrict && decodeEntityLastChar !== ";") {
    decodeResult = entity;
  } else {
    var decodeResultByReference = references[entity];
    if (decodeResultByReference) {
      decodeResult = decodeResultByReference;
    } else if (entity[0] === "&" && entity[1] === "#") {
      var decodeSecondChar = entity[2];
      var decodeCode = decodeSecondChar == "x" || decodeSecondChar == "X" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
      decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode] || decodeCode);
    }
  }
  return decodeResult;
}
function decodeEntity(entity, _a2) {
  var _b2 = (_a2 === void 0 ? defaultDecodeEntityOptions : _a2).level, level = _b2 === void 0 ? "all" : _b2;
  if (!entity) {
    return "";
  }
  return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);
}
var decodeEntity_1 = lib.decodeEntity = decodeEntity;
function decode(text, _a2) {
  var _b2 = _a2 === void 0 ? defaultDecodeOptions : _a2, _c2 = _b2.level, level = _c2 === void 0 ? "all" : _c2, _d2 = _b2.scope, scope = _d2 === void 0 ? level === "xml" ? "strict" : "body" : _d2;
  if (!text) {
    return "";
  }
  var decodeRegExp = decodeRegExps[level][scope];
  var references = allNamedReferences[level].entities;
  var isAttribute = scope === "attribute";
  var isStrict = scope === "strict";
  return replaceUsingRegExp(text, decodeRegExp, function(entity) {
    return getDecodedEntity(entity, references, isAttribute, isStrict);
  });
}
var decode_1 = lib.decode = decode;
const LOCATION_DATA$1 = [
  ["A Deserted Stretch of I-911", "A Deserted Stretch of I-911", 373],
  ["Astral", "An Incredibly Strange Place (Bad Trip)", 96],
  ["Astral", "An Incredibly Strange Place (Great Trip)", 97],
  ["Astral", "An Incredibly Strange Place (Mediocre Trip)", 98],
  ["BadMoon", "Heartbreaker's Hotel", 148],
  ["BatHole", "Guano Junction", 31],
  ["BatHole", "The Bat Hole Entrance", 30],
  ["BatHole", "The Batrat and Ratbat Burrow", 32],
  ["BatHole", "The Beanbat Chamber", 33],
  ["BatHole", "The Boss Bat's Lair", 34],
  ["Beach", "Kokomo Resort", 446],
  ["Beach", "South of the Border", 45],
  ["Beach", "The Arid, Extra-Dry Desert", 364],
  ["Beach", "The Oasis", 122],
  ["Beach", "The Shore, Inc. Travel Agency", 355],
  ["Beanstalk", "The Castle in the Clouds in the Sky (Basement)", 322],
  ["Beanstalk", "The Castle in the Clouds in the Sky (Ground Floor)", 323],
  ["Beanstalk", "The Castle in the Clouds in the Sky (Top Floor)", 324],
  ["Beanstalk", "The Hole in the Sky", 83],
  ["Beanstalk", "The Penultimate Fantasy Airship", 81],
  ["Campground", "Your Mushroom Garden", 543],
  ["Casino", "Goat Party", null],
  ["Casino", "Lemon Party", null],
  ["Casino", "Pirate Party", null],
  ["Casino", "The Poker Room", 71],
  ["Casino", "The Roulette Tables", 70],
  ["Center Park (Low Crime)", "Center Park After Dark", 461],
  ["Center Park (Low Crime)", "Gotpork Conservatory of Flowers", 464],
  ["Center Park (Low Crime)", "Gotpork Gardens Cemetery", 466],
  ["Center Park (Low Crime)", "Gotpork Municipal Reservoir", 465],
  ["Clan Basement", "The Slime Tube", 203],
  ["Conspiracy Island", "The Deep Dark Jungle", 417],
  ["Conspiracy Island", "The Mansion of Dr. Weirdeaux", 415],
  ["Conspiracy Island", "The Secret Government Laboratory", 416],
  ["Crimbo05", "Crimbo Town Toy Factory (2005)", 93],
  ["Crimbo06", "Crimborg Collective Factory", 117],
  ["Crimbo06", "Simple Tool-Making Cave", 115],
  ["Crimbo06", "Spooky Fright Factory", 116],
  ["Crimbo07", "Crimbo Town Toy Factory (2007)", 162],
  ["Crimbo07", "Sinister Dodecahedron", 161],
  ["Crimbo08", "Atomic Crimbo Toy Factory", 192],
  ["Crimbo08", "Old Crimbo Town Toy Factory", 193],
  ["Crimbo09", "Crimbo Town Toy Factory (2009)", 222],
  ["Crimbo09", "The Don's Crimbo Compound", 223],
  ["Crimbo10", "CRIMBCO WC", null],
  ["Crimbo10", "CRIMBCO cubicles", 247],
  ["Crimbo10", "Elf Alley", 246],
  ["Crimbo12", "Crimbo Town Toy Factory (2012)", 300],
  ["Crimbo13", "WarBear Fortress (First Level)", 366],
  ["Crimbo13", "WarBear Fortress (Second Level)", 367],
  ["Crimbo13", "WarBear Fortress (Third Level)", 368],
  ["Crimbo14", "The Crimbonium Mine", null],
  ["Crimbo14", "The Crimbonium Mining Camp", 419],
  ["Crimbo15", "The Ruins of the Fully Automated Crimbo Factory", 459],
  ["Crimbo16", "Crimbo's Beard", 492],
  ["Crimbo16", "Crimbo's Boots", 489],
  ["Crimbo16", "Crimbo's Hat", 493],
  ["Crimbo16", "Crimbo's Jelly", 490],
  ["Crimbo16", "Crimbo's Reindeer", 491],
  ["Crimbo16", "Crimbo's Sack", 488],
  ["Crimbo16", "Your Bung Chakra", 482],
  ["Crimbo16", "Your Guts Chakra", 483],
  ["Crimbo16", "Your Hat Chakra", 487],
  ["Crimbo16", "Your Liver Chakra", 484],
  ["Crimbo16", "Your Nipple Chakra", 485],
  ["Crimbo16", "Your Nose Chakra", 486],
  ["Crimbo17", "The Cheerless Spire (Level 1)", 497],
  ["Crimbo17", "The Cheerless Spire (Level 2)", 498],
  ["Crimbo17", "The Cheerless Spire (Level 3)", 499],
  ["Crimbo17", "The Cheerless Spire (Level 4)", 500],
  ["Crimbo17", "The Cheerless Spire (Level 5)", 501],
  ["Crimbo18", "The Canadian Wildlife Preserve", 529],
  ["Crimbo21", "Site Alpha Dormitory", 554],
  ["Crimbo21", "Site Alpha Greenhouse", 555],
  ["Crimbo21", "Site Alpha Primary Lab", 557],
  ["Crimbo21", "Site Alpha Quarry", 556],
  ["Crimbo22", "Crimbo Train (Caboose)", 559],
  ["Crimbo22", "Crimbo Train (Coal Car)", 562],
  ["Crimbo22", "Crimbo Train (Dining Car)", 561],
  ["Crimbo22", "Crimbo Train (Locomotive)", null],
  ["Crimbo22", "Crimbo Train (Passenger Car)", 560],
  ["Crimbo23", "A Cafe Divided", 578],
  ["Crimbo23", "Abuela's Cottage (Contested)", 575],
  ["Crimbo23", "The Armory Up In Arms", 579],
  ["Crimbo23", "The Bar At War", 577],
  ["Crimbo23", "The Embattled Factory", 576],
  ["Cyrpt", "Haert of the Cyrpt", null],
  ["Cyrpt", "The Defiled Alcove", 261],
  ["Cyrpt", "The Defiled Cranny", 262],
  ["Cyrpt", "The Defiled Niche", 263],
  ["Cyrpt", "The Defiled Nook", 264],
  ["Deep Machine Tunnels", "The Deep Machine Tunnels", 458],
  ["Degrassi Knoll", "The Degrassi Knoll Bakery", 352],
  ["Degrassi Knoll", "The Degrassi Knoll Garage", 354],
  ["Degrassi Knoll", "The Degrassi Knoll Gym", 353],
  ["Degrassi Knoll", "The Degrassi Knoll Restroom", 351],
  ["Dinseylandfill", "Barf Mountain", 442],
  ["Dinseylandfill", "Pirates of the Garbage Barges", 443],
  ["Dinseylandfill", "The Toxic Teacups", 444],
  ["Dinseylandfill", "Uncle Gator's Country Fun-Time Liquid Waste Sluice", 445],
  ["Downtown", "JokesterCo", 473],
  ["Dreadsylvania", "Dreadsylvanian Castle", 340],
  ["Dreadsylvania", "Dreadsylvanian Village", 339],
  ["Dreadsylvania", "Dreadsylvanian Woods", 338],
  ["Dungeon", "The Daily Dungeon", 325],
  ["Dungeon", "The Dungeons of Doom", 39],
  ["Dungeon", "The Enormous Greater-Than Sign", 226],
  ["Dungeon", "The Haiku Dungeon", 138],
  ["Dungeon", "The Limerick Dungeon", 19],
  ["Ellsbury's Claim", "Neckback Crick", 236],
  ["Events", "A Crater Full of Space Beasts", 409],
  ["Exploathing", "The Exploaded Battlefield", 533],
  ["Exploathing", "The Invader", 534],
  ["FantasyRealm", "Duke Vampire's Chateau", 521],
  ["FantasyRealm", "Near the Witch's House", 513],
  ["FantasyRealm", "The Archwizard's Tower", 524],
  ["FantasyRealm", "The Bandit Crossroads", 502],
  ["FantasyRealm", "The Barrow Mounds", 515],
  ["FantasyRealm", "The Cursed Village Thieves' Guild", 516],
  ["FantasyRealm", "The Cursed Village", 506],
  ["FantasyRealm", "The Dragon's Moor", 520],
  ["FantasyRealm", "The Druidic Campsite", 512],
  ["FantasyRealm", "The Evil Cathedral", 514],
  ["FantasyRealm", "The Faerie Cyrkle", 511],
  ["FantasyRealm", "The Foreboding Cave", 510],
  ["FantasyRealm", "The Ghoul King's Catacomb", 526],
  ["FantasyRealm", "The Labyrinthine Crypt", 518],
  ["FantasyRealm", "The Lair of the Phoenix", 519],
  ["FantasyRealm", "The Ley Nexus", 525],
  ["FantasyRealm", "The Master Thief's Chalet", 522],
  ["FantasyRealm", "The Mystic Wood", 504],
  ["FantasyRealm", "The Ogre Chieftain's Keep", 527],
  ["FantasyRealm", "The Old Rubee Mine", 509],
  ["FantasyRealm", "The Putrid Swamp", 505],
  ["FantasyRealm", "The Spider Queen's Lair", 523],
  ["FantasyRealm", "The Sprawling Cemetery", 507],
  ["FantasyRealm", "The Towering Mountains", 503],
  ["FantasyRealm", "The Troll Fortress", 517],
  ["Farm", "McMillicancuddy's Back 40", 142],
  ["Farm", "McMillicancuddy's Barn", 137],
  ["Farm", "McMillicancuddy's Bog", 145],
  ["Farm", "McMillicancuddy's Family Plot", 146],
  ["Farm", "McMillicancuddy's Granary", 144],
  ["Farm", "McMillicancuddy's Other Back 40", 143],
  ["Farm", "McMillicancuddy's Pond", 141],
  ["Farm", "McMillicancuddy's Shady Thicket", 147],
  ["Fernswarthy's Tower", "Fernswarthy's Basement", null],
  ["Fernswarthy's Tower", "Tower Ruins", 22],
  ["Friars", "Friar Ceremony Location", null],
  ["Friars", "Pandamonium", 438],
  ["Friars", "The Dark Elbow of the Woods", 539],
  ["Friars", "The Dark Heart of the Woods", 540],
  ["Friars", "The Dark Neck of the Woods", 541],
  ["Gingerbread City", "Gingerbread Civic Center", 477],
  ["Gingerbread City", "Gingerbread Industrial Zone", 479],
  ["Gingerbread City", "Gingerbread Sewers", 481],
  ["Gingerbread City", "Gingerbread Train Station", 478],
  ["Gingerbread City", "Gingerbread Upscale Retail District", 480],
  ["Gyms", "Pump Up Moxie", null],
  ["Gyms", "Pump Up Muscle", null],
  ["Gyms", "Pump Up Mysticality", null],
  ["Gyms", "Richard's Hobo Moxie", null],
  ["Gyms", "Richard's Hobo Muscle", null],
  ["Gyms", "Richard's Hobo Mysticality", null],
  ["HiddenCity", "A Massive Ziggurat", 350],
  ["HiddenCity", "An Overgrown Shrine (Northeast)", 348],
  ["HiddenCity", "An Overgrown Shrine (Northwest)", 346],
  ["HiddenCity", "An Overgrown Shrine (Southeast)", 349],
  ["HiddenCity", "An Overgrown Shrine (Southwest)", 347],
  ["HiddenCity", "The Hidden Apartment Building", 341],
  ["HiddenCity", "The Hidden Bowling Alley", 344],
  ["HiddenCity", "The Hidden Hospital", 342],
  ["HiddenCity", "The Hidden Office Building", 343],
  ["HiddenCity", "The Hidden Park", 345],
  ["Highlands", "A-Boo Peak", 296],
  ["Highlands", "Oil Peak", 298],
  ["Highlands", "Twin Peak", 297],
  ["Hobopolis", "A Maze of Sewer Tunnels", 166],
  ["Hobopolis", "Burnbarrel Blvd.", 168],
  ["Hobopolis", "Exposure Esplanade", 169],
  ["Hobopolis", "Hobopolis Town Square", 167],
  ["Hobopolis", "The Ancient Hobo Burial Ground", 171],
  ["Hobopolis", "The Heap", 170],
  ["Hobopolis", "The Purple Light District", 172],
  ["Holiday", "Drunken Stupor", 23],
  ["Holiday", "Generic Summer Holiday Swimming!", 173],
  ["Holiday", "St. Sneaky Pete's Day Stupor", 84],
  ["Holiday", "The Arrrboretum", 174],
  ["Holiday", "The Spectral Pickle Factory", 37],
  ["Holiday", "The Yuletide Bonfire", 163],
  ["Holiday", "Trick-or-Treating", null],
  ["Industrial District (High Crime)", "Gotpork Clock, Inc.", 470],
  ["Industrial District (High Crime)", "Gotpork Foundry", 471],
  ["Industrial District (High Crime)", "Trivial Pursuits, LLC", 472],
  ["Industrial District (High Crime)", "Warehouse Row", 463],
  ["Island", "Frat House (Frat Disguise)", 29],
  ["Island", "Frat House", 27],
  ["Island", "Hippy Camp (Hippy Disguise)", 65],
  ["Island", "Hippy Camp", 26],
  ["Island", "McMillicancuddy's Farm", 155],
  ["Island", "Sonofa Beach", 136],
  ["Island", "The Hippy Camp (Bombed Back to the Stone Age)", 149],
  ["Island", "The Junkyard", 154],
  ["Island", "The Obligatory Pirate's Cove", 66],
  ["Island", "The Orcish Frat House (Bombed Back to the Stone Age)", 150],
  ["IsleWar", "The Battlefield (Frat Uniform)", 132],
  ["IsleWar", "The Battlefield (Hippy Uniform)", 140],
  ["IsleWar", "The Themthar Hills", 126],
  ["IsleWar", "Wartime Frat House (Hippy Disguise)", 134],
  ["IsleWar", "Wartime Frat House", 135],
  ["IsleWar", "Wartime Hippy Camp (Frat Disguise)", 131],
  ["IsleWar", "Wartime Hippy Camp", 133],
  ["Jacking", "Professor Jacking's Huge-A-Ma-tron", 228],
  ["Jacking", "Professor Jacking's Small-O-Fier", 227],
  ["Jick's Obsessions", "The Tower of Procedurally-Generated Skeletons", 317],
  ["Junkyard", "Near an Abandoned Refrigerator", 183],
  ["Junkyard", "Next to that Barrel with Something Burning in it", 182],
  ["Junkyard", "Out by that Rusted-Out Car", 185],
  ["Junkyard", "Over Where the Old Tires Are", 184],
  ["KOL High School", "Art Class", 329],
  ["KOL High School", "Chemistry Class", 328],
  ["KOL High School", "Shop Class", 327],
  ["KOL High School", "The Hallowed Halls", 326],
  ["Kegger", "Kegger in the Woods", 231],
  ["Knob", "Cobb's Knob Barracks", 257],
  ["Knob", "Cobb's Knob Harem", 259],
  ["Knob", "Cobb's Knob Kitchens", 258],
  ["Knob", "Cobb's Knob Treasury", 260],
  ["Knob", "The Outskirts of Cobb's Knob", 114],
  ["Knob", "Throne Room", null],
  ["LT&T", "Investigating a Plaintive Telegram", 474],
  ["Lab", "Cobb's Knob Laboratory", 50],
  ["Lab", "The Knob Shaft (Mining)", null],
  ["Lab", "The Knob Shaft", 101],
  ["Landscaper", "The Landscaper's Lair", 224],
  ["Le Marais D&egrave;gueulasse", "Swamp Beaver Territory", 335],
  ["Le Marais D&egrave;gueulasse", "The Corpse Bog", 332],
  ["Le Marais D&egrave;gueulasse", "The Dark and Spooky Swamp", 331],
  ["Le Marais D&egrave;gueulasse", "The Edge of the Swamp", 330],
  ["Le Marais D&egrave;gueulasse", "The Ruined Wizard Tower", 333],
  ["Le Marais D&egrave;gueulasse", "The Weird Swamp Village", 336],
  ["Le Marais D&egrave;gueulasse", "The Wildlife Sanctuarrrrrgh", 334],
  ["Little Canadia", "Camp Logging Camp", 44],
  ["Little Canadia", "Outskirts of Camp Logging Camp", 43],
  ["Magic Commune", "The Electric Lemonade Acid Parade", 232],
  ["Manor0", "Summoning Chamber", null],
  ["Manor0", "The Haunted Boiler Room", 399],
  ["Manor0", "The Haunted Laundry Room", 400],
  ["Manor0", "The Haunted Wine Cellar", 401],
  ["Manor1", "The Haunted Billiards Room", 391],
  ["Manor1", "The Haunted Conservatory", 389],
  ["Manor1", "The Haunted Kitchen", 388],
  ["Manor1", "The Haunted Library", 390],
  ["Manor1", "The Haunted Pantry", 113],
  ["Manor2", "The Haunted Ballroom", 395],
  ["Manor2", "The Haunted Bathroom", 392],
  ["Manor2", "The Haunted Bedroom", 393],
  ["Manor2", "The Haunted Gallery", 394],
  ["Manor3", "The Haunted Laboratory", 396],
  ["Manor3", "The Haunted Nursery", 397],
  ["Manor3", "The Haunted Storage Room", 398],
  ["McLarge", "Dwarven Factory Warehouse", null],
  ["McLarge", "Itznotyerzitz Mine (in Disguise)", null],
  ["McLarge", "Itznotyerzitz Mine", 270],
  ["McLarge", "Lair of the Ninja Snowmen", 272],
  ["McLarge", "Mist-Shrouded Peak", null],
  ["McLarge", "The Goatlet", 271],
  ["McLarge", "The Icy Peak", 110],
  ["McLarge", "The Mine Foremens' Office", 176],
  ["McLarge", "The eXtreme Slope", 273],
  ["Memories", "Seaside Megalopolis", 206],
  ["Memories", "The Jungles of Ancient Loathing", 205],
  ["Memories", "The Primordial Soup", 204],
  ["Menagerie", "Cobb's Knob Menagerie, Level 1", 51],
  ["Menagerie", "Cobb's Knob Menagerie, Level 2", 52],
  ["Menagerie", "Cobb's Knob Menagerie, Level 3", 53],
  ["Mothership", "Engineering", 287],
  ["Mothership", "Galley", 289],
  ["Mothership", "Medbay", 281],
  ["Mothership", "Morgue", 285],
  ["Mothership", "Navigation", 288],
  ["Mothership", "Science Lab", 284],
  ["Mothership", "Sonar", 283],
  ["Mothership", "Special Ops", 286],
  ["Mothership", "Waste Processing", 282],
  ["Mountain", "Noob Cave", 240],
  ["Mountain", "The Dire Warren", 92],
  ["Mountain", "The Secret Council Warehouse", 437],
  ["Mountain", "The Smut Orc Logging Camp", 295],
  ["Mountain", "The Thinknerd Warehouse", 387],
  ["Mountain", "The Valley of Rof L'm Fao", 80],
  ["MoxSign", "Thugnderdome", 46],
  ["MusSign", "Post-Quest Bugbear Pens", 49],
  ["MusSign", "The Bugbear Pen", 47],
  ["MusSign", "The Spooky Gravy Burrow", 48],
  ["Nemesis Cave", "The Fungal Nethers", 452],
  ["Neverending Party", "The Neverending Party", 528],
  ["Obsolete", "8-Bit Realm", 73],
  ["Obsolete", "Degrassi Knoll", 18],
  ["Obsolete", "Nemesis Cave", 213],
  ["Obsolete", "OLD The Middle Chamber", 125],
  ["Obsolete", "OLD The Upper Chamber", 124],
  ["Obsolete", "The Arid, Extra-Dry Desert (Dehydrated)", 121],
  ["Obsolete", "The Arid, Extra-Dry Desert (Ultrahydrated)", 123],
  ["Obsolete", "The Black Forest (OLD)", 111],
  ["Obsolete", "The Haunted Bathroom (OLD)", 107],
  ["Obsolete", "The Haunted Bedroom (OLD)", 108],
  ["Obsolete", "The Haunted Billiards Room (OLD)", 105],
  ["Obsolete", "The Haunted Conservatory (OLD)", 103],
  ["Obsolete", "The Haunted Kitchen (OLD)", 102],
  ["Obsolete", "The Haunted Wine Cellar (Northeast", 179],
  ["Obsolete", "The Haunted Wine Cellar (Northwest)", 178],
  ["Obsolete", "The Haunted Wine Cellar (Southeast)", 181],
  ["Obsolete", "The Haunted Wine Cellar (Southwest)", 180],
  ["Obsolete", "The Hidden City", 118],
  ["Obsolete", "The Palindome (OLD)", 119],
  ["Obsolete", "The Road to White Citadel", 99],
  ["Orchard", "The Feeding Chamber", 128],
  ["Orchard", "The Filthworm Queen's Chamber", 130],
  ["Orchard", "The Hatching Chamber", 127],
  ["Orchard", "The Royal Guard Chamber", 129],
  ["Pandamonium", "Infernal Rackets Backstage", 243],
  ["Pandamonium", "Pandamonium Slums", 248],
  ["Pandamonium", "The Laugh Floor", 242],
  ["PastEvents", "A Freezing Abyssal Portal", 360],
  ["PastEvents", "A Massive Flying Battleship", null],
  ["PastEvents", "A Monorail Station", 508],
  ["PastEvents", "A Pile of Old Servers", 268],
  ["PastEvents", "A Scorching Abyssal Portal", 358],
  ["PastEvents", "A Skeleton Invasion!", 244],
  ["PastEvents", "A Stinking Abyssal Portal", 357],
  ["PastEvents", "A Supply Train", null],
  ["PastEvents", "A Swarm of Yeti-Mounted Skeletons", null],
  ["PastEvents", "A Terrifying Abyssal Portal", 359],
  ["PastEvents", "A Yawning Abyssal Portal", 362],
  ["PastEvents", "An Eldritch Fissure", null],
  ["PastEvents", "An Eldritch Horror", null],
  ["PastEvents", "An Unsettling Abyssal Portal", 361],
  ["PastEvents", "Fierce Flying Flames", 291],
  ["PastEvents", "Fightin' Fire", null],
  ["PastEvents", "Grim Grimacite Site", 156],
  ["PastEvents", "Lord Flameface's Castle Belfry", 293],
  ["PastEvents", "Lord Flameface's Castle Entryway", 292],
  ["PastEvents", "Lord Flameface's Throne Room", 294],
  ["PastEvents", "Monorail Work Site", 496],
  ["PastEvents", "Shivering Timbers", 216],
  ["PastEvents", "Some Scattered Smoking Debris", 408],
  ["PastEvents", "Spectral Salad Factory", 175],
  ["PastEvents", "Super-Intense Mega-Grassfire", 290],
  ["PastEvents", "The Bone Star", null],
  ["PastEvents", "The Bonewall", null],
  ["PastEvents", "The Cannon Museum", 245],
  ["PastEvents", "The Haunted Sorority House", 269],
  ["PastEvents", "The Space Odyssey Discotheque", 363],
  ["PastEvents", "The Spirit World", 365],
  ["Pirate", "Barrrney's Barrr", 157],
  ["Pirate", "Belowdecks", 160],
  ["Pirate", "The F'c'le", 158],
  ["Pirate", "The Poop Deck", 159],
  ["PirateRealm Island", "Battle Island", 531],
  ["PirateRealm Island", "Cemetery Island", 531],
  ["PirateRealm Island", "Crab Island", 531],
  ["PirateRealm Island", "Dessert Island", 531],
  ["PirateRealm Island", "Glass Island", 531],
  ["PirateRealm Island", "Isla Gublar", 531],
  ["PirateRealm Island", "Jack's Hideout", 531],
  ["PirateRealm Island", "Jungle Island", 531],
  ["PirateRealm Island", "Key Key", 531],
  ["PirateRealm Island", "Prison Island", 531],
  ["PirateRealm Island", "Red Roger's Fortress", 531],
  ["PirateRealm Island", "Signal Island", 531],
  ["PirateRealm Island", "Skull Island", 531],
  ["PirateRealm Island", "Storm Island", 531],
  ["PirateRealm Island", "The Temple", 531],
  ["PirateRealm Island", "Tiki Island", 531],
  ["PirateRealm Island", "Trash Island", 531],
  ["PirateRealm", "PirateRealm Island", 531],
  ["PirateRealm", "Sailing the PirateRealm Seas", 530],
  ["Plains", "Inside the Palindome", 386],
  ["Plains", 'The "Fun" House', 20],
  ["Plains", "The Unquiet Garves", 21],
  ["Plains", "The VERY Unquiet Garves", 58],
  ["Portal", "El Vibrato Island", 164],
  ["Pyramid", "The Lower Chambers", null],
  ["Pyramid", "The Middle Chamber", 407],
  ["Pyramid", "The Upper Chamber", 406],
  ["Rabbit Hole", "The Red Queen's Garden", 225],
  ["Rift", "Battlefield (Cloaca Uniform)", 86],
  ["Rift", "Battlefield (Dyspepsi Uniform)", 87],
  ["Rift", "Battlefield (No Uniform)", 85],
  ["Rumpelstiltskin's Home For Children", "Portal to Terrible Parents", 381],
  ["Rumpelstiltskin's Home For Children", "Rumpelstiltskin's Workshop", 382],
  ["Rumpelstiltskin's Home For Children", "Ye Olde Medievale Villagee", 380],
  ["Shadow Rift", "Shadow Rift (Desert Beach)", null],
  ["Shadow Rift", "Shadow Rift (Forest Village)", null],
  ["Shadow Rift", "Shadow Rift (Mt. McLargeHuge)", null],
  ["Shadow Rift", "Shadow Rift (Somewhere Over the Beanstalk)", null],
  ["Shadow Rift", "Shadow Rift (Spookyraven Manor Third Floor)", null],
  ["Shadow Rift", "Shadow Rift (The 8-Bit Realm)", null],
  ["Shadow Rift", "Shadow Rift (The Ancient Buried Pyramid)", null],
  ["Shadow Rift", "Shadow Rift (The Castle in the Clouds in the Sky)", null],
  ["Shadow Rift", "Shadow Rift (The Distant Woods)", null],
  ["Shadow Rift", "Shadow Rift (The Hidden City)", null],
  ["Shadow Rift", "Shadow Rift (The Misspelled Cemetary)", null],
  ["Shadow Rift", "Shadow Rift (The Nearby Plains)", null],
  ["Shadow Rift", "Shadow Rift (The Right Side of the Tracks)", null],
  ["Shadow Rift", "Shadow Rift", 567],
  ["Shape of Mole", "Mt. Molehill", 177],
  ["Skid Row", "The Inner Wolf Gym", 369],
  ["Skid Row", "Unleash Your Inner Wolf", null],
  ["Slums (Moderate Crime)", "Gotpork City Sewers", 467],
  ["Slums (Moderate Crime)", "Porkham Asylum", 468],
  ["Slums (Moderate Crime)", "The Mean Streets", 462],
  ["Slums (Moderate Crime)", "The Old Gotpork Library", 469],
  ["Sorceress", "A Crowd of (Element) Adventurers", null],
  ["Sorceress", "A Crowd of (Stat) Adventurers", null],
  ["Sorceress", "Coldest Adventurer Contest", null],
  ["Sorceress", "Fastest Adventurer Contest", null],
  ["Sorceress", "Hottest Adventurer Contest", null],
  ["Sorceress", "Sleaziest Adventurer Contest", null],
  ["Sorceress", "Smartest Adventurer Contest", null],
  ["Sorceress", "Smoothest Adventurer Contest", null],
  ["Sorceress", "Spookiest Adventurer Contest", null],
  ["Sorceress", "Stinkiest Adventurer Contest", null],
  ["Sorceress", "Strongest Adventurer Contest", null],
  ["Sorceress", "The Hedge Maze", null],
  ["Sorceress", "The Naughty Sorceress' Chamber", null],
  ["Sorceress", "Tower Level 1", null],
  ["Sorceress", "Tower Level 2", null],
  ["Sorceress", "Tower Level 3", null],
  ["Sorceress", "Tower Level 4", null],
  ["Sorceress", "Tower Level 5", null],
  ["Spaaace", "Domed City of Grimacia", 266],
  ["Spaaace", "Domed City of Ronaldus", 265],
  ["Spaaace", "Hamburglaris Shield Generator", 267],
  ["Speakeasy", "An Unusually Quiet Barroom Brawl", 558],
  ["Spelunky Area", "Hell", 428],
  ["Spelunky Area", "LOLmec's Lair", 435],
  ["Spelunky Area", "The Ancient Burial Ground", 431],
  ["Spelunky Area", "The Beehive", 432],
  ["Spelunky Area", "The City of Goooold", 434],
  ["Spelunky Area", "The Crashed U. F. O.", 433],
  ["Spelunky Area", "The Ice Caves", 426],
  ["Spelunky Area", "The Jungle", 425],
  ["Spelunky Area", "The Mines", 424],
  ["Spelunky Area", "The Snake Pit", 429],
  ["Spelunky Area", "The Spider Hole", 430],
  ["Spelunky Area", "The Temple Ruins", 427],
  ["Spelunky Area", "Yomama's Throne", 436],
  ["Spring Break Beach", "Sloppy Seconds Diner", 403],
  ["Spring Break Beach", "The Fun-Guy Mansion", 402],
  ["Spring Break Beach", "The Sunken Party Yacht", 404],
  ["Suburbs", "The Clumsiness Grove", 277],
  ["Suburbs", "The Glacier of Jerks", 279],
  ["Suburbs", "The Maelstrom of Lovers", 278],
  ["Tammy's Offshore Platform", "Gingerbread Reef", 536],
  ["Tammy's Offshore Platform", "The Impenetrable Kelp-Holly Forest", 538],
  ["Tammy's Offshore Platform", "The Wreck of the H. M. S. Kringle", 537],
  ["That 70s Volcano", "LavaCo&trade; Lamp Factory", 450],
  ["That 70s Volcano", "The Bubblin' Caldera", 451],
  ["That 70s Volcano", "The SMOOCH Army HQ", 448],
  ["That 70s Volcano", "The Velvet / Gold Mine (Mining)", null],
  ["That 70s Volcano", "The Velvet / Gold Mine", 449],
  ["The 8-Bit Realm", "Hero's Field", 564],
  ["The 8-Bit Realm", "Megalo-City", 566],
  ["The 8-Bit Realm", "The Fungus Plains", 563],
  ["The 8-Bit Realm", "Vanya's Castle", 565],
  ["The Candy Diorama", "Fudge Mountain", 275],
  ["The Candy Diorama", "Lollipop Forest", 274],
  [
    "The Candy Witch and the Relentless Child Thieves",
    "Eager Rice Burrows",
    371
  ],
  ["The Candy Witch and the Relentless Child Thieves", "Gumdrop Forest", 372],
  ["The Candy Witch and the Relentless Child Thieves", "Sweet-Ade Lake", 370],
  ["The Captain of the Gourd's Psychoses", "The Gourd!", 316],
  ["The Crackpot Mystic's Psychoses", "Anger Man's Level", 301],
  ["The Crackpot Mystic's Psychoses", "Doubt Man's Level", 303],
  ["The Crackpot Mystic's Psychoses", "Fear Man's Level", 302],
  ["The Crackpot Mystic's Psychoses", "Regret Man's Level", 304],
  ["The Drip", "The Dripping Hall", 544],
  ["The Drip", "The Dripping Trees", 542],
  ["The Glaciest", "The Ice Hole", 457],
  ["The Glaciest", "The Ice Hotel", 455],
  ["The Glaciest", "VYKEA", 456],
  ["The Grey Goo Impact Site", "The Goo Fields", 545],
  ["The Grey Goo Impact Site", "The Goo-Bedecked Beanstalk", 549],
  ["The Grey Goo Impact Site", "The Goo-Choked Fun House", 546],
  ["The Grey Goo Impact Site", "The Goo-Coated Knob", 547],
  ["The Grey Goo Impact Site", "The Goo-Girded Garves", 551],
  ["The Grey Goo Impact Site", "The Goo-Shrouded Palindome", 550],
  ["The Grey Goo Impact Site", "The Goo-Spewing Bat Hole", 548],
  ["The Grey Goo Impact Site", "The Goo-Splattered Tower Ruins", 552],
  ["The Meatsmith's Brainspace", "The Nightmare Meatrealm", 305],
  ["The Mer-Kin Deepcity", "Mer-kin Colosseum", 210],
  ["The Mer-Kin Deepcity", "Mer-kin Elementary School", 207],
  ["The Mer-Kin Deepcity", "Mer-kin Gymnasium", 209],
  ["The Mer-Kin Deepcity", "Mer-kin Library", 208],
  ["The Mer-Kin Deepcity", "Mer-kin Temple", null],
  ["The Old Man's Past", "The Old Man's Bathtime Adventures", 318],
  ["The Pretentious Artist's Obsession", "A Grocery Bag", 307],
  ["The Pretentious Artist's Obsession", "A Kitchen Drawer", 306],
  ["The Prince's Ball", "The Prince's Balcony", 377],
  ["The Prince's Ball", "The Prince's Canapes Table", 379],
  ["The Prince's Ball", "The Prince's Dance Floor", 375],
  ["The Prince's Ball", "The Prince's Kitchen", 376],
  ["The Prince's Ball", "The Prince's Lounge", 378],
  ["The Prince's Ball", "The Prince's Restroom", 374],
  ["The Red Zeppelin's Mooring", "A Mob of Zeppelin Protesters", 384],
  ["The Red Zeppelin's Mooring", "The Red Zeppelin", 385],
  ["The Sea Floor", "An Octopus's Garden", 190],
  ["The Sea Floor", "Anemone Mine (Mining)", null],
  ["The Sea Floor", "Anemone Mine", 196],
  ["The Sea Floor", "Madness Reef", 194],
  ["The Sea Floor", "The Caliginous Abyss", 337],
  ["The Sea Floor", "The Coral Corral", 199],
  ["The Sea Floor", "The Dive Bar", 197],
  ["The Sea Floor", "The Marinara Trench", 195],
  ["The Sea Floor", "The Mer-Kin Outpost", 198],
  ["The Sea Floor", "The Skate Park", 188],
  ["The Sea Floor", "The Wreck of the Edgar Fitzsimmons", 191],
  ["The Sea", "The Brinier Deepers", 187],
  ["The Sea", "The Briniest Deepests", 189],
  ["The Sea", "The Briny Deeps", 186],
  ["The Snojo", "The X-32-F Combat Training Snowman", 460],
  ["The Spacegate", "Through the Spacegate", 494],
  [
    "The Suspicious-Looking Guy's Shady Past",
    "1st Floor, Shiawase-Mitsuhama Building",
    311
  ],
  [
    "The Suspicious-Looking Guy's Shady Past",
    "2nd Floor, Shiawase-Mitsuhama Building",
    312
  ],
  [
    "The Suspicious-Looking Guy's Shady Past",
    "3rd Floor, Shiawase-Mitsuhama Building",
    313
  ],
  ["The Suspicious-Looking Guy's Shady Past", "Chinatown Shops", 309],
  ["The Suspicious-Looking Guy's Shady Past", "Chinatown Tenement", 314],
  ["The Suspicious-Looking Guy's Shady Past", "Triad Factory", 310],
  ["Town", "Madness Bakery", 440],
  ["Town", "Super Villain's Lair", 495],
  ["Town", "The Copperhead Club", 383],
  ["Town", "The Overgrown Lot", 441],
  ["Town", "The Skeleton Store", 439],
  ["Town", "The Sleazy Back Alley", 112],
  ["Tunnel of L.O.V.E.", "The Tunnel of L.O.V.E.", null],
  ["Twitch", "12 West Main", 475],
  ["Twitch", "An Illicit Bohemian Party", 411],
  ["Twitch", "Boltsmann Bearings", 582],
  ["Twitch", "Globe Theatre Backstage", 454],
  ["Twitch", "Globe Theatre Main Stage", 453],
  ["Twitch", "KoL Con Clan Party House", 476],
  ["Twitch", "Moonshiners' Woods", 412],
  ["Twitch", "Spring Bros. Solenoids", 581],
  ["Twitch", "The Cave Before Time", 410],
  ["Twitch", "The Home of The Future", 580],
  ["Twitch", "The Post-Mall", 418],
  ["Twitch", "The Primordial Stew", 584],
  ["Twitch", "The Roman Forum", 414],
  ["Twitch", "The Rowdy Saloon", 422],
  ["Twitch", "The Spooky Old Abandoned Mine", 423],
  ["Vanya's Castle", "Vanya's Castle Chapel", 230],
  ["Vanya's Castle", "Vanya's Castle Foyer", 229],
  ["Video Game Dungeon", "Video Game Level 1", 319],
  ["Video Game Dungeon", "Video Game Level 2", 320],
  ["Video Game Dungeon", "Video Game Level 3", 321],
  ["Volcano", "Convention Hall Lobby", 218],
  ["Volcano", "Outside the Club", 219],
  ["Volcano", "The Broodling Grounds", 214],
  ["Volcano", "The Island Barracks", 220],
  ["Volcano", "The Nemesis' Lair", 221],
  ["Volcano", "The Outer Compound", 215],
  ["Volcano", "The Temple Portico", 217],
  ["WhiteWed", "Market Square, 28 Days Later", 88],
  ["WhiteWed", "The Icy Peak in The Recent Past", 59],
  ["WhiteWed", "The Mall of Loathing, 28 Days Later", 89],
  ["WhiteWed", "Wrong Side of the Tracks, 28 Days Later", 90],
  ["Woods", "A Barroom Brawl", 233],
  ["Woods", "The Black Forest", 405],
  ["Woods", "The Hidden Temple", 280],
  ["Woods", "The Old Landfill", 356],
  ["Woods", "The Road to the White Citadel", 413],
  ["Woods", "The Spooky Forest", 15],
  ["Woods", "The Typical Tavern Cellar", null],
  ["Woods", "Whitey's Grove", 100],
  ["Wormwood", "The Mouldering Mansion", 152],
  ["Wormwood", "The Rogue Windmill", 153],
  ["Wormwood", "The Stately Pleasure Dome", 151],
  ["Your Campground From a Bug's Perspective", "Fight in the Dirt", 568],
  ["Your Campground From a Bug's Perspective", "Fight in the Tall Grass", 569],
  [
    "Your Campground From a Bug's Perspective",
    "Fight in the Very Tall Grass",
    570
  ]
];
const BLACK_MARKET_URL = "/shop.php?whichshop=blackmarket";
function mainActionLink(action) {
  return `/main.php?pwd=${getHashIfAvailable()}&action=${action}`;
}
function urlFilter(filter) {
  if (typeof filter !== "string") {
    filter = filter.identifierString;
    filter = filter.replace(/^\[[0-9]+\]/, "");
  }
  filter = decodeEntity_1(filter);
  return encodeURIComponent(filter);
}
function filterLink(file, filter) {
  return `/${file}?ftext=${urlFilter(filter)}`;
}
function inventoryLink(filter) {
  return filterLink("inventory.php", filter);
}
function inventoryActionLink(action) {
  return `/inventory.php?pwd=${getHashIfAvailable()}&action=${action}`;
}
function inventoryUseLink(item2) {
  return `/inv_use.php?pwd=${getHashIfAvailable()}&whichitem=${item2.id}`;
}
function storageLink(filter) {
  return filterLink("storage.php", filter);
}
function mallLink(filter) {
  return `/mall.php?pudnuggler=${urlFilter(filter)}`;
}
function skillLink(filter) {
  if (typeof filter !== "string") {
    filter = filter.identifierString;
  }
  filter = decodeEntity_1(filter);
  return `/skillz.php#:~:text=${encodeURIComponent(filter)}`;
}
const PARENTS = {
  Beach: "/place.php?whichplace=desertbeach",
  Pyramid: "/pyramid.php",
  Woods: "/woods.php",
  Friars: "/friars.php",
  HiddenCity: "/place.php?whichplace=hiddencity",
  Town: "/town.php",
  Manor1: "/place.php?whichplace=manor1",
  Manor2: "/place.php?whichplace=manor2",
  Manor3: "/place.php?whichplace=manor3",
  "Little Canadia": "/place.php?whichplace=canadia",
  Plains: "/place.php?whichplace=plains",
  BatHole: "/place.php?whichplace=bathole",
  "Degrassi Knoll": "/place.php?whichplace=knoll_friendly",
  Beanstalk: "/place.php?whichplace=beanstalk",
  Knob: "/cobbsknob.php",
  Mountain: "/mountains.php",
  "The Red Zeppelin's Mooring": "/place.php?whichplace=zeppelin",
  McLarge: "/place.php?whichplace=mclargehuge",
  Highlands: "/place.php?whichplace=highlands",
  Island: "/island.php",
  IsleWar: "/bigisland.php"
};
function parentPlaceLink(location) {
  if (!canAdventure(location)) return void 0;
  return parentPlaceNameLink(location.identifierString, location.zone);
}
function parentPlaceNameLink(locationName, zone) {
  const parentLink = PARENTS[zone];
  if (locationName === "The Smut Orc Logging Camp") {
    return "/place.php?whichplace=orc_chasm";
  } else if (locationName.startsWith("The Castle in the Clouds in the Sky")) {
    return "/place.php?whichplace=giantcastle";
  } else if (locationName.endsWith("Unquiet Garves")) {
    return "/place.php?whichplace=cemetery";
  } else if ([
    "The Copperhead Club",
    "The Neverending Party",
    "The Tunnel of L.O.V.E."
  ].includes(locationName)) {
    return "/place.php?whichplace=town_wrong";
  } else if (["Noob Cave", "The Dire Warren"].includes(locationName)) {
    return "/tutorial.php";
  } else if (locationName === "The Outskirts of Cobb's Knob" && questStep("questL05Goblin") < 1) {
    return "/place.php?whichplace=plains";
  } else if (parentLink) {
    return parentLink;
  }
}
function pluralJustDesc(count, description, descriptionPlural) {
  if (typeof description === "object" && "name" in description && "plural" in description) {
    descriptionPlural = description.plural;
    description = description.name;
  }
  if (!descriptionPlural) descriptionPlural = `${description}s`;
  return count === 1 ? description : descriptionPlural;
}
function plural(count, description, descriptionPlural) {
  return `${count} ${pluralJustDesc(count, description, descriptionPlural)}`;
}
function pluralItem(item2, count) {
  return plural(
    count ?? availableAmount(item2),
    item2.identifierString,
    item2.plural
  );
}
function separateInternal(values, separator, keys) {
  values = values.map((x2) => isIdentified(x2) ? x2.identifierString : x2);
  values = truthy(values);
  if (values.length === 0) return "";
  else if (values.length >= 1) {
    if (values.every((value) => typeof value === "string")) {
      return values.join(separator);
    } else {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        values.slice(0, -1).map((value, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
          value,
          separator
        ] }, (keys == null ? void 0 : keys[index]) ?? index)),
        values[values.length - 1]
      ] });
    }
  }
}
function separate(values, separator, keys) {
  return separateInternal(values, separator, keys);
}
function commaSeparate(values, keys) {
  return separateInternal(values, ", ", keys);
}
function commaListInternal(values, connector, keys) {
  values = values.map((x2) => isIdentified(x2) ? x2.identifierString : x2);
  values = truthy(values);
  keys = keys == null ? void 0 : keys.filter((key, index) => values[index]);
  if (values.length === 0) return "none";
  else if (values.length === 1) return values[0];
  else if (values.length === 2) {
    if (values.every((value) => typeof value === "string")) {
      return `${values[0]} ${connector} ${values[1]}`;
    } else {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        values[0],
        " ",
        connector,
        " ",
        values[1]
      ] });
    }
  } else {
    if (values.every((value) => typeof value === "string")) {
      return `${values.slice(0, -1).join(", ")}, ${connector} ${values[values.length - 1]}`;
    } else {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        values.slice(0, -1).map((value, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          reactExports.Fragment,
          {
            children: [
              value,
              ", "
            ]
          },
          keys && keys[index] !== void 0 ? keys[index] : index
        )),
        `${connector} `,
        values[values.length - 1]
      ] });
    }
  }
}
function commaList(values, connector, keys) {
  return commaListInternal(values, connector, keys);
}
function commaAnd(values, keys) {
  return commaListInternal(values, "and", keys);
}
function commaOr(values, keys) {
  return commaListInternal(values, "or", keys);
}
function truthy(values) {
  return values.filter((x2) => x2);
}
function capitalize(text) {
  return text.charAt(0).toUpperCase() + text.slice(1);
}
function capitalizeWords(text) {
  return text.split(" ").map((word) => capitalize(word)).join(" ");
}
function ordinal(n2) {
  if (10 <= n2 % 100 && n2 % 100 <= 20) {
    return `${n2}th`;
  } else if (n2 % 10 === 1) {
    return `${n2}st`;
  } else if (n2 % 10 === 2) {
    return `${n2}nd`;
  } else if (n2 % 10 === 3) {
    return `${n2}rd`;
  } else {
    return `${n2}th`;
  }
}
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React.createContext && /* @__PURE__ */ React.createContext(DefaultContext);
var _excluded = ["attr", "size", "title"];
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function Tree2Element(tree) {
  return tree && tree.map((node2, i) => /* @__PURE__ */ React.createElement(node2.tag, _objectSpread({
    key: i
  }, node2.attr), Tree2Element(node2.child)));
}
function GenIcon(data) {
  return (props) => /* @__PURE__ */ React.createElement(IconBase, _extends({
    attr: _objectSpread({}, data.attr)
  }, props), Tree2Element(data.child));
}
function IconBase(props) {
  var elem = (conf) => {
    var {
      attr,
      size: size2,
      title
    } = props, svgProps = _objectWithoutProperties(props, _excluded);
    var computedSize = size2 || conf.size || "1em";
    var className;
    if (conf.className) className = conf.className;
    if (props.className) className = (className ? className + " " : "") + props.className;
    return /* @__PURE__ */ React.createElement("svg", _extends({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: _objectSpread(_objectSpread({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && /* @__PURE__ */ React.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? /* @__PURE__ */ React.createElement(IconContext.Consumer, null, (conf) => elem(conf)) : elem(DefaultContext);
}
function LuX(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M18 6 6 18" }, "child": [] }, { "tag": "path", "attr": { "d": "m6 6 12 12" }, "child": [] }] })(props);
}
const CloseButton = reactExports.forwardRef((props, ref2) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { variant: "ghost", "aria-label": "Close", ref: ref2, ...props, children: props.children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(LuX, {}) });
});
const PopoverContent = reactExports.forwardRef((props, ref2) => {
  const { portalled = true, portalRef, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { disabled: !portalled, container: portalRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverPositioner, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContent$1, { ref: ref2, ...rest }) }) });
});
reactExports.forwardRef((props, ref2) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverArrow, { ...props, ref: ref2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverArrowTip, {}) });
});
reactExports.forwardRef((props, ref2) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverCloseTrigger,
    {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      ...props,
      asChild: true,
      ref: ref2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButton, { size: "sm" })
    }
  );
});
const PopoverRoot = PopoverRoot$1;
const PopoverBody = PopoverBody$1;
const PopoverTrigger = PopoverTrigger$1;
function mod(n2, k2) {
  const naive = n2 % k2;
  return naive < 0 ? naive + k2 : naive;
}
function getMatchingValues(value, allValues, maxOptions) {
  const valueLower = value.toLowerCase();
  return value.length >= 3 ? allValues.filter((name) => name.toLowerCase().includes(valueLower)).slice(0, maxOptions) : [];
}
const AutocompleteInput = reactExports.forwardRef(
  ({ value, maxOptions, allValues, hide: hide2, onChange, onSubmit, ...props }, ref2) => {
    const [autoIndex, setAutoIndex] = reactExports.useState(null);
    const matchingValues = getMatchingValues(value, allValues, maxOptions);
    const handleAutocompleteKeyDown = reactExports.useCallback(
      (event) => {
        if (event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Tab") {
          event.preventDefault();
          event.stopPropagation();
          const increment = event.key === "ArrowDown" ? 1 : -1;
          setAutoIndex((index) => {
            if (index === null) {
              return increment === 1 ? 0 : -1;
            } else {
              return index + increment;
            }
          });
        } else if (event.key === "Enter") {
          event.preventDefault();
          event.stopPropagation();
          onSubmit(event.currentTarget.getAttribute("data-current"));
        } else if (event.key === "Escape") {
          event.currentTarget.blur();
        }
      },
      [onSubmit]
    );
    const handleAutocompleteClick = reactExports.useCallback(
      (event) => {
        onSubmit(event.currentTarget.getAttribute("data-current"));
      },
      [onSubmit]
    );
    const handleChange = reactExports.useCallback(
      (event) => {
        onChange == null ? void 0 : onChange(event);
        const newValue = event.currentTarget.value;
        if (newValue && getMatchingValues(newValue, allValues, maxOptions).length === 1) {
          setAutoIndex(0);
        } else {
          setAutoIndex(null);
        }
      },
      [allValues, maxOptions, onChange]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      PopoverRoot,
      {
        open: !hide2 && value.length >= 3 && matchingValues.length > 0,
        autoFocus: false,
        positioning: { placement: "top" },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              size: "xs",
              height: 7,
              value,
              onChange: handleChange,
              onKeyDown: handleAutocompleteKeyDown,
              "data-current": autoIndex === null ? void 0 : matchingValues[mod(autoIndex, matchingValues.length)],
              ref: ref2,
              ...props
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContent, { maxW: "90vw", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverBody, { p: 2, maxW: "90vw", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { listStyleType: "none", children: matchingValues.map((name, index) => {
            const highlight = autoIndex !== null && mod(autoIndex, matchingValues.length) === index;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              ListItem,
              {
                "data-current": name,
                p: 0.5,
                my: 0.5,
                cursor: "pointer",
                onMouseEnter: () => setAutoIndex(index),
                onClick: handleAutocompleteClick,
                background: highlight ? "Highlight" : void 0,
                borderRadius: "3px",
                children: name
              },
              name
            );
          }) }) }) })
        ]
      }
    );
  }
);
function dropRateModifier(item2) {
  let itemModifier = itemDropModifier();
  if (haveEquipped($item`Everfull Dart Holster`) && get$1("everfullDartPerks").includes("Butt awareness")) {
    itemModifier += 30;
  }
  const isWeapon = weaponHands(item2) > 0;
  const type = isWeapon ? "weapon" : itemType(item2);
  if (item2.cookable || type === "food") {
    itemModifier += get("Food Drop");
  }
  if (item2.mixable || type === "booze") {
    itemModifier += get("Booze Drop");
  }
  if (item2.candy) {
    itemModifier += get("Candy Drop");
  }
  if (type === "spleen item") {
    itemModifier += get("Spleen Drop");
  } else if (type === "potion") {
    itemModifier += get("Potion Drop");
  }
  if (["hat", "weapon", "offhand", "shirt", "pants", "accessory"].includes(type)) {
    itemModifier += numericModifier(`${capitalize(type)} Drop`) + get("Gear Drop");
  }
  return itemModifier;
}
function monsterFrequencyAndQueue(location) {
  const monsters = getMonsters(location);
  const appearingMonsters = monsters.filter(
    (monster) => monster !== $monster`none` && appearanceRates(location)[monster.name] > 0
  );
  const queue = (location.combatQueue ?? "").split("; ").filter((s) => s).map((name) => Monster.get(name));
  const monsterCopies = appearingMonsters.map((monster) => {
    const copies = isBanished(monster) ? 0 : 1 + trackCopyCount(monster);
    const reject = !trackIgnoreQueue(monster);
    const copiesWithQueue = (reject && queue.includes(monster) ? 0.25 : 1) * copies;
    return { monster, copiesWithQueue };
  });
  const totalCopiesWithQueue = sum(monsterCopies, "copiesWithQueue");
  const monsterFrequency = monsterCopies.map(
    ({ monster, copiesWithQueue }) => ({
      monster,
      frequency: copiesWithQueue / totalCopiesWithQueue
    })
  );
  return { monsterFrequency, queue };
}
const TooltipContext = reactExports.createContext(reactExports.createRef());
const Tooltip = React.forwardRef(
  (props, ref2) => {
    const {
      showArrow,
      children,
      disabled,
      portalled,
      content: content2,
      contentProps,
      portalRef,
      ...rest
    } = props;
    const containerRef = reactExports.useContext(TooltipContext);
    if (disabled) return children;
    rest.openDelay ?? (rest.openDelay = 200);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipRoot, { ...rest, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Portal,
        {
          disabled: !portalled,
          container: portalRef ?? (containerRef.current ? containerRef : void 0),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPositioner, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipContent, { ref: ref2, ...contentProps, children: [
            showArrow && /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipArrow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipArrowTip, {}) }),
            content2
          ] }) })
        }
      )
    ] });
  }
);
const importantItems = [
  "sonar-in-a-biscuit",
  "concentrated cooking",
  "Knob Goblin harem pants",
  "Knob Goblin harem veil",
  "evil eye",
  "A-Boo clue",
  "rusty hedge trimmers",
  "bubblin' crude",
  "Mohawk wig",
  "amulet of extreme plot significance",
  "stunt nuts",
  "bird rib",
  "lion oil",
  "killing jar",
  "goat cheese",
  "forest tears",
  "bowling ball",
  "book of matches",
  "cigarette lighter",
  "glark cable",
  "blasting soda",
  "bottle of Chateau de Vinegar",
  "tomb ratchet",
  "filthworm hatchling scent gland",
  "filthworm drone scent gland",
  "filthworm royal guard scent gland",
  "star",
  "line",
  "shadow brick"
];
const DetailedMonsters = ({ location }) => {
  const { monsterFrequency, queue } = monsterFrequencyAndQueue(location);
  const banishedMonsters = [...getBanishedMonsters().entries()];
  return monsterFrequency.length === 0 ? "No monsters." : /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", wrap: "wrap", children: monsterFrequency.map(({ monster, frequency }) => {
    var _a2;
    const text = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      monster.name,
      " (",
      queue.includes(monster) ? "Q " : "",
      (100 * frequency).toFixed(0),
      "%)"
    ] });
    const banisher = (_a2 = banishedMonsters.find(([, m2]) => m2 === monster)) == null ? void 0 : _a2[0];
    const title = /* @__PURE__ */ jsxRuntimeExports.jsxs(
      CardTitle,
      {
        fontSize: ["xs", "sm"],
        lineHeight: "1.2",
        color: banisher ? "fg.subtle" : void 0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Image,
            {
              display: "inline",
              verticalAlign: "baseline",
              w: "1em",
              h: "1em",
              src: `/images/adventureimages/${monster.image}`
            }
          ),
          " ",
          text
        ]
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CardRoot,
      {
        w: "100%",
        sm: { w: "calc(50% - var(--chakra-spacing-2) / 2)" },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardBody, { p: 2, gap: 1, children: [
          banisher ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { showArrow: true, content: `Banished: ${banisher.name}`, children: title }) : queue.includes(monster) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tooltip,
            {
              showArrow: true,
              content: `In combat queue, frequency reduced by 75%.`,
              children: title
            }
          ) : title,
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { fontSize: ["2xs", "xs"], children: itemDropsArray(monster).filter(({ type }) => type !== "p" && type !== "a").map(({ drop, rate }, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Text,
            {
              ...importantItems.includes(drop.name) ? { bg: "cyan.subtle", fontWeight: "bold" } : void 0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Image,
                  {
                    display: "inline",
                    verticalAlign: "baseline",
                    h: "0.8em",
                    src: `/images/itemimages/${drop.image}`
                  }
                ),
                " ",
                decode_1(drop.name),
                " (",
                rate === 0 ? "?" : Math.min(
                  100,
                  rate * (1 + dropRateModifier(drop) / 100)
                ).toFixed(0),
                "%)"
              ]
            },
            index
          )) })
        ] })
      },
      monster.id
    );
  }) });
};
const H2 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h2", size: ["md", "lg"], ...props });
const MainLink = ({ href, children, ...props }) => href ? /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { target: "mainpane", href, ...props, children }) : children;
const MAX_AUTOCOMPLETE = 10;
const LOCATION_NAMES = LOCATION_DATA$1.filter(
  ([parent]) => parent !== "Obsolete"
).map(([parent, name]) => `${parent}: ${name}`);
const LocationBar = (props) => {
  const { triggerHardRefresh } = reactExports.useContext(RefreshContext);
  const [showDetails, setShowDetails] = reactExports.useState(false);
  const [autoValue, setAutoValue] = reactExports.useState("");
  const [autoHasFocus, setAutoHasFocus] = reactExports.useState(false);
  const [autoFocusCount, setAutoFocusCount] = reactExports.useState(0);
  const locationFieldRef = reactExports.useRef(null);
  const handleKeyDownGlobal = reactExports.useCallback((event) => {
    var _a2, _b2, _c2;
    if (((_b2 = (_a2 = event.target) == null ? void 0 : _a2.constructor) == null ? void 0 : _b2.name) !== "HTMLInputElement" && event.key === "\\" && !event.metaKey && !event.altKey && !event.shiftKey && !event.ctrlKey) {
      setAutoHasFocus(true);
      setAutoFocusCount((count) => count + 1);
      (_c2 = locationFieldRef.current) == null ? void 0 : _c2.focus();
      event.preventDefault();
    }
  }, []);
  reactExports.useEffect(() => {
    var _a2;
    (_a2 = locationFieldRef.current) == null ? void 0 : _a2.focus();
  }, [autoFocusCount]);
  reactExports.useEffect(() => {
    const frameList = Array.from(new Array(getFrames().length).keys()).map(
      (i) => getFrames()[i]
    );
    for (const frame of frameList) {
      frame.onkeydown = handleKeyDownGlobal;
      const frameElement = frame.frameElement;
      frameElement.onload = (event) => {
        const frameElement2 = event.target;
        if (frameElement2.contentWindow) {
          frameElement2.contentWindow.onkeydown = handleKeyDownGlobal;
        }
      };
    }
  }, [handleKeyDownGlobal, locationFieldRef]);
  const handleSubmit = reactExports.useCallback(
    async (current) => {
      if (current !== null) {
        const [zone, location2] = current.split(": ", 2);
        if (location2 !== void 0) {
          remoteCliExecute(`set nextAdventure = ${location2}`);
          triggerHardRefresh();
          setAutoValue("");
          const mainpane = window.parent.parent.mainpane;
          if (mainpane) {
            const link = parentPlaceNameLink(location2, zone);
            if (link) {
              mainpane.location.href = link;
            }
          }
        }
      }
    },
    [triggerHardRefresh]
  );
  const location = myLocation();
  const nowhere = location === $location`none`;
  const combatQueue = (location.combatQueue ?? "").split(";").filter((s) => s);
  const noncombatQueue = (location.noncombatQueue ?? "").split(";").filter((s) => s);
  const combatModifier = combatRateModifier();
  const isOpen = showDetails || autoHasFocus;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Flex,
    {
      direction: "column",
      w: "100%",
      maxH: "100vh",
      onMouseOver: () => setShowDetails(true),
      onMouseOut: () => setShowDetails(false),
      backgroundColor: "white",
      fontSize: ["2xs", "xs"],
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Stack,
          {
            w: "100%",
            minH: 0,
            flex: "0 1 auto",
            py: 2,
            px: 3,
            borderTop: "1px solid",
            borderColor: "gray.muted",
            display: isOpen ? "flex" : "none",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(H2, { children: location.identifierString }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { flex: "0 1 auto", overflow: "scroll", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DetailedMonsters, { location }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
                "Combat Queue:",
                " ",
                combatQueue.length === 0 ? "empty" : combatQueue.join("  ")
              ] }),
              (appearanceRates(location).none ?? 0) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
                "Noncombat Queue:",
                " ",
                noncombatQueue.length === 0 ? "empty" : noncombatQueue.join("  ")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                AutocompleteInput,
                {
                  placeholder: "Go To Location (press \\)",
                  allValues: LOCATION_NAMES,
                  maxOptions: MAX_AUTOCOMPLETE,
                  value: autoValue,
                  onChange: (event) => setAutoValue(event.target.value),
                  onSubmit: handleSubmit,
                  onFocus: () => setAutoHasFocus(true),
                  onBlur: () => setAutoHasFocus(false),
                  hide: !showDetails && !autoHasFocus,
                  ref: locationFieldRef
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Stack,
          {
            w: "100%",
            py: 2,
            px: 3,
            direction: "row",
            justify: "space-between",
            borderTop: "1px solid",
            borderColor: "gray.muted",
            ...props,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Text,
                {
                  maxW: "40%",
                  whiteSpace: "nowrap",
                  overflow: "hidden",
                  textOverflow: "ellipsis",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: parentPlaceLink(location), children: nowhere ? "No Location" : location.identifierString })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: [0, 100].includes(location.combatPercent) ? `${location.combatPercent}% C` : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                location.combatPercent,
                "% C (",
                combatModifier > 0 && "+",
                combatModifier,
                "%)"
              ] }) }),
              !nowhere && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
                plural(location.turnsSpent, "turn"),
                " spent"
              ] })
            ]
          }
        )
      ]
    }
  );
};
const RefreshButton = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  IconButton,
  {
    asChild: true,
    "aria-label": "Refresh",
    size: "2xs",
    _hover: { bgColor: "bg.emphasized" },
    bgColor: "bg",
    p: 1,
    variant: "outline",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Repeat, {})
  }
);
const toaster = createToaster({
  placement: "bottom-end",
  pauseOnPageIdle: true
});
const Toaster = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster$1, { toaster, insetInline: { mdDown: "4" }, children: (toast) => {
    var _a2;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastRoot, { width: { md: "sm" }, children: [
      toast.type === "loading" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm", color: "blue.solid" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ToastIndicator, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: "1", flex: "1", maxWidth: "100%", children: [
        toast.title && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, { children: toast.title }),
        toast.description && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDescription, { children: toast.description })
      ] }),
      toast.action && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastActionTrigger, { children: toast.action.label }),
      ((_a2 = toast.meta) == null ? void 0 : _a2.closable) && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastCloseTrigger, {})
    ] });
  } }) });
};
function jsName(obj) {
  return `${obj.objectType}.get(${JSON.stringify(obj.identifierString)})`;
}
function overrideName(name, args) {
  const namedArgs = args.map(
    (arg) => isIdentified(arg) ? jsName(arg) : JSON.stringify(arg)
  );
  return `override:${name}(${namedArgs.join(", ")})`;
}
const Section = ({ name, children, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: [1, 2], align: "stretch", px: 2, pb: 1, ...props, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(H2, { children: name }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    Stack,
    {
      gap: [1, 2],
      _empty: {
        _after: {
          content: '"Nothing to display."',
          fontWeight: "bold",
          fontStyle: "italic"
        }
      },
      children
    }
  )
] });
const storageListeners = {};
function addStorageListener(key, listener) {
  const list = storageListeners[key] ?? [];
  list.push(listener);
  storageListeners[key] = list;
}
function fireStorageListeners(key, newValue) {
  for (const listener of storageListeners[key] ?? []) {
    listener(newValue);
  }
}
function useLocalStorage(key, initialValue) {
  const readValue = reactExports.useCallback(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item2 = window.localStorage.getItem(key);
      return item2 ? typeof initialValue === "boolean" ? item2 === "true" : typeof initialValue === "number" ? parseInt(item2) : item2 : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  }, [initialValue, key]);
  const [storedValue, setStoredValue] = reactExports.useState(readValue);
  const setValue = reactExports.useCallback(
    (valueOrUpdater) => {
      try {
        const valueToStore = valueOrUpdater instanceof Function ? valueOrUpdater(readValue()) : valueOrUpdater;
        const valueString = valueToStore.toString();
        if (typeof window !== "undefined") {
          if (valueToStore === initialValue) {
            window.localStorage.removeItem(key);
          } else {
            window.localStorage.setItem(key, valueString);
          }
          fireStorageListeners(key, valueString);
        }
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error);
      }
    },
    [initialValue, key, readValue]
  );
  reactExports.useEffect(() => {
    addStorageListener(key, () => setStoredValue(readValue()));
  }, [key, readValue]);
  return [storedValue, setValue];
}
function inDevMode() {
  return false;
}
const Button = reactExports.forwardRef(
  (props, ref2) => {
    const { loading, disabled, loadingText, children, ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { disabled: loading || disabled, ref: ref2, ...rest, children: loading && !loadingText ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AbsoluteCenter, { display: "inline-flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "inherit", color: "inherit" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Span, { opacity: 0, children })
    ] }) : loading && loadingText ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "inherit", color: "inherit" }),
      loadingText
    ] }) : children });
  }
);
const HeaderButton = reactExports.forwardRef(
  ({ href, onClick, children, ...props }, ref2) => {
    const button = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        ref: ref2,
        colorPalette: "gray",
        size: "xs",
        px: 1,
        height: 4,
        onClick,
        ...props,
        children
      }
    );
    return href && !onClick ? /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href, _hover: { textDecoration: "none" }, children: button }) : button;
  }
);
HeaderButton.displayName = "HeaderButton";
const AsyncButton = reactExports.forwardRef(
  ({ href, command, onClick, children, ...props }, ref2) => {
    const { triggerHardRefresh } = reactExports.useContext(RefreshContext);
    const [isLoading, setIsLoading] = reactExports.useState(false);
    const onClickWithCommand = reactExports.useMemo(
      () => command && !onClick ? async () => {
        const result = await remoteCliExecute(command);
        if (result === false) {
          toaster.error({
            title: "Command failed.",
            description: `Failed to execute "${command}".`,
            duration: 5e3
          });
        }
      } : onClick,
      [command, onClick]
    );
    const handleClick = reactExports.useCallback(
      async (event) => {
        event.preventDefault();
        setIsLoading(true);
        await (onClickWithCommand ? onClickWithCommand(event) : href && fetch(href).then((response) => response.text()));
        setIsLoading(false);
        triggerHardRefresh();
      },
      [href, onClickWithCommand, triggerHardRefresh]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      HeaderButton,
      {
        loading: isLoading,
        href,
        onClick: handleClick,
        ref: ref2,
        ...props,
        children: command ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { content: command, children: typeof children === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", children }) : children }) : children
      }
    );
  }
);
AsyncButton.displayName = "AsyncButton";
const FamiliarButtons = ({
  linkedContent,
  ...props
}) => {
  const linkID = linkedContent.id;
  const haveOut = myFamiliar() === linkedContent;
  if (!have$b(linkedContent) || haveOut) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AsyncButton,
    {
      href: `/familiar.php?&action=newfam&newfam=${linkID}&pwd=${myHash()}`,
      ...props,
      children: "take"
    }
  );
};
const EquipButton = ({
  item: item2,
  action,
  accessorySlot,
  children,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onClick,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AsyncButton,
    {
      href: `/inv_equip.php?pwd=${getHashIfAvailable()}&which=2&action=${action ?? "equip"}&whichitem=${item2}${accessorySlot ? `&slot=${accessorySlot}` : ""}`,
      ...props,
      children
    }
  );
};
const ItemButtons = ({
  linkedContent,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onClick,
  ...props
}) => {
  var _a2;
  const linkID = linkedContent.id;
  const isEquippable = canEquip(linkedContent);
  const equipSlot = toSlot(linkedContent);
  if (!have$b(linkedContent) || haveEquipped(linkedContent)) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  if ((equipSlot == null ? void 0 : equipSlot.identifierString) === "acc1") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: [1, 2, 3].map((slot) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      EquipButton,
      {
        item: linkID,
        accessorySlot: slot,
        ...props,
        children: `acc${slot}`
      },
      slot
    )) });
  } else if ((equipSlot == null ? void 0 : equipSlot.identifierString) === "weapon" && weaponHands(linkedContent) === 1 && ((_a2 = weaponType(linkedContent)) == null ? void 0 : _a2.identifierString) === "Muscle") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(EquipButton, { item: linkID, ...props, children: "main" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(EquipButton, { item: linkID, action: "dualwield", ...props, children: "off" })
    ] });
  } else if (isEquippable) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(EquipButton, { item: linkID, ...props, children: "equip" });
  } else {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      HeaderButton,
      {
        href: `/inv_use.php?pwd=${myHash()}&which=3&whichitem=${linkID}`,
        ...props,
        children: "use"
      }
    );
  }
};
const SkillButtons = ({
  linkedContent,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onClick,
  ...props
}) => {
  const linkID = linkedContent.id;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    HeaderButton,
    {
      href: `/runskillz.php?action=Skillz&whichskill=${linkID}&targetplayer=0&pwd=${myHash()}&quantity=1`,
      disabled: myMp() < mpCost(linkedContent),
      ...props,
      children: "cast"
    }
  );
};
const ContentButtons = ({
  linkedContent,
  ...props
}) => {
  if (!have$b(linkedContent)) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  switch (linkedContent.objectType) {
    case "Item":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemButtons, { linkedContent, ...props });
    case "Familiar": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FamiliarButtons, { linkedContent, ...props });
    }
    case "Skill":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SkillButtons, { linkedContent, ...props });
  }
};
const H3 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h3", size: ["sm", "md"], ...props });
const LinkBlock = ({ children, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { gap: 0.5, children }) });
const TileImage = reactExports.forwardRef(
  ({ imageUrl, imageAlt, boxSize, ...props }, ref2) => imageUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(Flex, { ref: ref2, direction: "row", justify: "center", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: imageUrl, alt: imageAlt, w: boxSize, fit: "contain" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Flex, { w: boxSize, ref: ref2, ...props })
);
const Tile = ({
  header,
  headerSuffix,
  id: id2,
  imageUrl,
  imageAlt,
  icon,
  href,
  disabled,
  children,
  linkedContent,
  linkHide = false,
  linkEntireTile = false,
  extraLinks,
  tooltip,
  nonCollapsible,
  ...props
}) => {
  const storageId = id2 || (linkedContent == null ? void 0 : linkedContent.identifierString) || (typeof header === "string" ? header : null) || null;
  if (storageId === null && inDevMode()) {
    throw new Error(`Tile (unknown) needs an id parameter.`);
  }
  const [lastStorageId] = reactExports.useState(storageId);
  if (storageId !== lastStorageId && inDevMode()) {
    throw new Error(
      `Tile ${header} needs an id parameter (saw storageId change).`
    );
  }
  const [collapsed, setCollapsed] = useLocalStorage(
    `collapse-${storageId}`,
    false
  );
  const headerMain = header ?? ((linkedContent == null ? void 0 : linkedContent.identifierString) ? capitalizeWords(decode_1(linkedContent.identifierString)) : void 0);
  const heading = headerMain && headerSuffix ? `${headerMain} ${headerSuffix}` : headerMain;
  const imageSize = collapsed || disabled ? "20px" : "30px";
  const collapseNode = /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleRoot, { unmountOnExit: true, open: !collapsed, overflow: "visible", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleContent, { overflow: "visible", children: href && linkEntireTile ? /* @__PURE__ */ jsxRuntimeExports.jsx(LinkBlock, { href, children }) : /* @__PURE__ */ jsxRuntimeExports.jsx(VStack, { align: "start", gap: 0.5, children }) }) });
  const tileContents = /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { align: "start", gap: ["1px", 0.5], children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { gap: 1, align: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(H3, { lineHeight: "tall", children: !collapsed && !disabled && href ? /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href, children: heading }) : heading }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        HStack,
        {
          gap: 1,
          css: {
            ".chakra-tooltip__content &": {
              display: "none"
            }
          },
          children: [
            !collapsed && tooltip,
            !collapsed && linkedContent && !linkHide && /* @__PURE__ */ jsxRuntimeExports.jsx(
              ContentButtons,
              {
                linkedContent,
                smDown: { display: "none" }
              }
            ),
            !collapsed && extraLinks,
            disabled || nonCollapsible || /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                asChild: true,
                "aria-label": "Collapse",
                h: 4,
                w: 4,
                minW: 2,
                fontSize: "20px",
                variant: "ghost",
                color: "inherit",
                onClick: (event) => {
                  event.preventDefault();
                  setCollapsed((collapsed2) => !collapsed2);
                },
                children: collapsed ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, {})
              }
            )
          ]
        }
      )
    ] }),
    !disabled && collapseNode
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    HStack,
    {
      align: "stretch",
      color: collapsed || disabled ? "fg.subtle" : void 0,
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            w: "30px",
            flexShrink: 0,
            smDown: { display: "none" },
            css: {
              ".chakra-portal &": {
                display: "none"
              }
            },
            children: icon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(
              TileImage,
              {
                imageUrl: imageUrl ?? ((linkedContent == null ? void 0 : linkedContent.image) ? `/images/itemimages/${linkedContent == null ? void 0 : linkedContent.image}` : void 0),
                imageAlt: imageAlt ?? (typeof header === "string" ? header : void 0),
                mt: collapsed || disabled ? 0 : 1,
                mb: "auto",
                mx: collapsed || disabled ? "auto" : void 0,
                boxSize: imageSize
              }
            )
          }
        ),
        tileContents
      ]
    }
  );
};
const TileErrorBoundary = ({ name, children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ErrorBoundary,
    {
      fallbackRender: ({ error }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", color: "red.fg", children: [
            "Error in tile ",
            name,
            "."
          ] }),
          id: `${name}-error`,
          nonCollapsible: true,
          bgColor: "red.subtle",
          borderY: "1px solid red",
          py: 1,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Code, { children: error.message }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                href: "https://github.com/loathers/yorick/issues",
                target: "_blank",
                children: "Please report this on GitHub!"
              }
            ) })
          ]
        }
      ),
      children
    }
  );
};
const ENV_COLORS = {
  X: "gray.solid",
  U: "red.solid",
  I: "blue.solid",
  O: "yellow.solid"
};
const ENV_RESULTS = {
  X: "Fleshazole",
  U: "Breathitin",
  I: "Extrovermectin",
  O: "Homebodyl"
};
function getCMCInfo() {
  const cabinet = $item`cold medicine cabinet`;
  const workshed = getWorkshed();
  const consults = get$1("_coldMedicineConsults");
  if (workshed !== cabinet || consults >= 5) {
    return {
      available: false,
      consults,
      turnsToConsult: 0,
      environments: [],
      maxEnvironment: "X",
      result: ENV_RESULTS.X
    };
  }
  const nextConsult = get$1("_nextColdMedicineConsult");
  const turnsToConsult = nextConsult - totalTurnsPlayed();
  const environments = [...get$1("lastCombatEnvironments").toUpperCase()];
  const counts = {};
  for (const c2 of environments) {
    counts[c2] = (counts[c2] ?? 0) + 1;
  }
  const maxEnvironment = maxBy(Object.keys(ENV_RESULTS), (c2) => counts[c2] ?? 0);
  const result = counts[maxEnvironment] >= 11 ? ENV_RESULTS[maxEnvironment] : ENV_RESULTS.X;
  return {
    available: true,
    consults,
    turnsToConsult,
    environments,
    maxEnvironment,
    result
  };
}
const replicas = /* @__PURE__ */ new Set([
  "replica Dark Jill-O-Lantern",
  "replica hand turkey outline",
  "replica crimbo elfling",
  "replica pygmy bugbear shaman",
  "replica miniature gravy-covered maypole",
  "replica wax lips",
  "replica Tome of Snowcone Summoning",
  "replica jewel-eyed wizard hat",
  "replica bottle-rocket crossbow",
  "replica navel ring of navel gazing",
  "replica V for Vivala mask",
  "replica haiku katana",
  "replica little box of fireworks",
  "replica cotton candy cocoon",
  "replica Elvish sunglasses",
  "replica squamous polyp",
  "replica Greatest American Pants",
  "replica organ grinder",
  "replica Juju Mojo Mask",
  "replica Operation Patriot Shield",
  "replica Libram of Resolutions",
  "replica plastic vampire fangs",
  "replica cute angel",
  "replica Camp Scout backpack",
  "replica deactivated nanobots",
  "replica Apathargic Bandersnatch",
  "replica Smith's Tome",
  "replica over-the-shoulder Folder Holder",
  "replica Order of the Green Thumb Order Form",
  "replica Little Geneticist DNA-Splicing Lab",
  "replica still grill",
  "replica Crimbo sapling",
  "replica yellow puck",
  "replica Chateau Mantegna room key",
  "replica Deck of Every Card",
  "replica Source terminal",
  "replica disconnected intergnat",
  "replica Witchess Set",
  "replica genie bottle",
  "replica space planula",
  "replica unpowered Robortender",
  "replica Neverending Party invitation envelope",
  "replica January's Garbage Tote",
  "replica God Lobster Egg",
  "replica Fourth of May Cosplay Saber",
  "replica Kramco Sausage-o-Matic",
  "replica hewn moon-rune spoon",
  "replica baby camelCalf",
  "replica Powerful Glove",
  "replica Cargo Cultist Shorts",
  "replica industrial fire extinguisher",
  "replica miniature crystal ball",
  "replica emotion chip",
  "replica Jurassic Parka",
  "replica grey gosling",
  "replica designer sweatpants",
  "replica plastic pumpkin bucket",
  "replica Ten Dollars",
  "replica Cincho de Mayo",
  "replica sleeping patriotic eagle",
  "replica august scepter"
]);
function haveUnrestricted(thing) {
  return (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    isUnrestricted(thing) && (have$b(thing) || thing instanceof Item && getWorkshed() === thing || thing instanceof Item && !!getCampground()[thing.name] || replicas.has(`replica ${thing.name}`) && have$b(Item.get(`replica ${thing.name}`)))
  );
}
const Flyers = () => {
  const flyeredMl = get$1("flyeredML");
  const flyersActive = (have$b($item`rock band flyers`) || have$b($item`jam band flyers`)) && flyeredMl < 1e4 && get$1("sidequestArenaCompleted") === "none";
  if (!flyersActive) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressRoot, { min: 0, max: 1e4, value: flyeredMl, maxW: "sm", size: "lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { gap: 5, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressLabel, { children: "Flyers:" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressTrack, { flex: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressRange, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ProgressValueText, { children: [
      flyeredMl,
      "/10000"
    ] })
  ] }) });
};
const Pill = reactExports.forwardRef(
  ({ children, ...props }, ref2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Badge,
    {
      borderRadius: "2px",
      color: "white",
      bgColor: "gray.solid",
      lineHeight: ["12px", "16px"],
      px: ["4px", "6px"],
      ref: ref2,
      ...props,
      children
    }
  )
);
const CMCTimeline = () => {
  const cmcInfo = getCMCInfo();
  if (!cmcInfo.available) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: 1, align: "flex-start", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { flexFlow: "row wrap", gap: 0.5, align: "center", children: cmcInfo.environments.map((c2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Badge,
      {
        w: "14px",
        px: 0,
        fontSize: ["2xs", "xs"],
        color: "white",
        bgColor: ENV_COLORS[c2],
        alignItems: "center",
        justifyContent: "center",
        children: c2
      },
      index
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MainLink,
      {
        href: cmcInfo.turnsToConsult <= 0 ? "/campground.php?action=workshed" : void 0,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { flexFlow: "row wrap", gap: 1, align: "center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
            cmcInfo.turnsToConsult > 0 ? plural(cmcInfo.turnsToConsult, "turn") : "NOW",
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Badge,
            {
              fontSize: "xs",
              color: "white",
              bgColor: ENV_COLORS[cmcInfo.maxEnvironment],
              children: cmcInfo.result
            }
          )
        ] })
      }
    )
  ] });
};
const Timeline = (props) => {
  const returnCombats = get$1("cosmicBowlingBallReturnCombats");
  const elements2 = [
    {
      name: "ELG",
      turns: haveEffect($effect`Everything Looks Green`),
      color: "green.solid",
      label: (turns) => `${plural(turns, "turn")} of Everything Looks Green.`
    },
    {
      name: "ELP",
      turns: haveEffect($effect`Everything Looks Purple`),
      color: "purple.solid",
      label: (turns) => `${plural(turns, "turn")} of Everything Looks Purple.`
    },
    {
      name: "ELR",
      turns: haveEffect($effect`Everything Looks Red`),
      color: "red.solid",
      label: (turns) => `${plural(turns, "turn")} of Everything Looks Red.`
    },
    {
      name: "ELY",
      turns: haveEffect($effect`Everything Looks Yellow`),
      color: "yellow.500",
      label: (turns) => `${plural(turns, "turn")} of Everything Looks Yellow.`
    },
    {
      name: "ELRWB",
      turns: haveEffect($effect`Everything Looks Red, White and Blue`),
      color: "purple.solid",
      label: (turns) => `${plural(turns, "turn")} of Everything Looks Red, White and Blue.`
    },
    {
      name: "ELBe",
      turns: haveEffect($effect`Everything looks Beige`),
      color: "yellow.fg",
      label: (turns) => `${plural(turns, "turn")} of Everything Looks Beige`
    }
  ];
  if (myClass() === $class`Zootomist` || myClass() === $class`Jazz Agent`) {
    elements2.push({
      name: "ELB",
      turns: haveEffect($effect`Everything Looks Blue`),
      color: "blue.solid",
      label: (turns) => `${plural(turns, "turn")} of Everything Looks Blue.`
    });
  }
  if (returnCombats > 0) {
    elements2.push({
      name: "CBB",
      turns: returnCombats,
      color: "gray.solid",
      label: (turns) => `${plural(turns, "combat")} until Cosmic Bowling Ball returns.`
    });
  }
  if (haveUnrestricted($item`Kramco Sausage-o-Matic`)) {
    const lastTurn = get$1("_lastSausageMonsterTurn");
    const turnsToNextGuaranteedFight = Math.round(
      1 / getKramcoWandererChance() * (1 + totalTurnsPlayed() - (lastTurn || totalTurnsPlayed()))
    );
    elements2.push({
      name: "KRAM",
      turns: turnsToNextGuaranteedFight,
      color: "purple.solid",
      label: (turns) => `${plural(turns, "turn")} until guaranteed Kramco fight (${(100 * getKramcoWandererChance()).toFixed(0)}% now).`
    });
  }
  if (have$6()) {
    elements2.push({
      name: "AA",
      turns: available$1() ? 0 : turnsLeft() + 1,
      color: "orange.solid",
      label: (turns) => `${plural(turns, "turn")} until autumn-aton returns.`
    });
  }
  if (haveEquipped($item`cursed magnifying glass`)) {
    elements2.push({
      name: "CMG",
      turns: 13 - get$1("cursedMagnifyingGlassCount"),
      color: "gray.solid",
      label: (turns) => `${plural(turns, "combat")} until next void wanderer.`
    });
  }
  if (getWorkshed() === $item`model train set`) {
    elements2.push({
      name: "MTS",
      turns: 40 - (get$1("trainsetPosition") - get$1("lastTrainsetConfiguration")),
      color: "orange.solid",
      label: (turns) => `${plural(turns, "combat")} until train set reconfigurable.`
    });
  }
  if (getCounter("Spooky VHS Tape Monster") > 0) {
    elements2.push({
      name: "VHS",
      turns: getCounter("Spooky VHS Tape Monster"),
      color: "gray.solid",
      label: (turns) => `${plural(turns, "turn")} until VHS tape monster appears.`
    });
  }
  const elementsFiltered = elements2.filter(({ turns }) => turns > 0);
  elementsFiltered.sort(
    ({ turns: turnsA }, { turns: turnsB }) => turnsA - turnsB
  );
  if (elementsFiltered.length === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { flexFlow: "row wrap", children: elementsFiltered.map(({ name, turns, color, label }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { content: label(turns), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Pill, { bgColor: color, children: [
      name,
      " ",
      turns
    ] }) }, name)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CMCTimeline, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Flyers, {})
  ] });
};
const NAG_DISPLAY_LIMIT = 6;
const NagSection = () => {
  const { nags } = reactExports.useContext(NagContext);
  const nagsList = [...Object.entries(nags)].sort(
    ([, { priority: priorityA }], [, { priority: priorityB }]) => -(priorityA - priorityB)
  );
  const displayCount = nagsList.length > NAG_DISPLAY_LIMIT ? NAG_DISPLAY_LIMIT - 1 : nagsList.length;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Stack,
    {
      top: 0,
      position: "sticky",
      backgroundColor: "white",
      zIndex: 100,
      pt: "0.5rem",
      pb: 2,
      borderBottom: "1px solid",
      borderColor: "gray.muted",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Timeline, { px: 2 }),
        nagsList.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { name: `Day ${myDaycount()} / Turn ${myTurncount()}`, children: [
          nagsList.slice(0, displayCount).map(([id2, { node: node2 }]) => /* @__PURE__ */ jsxRuntimeExports.jsx(TileErrorBoundary, { name: id2, children: node2 }, id2)),
          nagsList.length > NAG_DISPLAY_LIMIT && /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { flexFlow: "row wrap", children: nagsList.slice(displayCount).map(([id2, { imageUrl, node: node2 }]) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tooltip,
              {
                interactive: true,
                contentProps: {
                  color: "black",
                  bgColor: "white",
                  border: "1px solid black",
                  rounded: "md",
                  p: 2
                },
                content: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: node2 }),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TileImage, { imageUrl })
              },
              id2
            );
          }) })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(H2, { px: 2, children: [
          "Day ",
          myDaycount(),
          " / Turn ",
          myTurncount()
        ] })
      ]
    }
  );
};
const TileSection = ({ tiles, ...props }) => {
  const rendered = tiles.map((SpecificTile) => [
    SpecificTile.name,
    /* @__PURE__ */ jsxRuntimeExports.jsx(SpecificTile, {})
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { ...props, children: rendered.map(([name, tile]) => /* @__PURE__ */ jsxRuntimeExports.jsx(TileErrorBoundary, { name, children: tile }, name)) });
};
var Step = /* @__PURE__ */ ((Step2) => {
  Step2[Step2["UNSTARTED"] = -1] = "UNSTARTED";
  Step2[Step2["STARTED"] = 0] = "STARTED";
  Step2[Step2["FINISHED"] = 999] = "FINISHED";
  return Step2;
})(Step || {});
function questValueToNumber(value) {
  if (typeof value === "number") return value;
  const match2 = value.match(/^step([0-9]+)$/);
  if (match2) {
    return parseInt(match2[1]);
  }
  switch (value) {
    case "finished":
      return 999;
    case "started":
      return 0;
    case "unstarted":
    default:
      return -1;
  }
}
function atStep(current, steps) {
  const stepsSorted = [...steps].sort(([stepX], [stepY]) => -(stepX - stepY));
  for (const [step, value] of stepsSorted) {
    if (current >= step) return value;
  }
}
function testQuest(property, operator, threshold) {
  const value = get$1(property, "unstarted");
  const valueNumber = questValueToNumber(value);
  const thresholdNumber = questValueToNumber(threshold);
  switch (operator) {
    case "<":
      return valueNumber < thresholdNumber;
    case "<=":
      return valueNumber <= thresholdNumber;
    case "=":
      return valueNumber === thresholdNumber;
    case ">=":
      return valueNumber >= thresholdNumber;
    case ">":
      return valueNumber > thresholdNumber;
  }
}
function questStarted(property) {
  return testQuest(property, ">=", "started");
}
function questPastStep(property, step) {
  return testQuest(property, ">=", step);
}
function questFinished(property) {
  return testQuest(property, ">=", "finished");
}
function inRun() {
  return !get$1("kingLiberated");
}
const AsyncLink = reactExports.forwardRef(
  ({ href, command, onClick, children, ...props }, ref2) => {
    const { triggerHardRefresh } = reactExports.useContext(RefreshContext);
    const [isLoading, setIsLoading] = reactExports.useState(false);
    const onClickWithCommand = reactExports.useMemo(
      () => command && !onClick ? async () => {
        const result = await remoteCliExecute(command);
        if (result === false) {
          toaster.error({
            title: "Command failed.",
            description: `Failed to execute "${command}".`,
            duration: 5e3
          });
        }
      } : onClick,
      [command, onClick]
    );
    const handleClick = reactExports.useCallback(
      async (event) => {
        event.preventDefault();
        setIsLoading(true);
        await (onClickWithCommand ? onClickWithCommand(event) : href && fetch(href).then((response) => response.text()));
        setIsLoading(false);
        triggerHardRefresh();
      },
      [href, onClickWithCommand, triggerHardRefresh]
    );
    const link = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Link,
      {
        ref: ref2,
        href,
        onClick: handleClick,
        color: "inherit",
        ...props,
        children
      }
    );
    return isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Link,
      {
        ref: ref2,
        ...props,
        textDecoration: "none !important",
        pointerEvents: "none",
        color: "fg.subtle",
        children: [
          children,
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { as: "span", size: "xs" })
        ]
      }
    ) : command ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { showArrow: true, content: command, children: link }) : link;
  }
);
const Line = ({
  href,
  command,
  takeFamiliar,
  equipItem,
  async = false,
  children,
  ...props
}) => {
  if (takeFamiliar && myFamiliar() !== takeFamiliar) {
    command = `familiar ${takeFamiliar.identifierString}`;
  }
  if (equipItem && !haveEquipped(equipItem)) {
    command = `equip ${equipItem.identifierString}`;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...props, children: command ? /* @__PURE__ */ jsxRuntimeExports.jsx(AsyncLink, { command, color: "inherit", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", children }) }) : href ? async ? /* @__PURE__ */ jsxRuntimeExports.jsx(AsyncLink, { href, color: "inherit", children }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href, color: "inherit", children }) : children });
};
const ElementName = ({ element, children }) => {
  const elementColors = {
    cold: "blue.solid",
    hot: "red.solid",
    spooky: "gray.solid",
    stench: "green.solid",
    sleaze: "purple.solid"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { color: elementColors[element], children: children ?? element });
};
const Cold = ({ ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ElementName, { element: "cold", ...props });
};
function renderSourceList(sourceList) {
  const sources = sourceList.map((source) => [source, source.remaining()]).filter(([, remaining]) => remaining > 0).sort(([, a], [, b2]) => b2 - a);
  return {
    total: sum(sources, ([, remaining]) => remaining),
    rendered: sources.map(([{ name, render }, remaining]) => /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: render({ remaining }) }, name)),
    keys: sources.map(([{ name }]) => name)
  };
}
function skill(skill2) {
  const effect2 = toEffect(skill2);
  return {
    thing: effect2,
    available: () => haveUnrestricted(skill2) && !have$b(effect2)
  };
}
function equipment(item2, itemAvailable = () => true) {
  return {
    thing: item2,
    available: () => itemAvailable() && !haveUnrestricted(item2)
  };
}
function potion(item2, itemAvailable = () => true) {
  const effect2 = effectModifier(item2, "Effect");
  return {
    thing: effect2,
    available: () => (itemAvailable() || haveUnrestricted(item2)) && !have$b(effect2),
    value: () => numericModifier(effect2, "Cold Resistance")
  };
}
function effect(effect2, effectAvailable = () => true) {
  return {
    thing: effect2,
    available: () => effectAvailable() && !have$b(effect2)
  };
}
const Leveling = () => {
  if (myLevel() >= 12 || myClass() === $class`Zootomist`) return null;
  const multiplier = 1 + numericModifier(`${myPrimestat().identifierString} Experience Percent`) / 100;
  const levelingSources = [
    {
      name: "Numberology",
      remaining: () => +haveUnrestricted($skill`Calculate the Universe`) && Math.min(3, get$1("skillLevel144")) - get$1("_universeCalculated"),
      render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
        plural(remaining, "numberology use"),
        " (",
        (multiplier * 89).toFixed(0),
        " ",
        "mainstat)."
      ] })
    },
    {
      name: "Bastille",
      remaining: () => +haveUnrestricted($item`Bastille Battalion control rig`) - get$1("_bastilleGames"),
      render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MainLink, { href: inventoryLink($item`Bastille Battalion control rig`), children: [
        "1 Bastille use (",
        (multiplier * 250).toFixed(0),
        " mainstat)."
      ] }) })
    },
    {
      name: "Leaflet",
      remaining: () => +!get$1("leafletCompleted"),
      render: () => {
        const text = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          "1 strange leaflet (Quests menu)",
          myLevel() < 9 ? " (at level 9)" : !have$b($item`strange leaflet`) && " (visit council)",
          "."
        ] });
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: myLevel() >= 9 && !have$b($item`strange leaflet`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: "/council.php", children: text }) : text });
      }
    },
    {
      name: "Enchanted Bean",
      remaining: () => +(questStep("questL10Garbage") <= Step.STARTED && haveUnrestricted($item`spring shoes`)),
      render: () => {
        const haveBean = have$b($item`enchanted bean`);
        const verb = haveBean ? "Plant" : "Find and plant";
        const text = `${verb} an enchanted bean${myLevel() >= 10 ? "" : " (at level 10)"}.`;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: myLevel() >= 10 && haveBean ? haveEquipped($item`spring shoes`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          MainLink,
          {
            href: questStarted("questL10Garbage") ? inventoryLink($item`enchanted bean`) : "/council.php",
            children: text
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(AsyncLink, { command: "equip acc3 spring shoes", children: "Equip spring shoes, then plant enchanted bean." }) : text });
      }
    }
  ];
  const { total, rendered } = renderSourceList(levelingSources);
  const coldResSources = [
    // Can't usually get passives, so don't show those.
    skill($skill`Elemental Saucesphere`),
    skill($skill`Scarysauce`),
    skill($skill`Astral Shell`),
    skill($skill`Feel Peaceful`),
    equipment($item`astronaut helmet`, () => get$1("_photoBoothEquipment") < 3),
    equipment(
      $item`Jurassic Parka`,
      () => haveUnrestricted($item`Jurassic Parka`) && get$1("parkaMode") !== "kachungasaur"
    ),
    equipment($item`Apriling band tuba`),
    equipment($item`bembershoot`),
    {
      thing: $familiar`Exotic Parrot`,
      available: () => have$b($familiar`Exotic Parrot`) && myFamiliar() !== $familiar`Exotic Parrot`,
      value: () => Math.floor((totalFamiliarWeight($familiar`Exotic Parrot`) - 5) / 20)
    },
    potion(
      $item`bottle of antifreeze`,
      () => canInteract() || pullsRemaining() > 0
    ),
    potion(
      $item`Synapse Blaster`,
      () => mySpleenUse() < spleenLimit() && haveUnrestricted($item`server room key`)
    ),
    potion(
      $item`scroll of minor invulnerability`,
      () => haveUnrestricted($skill`Secret Door Awareness`)
    ),
    potion(
      $item`lotion of hotness`,
      () => have$b($skill`Advanced Saucecrafting`)
    ),
    potion(
      $item`lotion of spookiness`,
      () => have$b($skill`Advanced Saucecrafting`)
    ),
    potion($item`cold powder`),
    potion($item`cyan seashell`, () => haveUnrestricted($item`Beach Comb`)),
    effect(
      $effect`Walled In`,
      () => have() && available("wall")
    ),
    effect(
      $effect`Ready to Survive`,
      () => haveUnrestricted($item`MayDay supply package`) || isUnrestricted($item`MayDay supply package`) && get$1("hasMaydayContract") && !get$1("_maydayDropped")
    ),
    effect(
      $effect`Double Hot Soupy Garbage`,
      () => getWorkshed() === $item`model train set`
    ),
    effect(
      $effect`Hot Soupy Garbage`,
      () => getWorkshed() === $item`model train set`
    ),
    effect(
      $effect`Imagining Guts`,
      () => haveUnrestricted($skill`Just the Facts`)
    ),
    {
      thing: "pale horse",
      available: () => get$1("horseryAvailable") && isUnrestricted($item`Horsery contract`) && get$1("_horsery") !== "pale horse",
      value: () => 1
    }
  ];
  const haveSeptEmber = haveUnrestricted($item`Sept-Ember Censer`);
  const mouthwash = $item`Mmm-brr! brand mouthwash`;
  const bembershoot = $item`bembershoot`;
  const septEmbers = +haveSeptEmber && 7 * +!get$1("_septEmberBalanceChecked") + get$1("availableSeptEmbers");
  const neededBembershoots = clamp(
    3 - availableAmount($item`bembershoot`),
    0,
    septEmbers
  );
  const embersAfterBembers = septEmbers - neededBembershoots;
  const neededBembershootsEven = neededBembershoots - embersAfterBembers % 2;
  const potentialMouthwash = availableAmount(mouthwash) + Math.floor((septEmbers - neededBembershootsEven) / 2);
  const coldRes = numericModifier("Cold Resistance");
  const mouthwashMainstat = Math.round(multiplier * 7 * Math.pow(coldRes, 1.7));
  const statName = myPrimestat().identifierString;
  const substat = $stat`Sub${statName === "none" ? "Muscle" : statName}`;
  const currentSubstat = myBasestat(substat);
  const endingSubstat = currentSubstat + mouthwashMainstat * potentialMouthwash;
  const endingStat = Math.sqrt(endingSubstat);
  const endingLevel = Math.sqrt(endingStat - 4) + 1;
  if (total <= 0 && (!haveSeptEmber || potentialMouthwash <= 0)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { header: "Get to Level 12", imageUrl: "/images/itemimages/uparrow.gif", children: [
    haveSeptEmber && potentialMouthwash > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        LinkBlock,
        {
          href: availableAmount(mouthwash) < potentialMouthwash || availableAmount(bembershoot) < neededBembershootsEven ? "/shop.php?whichshop=september" : inventoryLink(mouthwash),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Use ",
              plural(potentialMouthwash, $item`Mmm-brr! brand mouthwash`),
              " ",
              "with ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(Cold, { children: "cold res" }),
              " for lots of stats."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Current: ",
              coldRes,
              " cold res for ",
              mouthwashMainstat.toFixed(0),
              " ",
              "mainstat per mouthwash."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Will reach level ",
              endingLevel.toFixed(1),
              "."
            ] }),
            neededBembershootsEven > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Get ",
              plural(neededBembershootsEven, $item`bembershoot`),
              " first."
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Can get more cold res from:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: coldResSources.filter(({ available: available2 }) => available2()).map(({ thing, value }) => {
        const identifier2 = typeof thing === "string" ? thing : thing.identifierString;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
          identifier2,
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Cold, { children: [
            "(+",
            value ? value() : get("Cold Resistance", thing),
            ")"
          ] })
        ] }, identifier2);
      }) })
    ] }),
    total > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Additional stat sources:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: rendered })
    ] })
  ] });
};
function useNag(callback, dependencies) {
  const { rerenderCount, hardRefreshCount } = reactExports.useContext(RefreshContext);
  const { withNag } = reactExports.useContext(NagContext);
  const memoizedCallback = reactExports.useCallback(callback, [
    ...dependencies,
    rerenderCount,
    hardRefreshCount
  ]);
  reactExports.useEffect(() => {
    const { id: id2, priority, imageUrl, node: node2 } = memoizedCallback();
    withNag(id2, priority, imageUrl, node2);
  }, [memoizedCallback, withNag]);
}
function filterHave(obj) {
  return Object.fromEntries(
    Object.entries(obj).map(([tag, familiars]) => [
      tag,
      familiars.filter(haveUnrestricted)
    ])
  );
}
function familiarsWithGoals(header, goals) {
  return Object.values(goals).some((x2) => x2.length > 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      header,
      ":"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: Object.entries(goals).filter(([, familiars]) => familiars.length > 0).map(([goal, familiars]) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
      goal,
      ": ",
      commaSeparate(familiars),
      "."
    ] }, goal)) })
  ] });
}
const Zootomist = () => {
  const enable = myClass() === $class`Zootomist`;
  const yrFamiliars = $familiars`Quantum Entangler, Foul Ball`;
  const banishFamiliars = $familiars`Phantom Limb, Dire Cassava`;
  const leftFoot = get$1("zootGraftedFootLeftFamiliar");
  const rightFoot = get$1("zootGraftedFootRightFamiliar");
  const hasYR = leftFoot && yrFamiliars.includes(leftFoot) ? "left" : rightFoot && yrFamiliars.includes(rightFoot) ? "right" : null;
  const hasBanish = leftFoot && banishFamiliars.includes(leftFoot) ? "left" : rightFoot && banishFamiliars.includes(rightFoot) ? "right" : null;
  const feet = reactExports.useMemo(
    () => ({ left: leftFoot, right: rightFoot }),
    [leftFoot, rightFoot]
  );
  const hasELY = have$b($effect`Everything Looks Yellow`);
  const hasELB = have$b($effect`Everything Looks Blue`);
  useNag(
    () => ({
      id: "zootomist-ely-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: hasYR && feet[hasYR] ? `/images/itemimages/${feet[hasYR].image}` : "",
      node: enable && hasYR && feet[hasYR] && !hasELY && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: `Use ${hasYR} kick YR`,
          imageUrl: `/images/itemimages/${feet[hasYR].image}`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "yellow.700", _dark: { color: "yellow.300" }, children: "Free kill and force monster drops." })
        }
      )
    }),
    [enable, feet, hasELY, hasYR]
  );
  useNag(
    () => ({
      id: "zootomist-elb-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: hasBanish && feet[hasBanish] ? `/images/itemimages/${feet[hasBanish].image}` : "",
      node: enable && hasBanish && feet[hasBanish] && !hasELB && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: `Use ${hasBanish} kick banish`,
          imageUrl: `/images/itemimages/${feet[hasBanish].image}`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "blue.solid", children: "Free fight and banish monster for 100 turns." })
        }
      )
    }),
    [enable, feet, hasBanish, hasELB]
  );
  if (!enable || myLevel() >= 13) return null;
  const head = get$1("zootGraftedHeadFamiliar");
  const shoulders = [
    get$1("zootGraftedShoulderLeftFamiliar"),
    get$1("zootGraftedShoulderRightFamiliar")
  ];
  const butt = [
    get$1("zootGraftedButtCheekLeftFamiliar"),
    get$1("zootGraftedButtCheekRightFamiliar")
  ];
  const headShouldersButt = truthy([head, ...shoulders, ...butt]);
  const suggestedHead = $familiars`Mechanical Songbird, Exotic Parrot, Baby Z-Rex, Smiling Rat, Jumpsuited Hound Dog, Ghuol Whelp, Ragamuffin Imp`.filter(haveUnrestricted).slice(0, 6 - headShouldersButt.length);
  const suggestedLeftNipple = filterHave({
    "-combat": $familiars`Scary Death Orb, Stab Bat, Syncopated Turtle`,
    "fam xp": $familiars`Stab Bat, Syncopated Turtle, Ragamuffin Imp`,
    item: $familiars`Stab Bat, Syncopated Turtle, Mechanical Songbird, Scary Death Orb`
  });
  const suggestedRightNipple = filterHave({
    "+combat": $familiars`Syncopated Turtle, Stinky Gravy Fairy, Topiary Skunk`,
    "fam xp": $familiars`Killer Bee, Mosquito`,
    item: $familiars`Ragamuffin Imp, Misshapen Animal Skeleton, Ghuol Whelp`
  });
  const suggestedLeftKick = yrFamiliars.filter(haveUnrestricted);
  const suggestedRightKick = banishFamiliars.filter(haveUnrestricted);
  const currentXp = myFamiliar().experience;
  const threshold = (myLevel() + 2) ** 2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Z is for Zootomist",
      imageUrl: "/images/adventureimages/zootomist.gif",
      href: "/place.php?whichplace=graftinglab",
      linkEntireTile: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Graft ",
          plural(12 - myLevel(), "additional familiar"),
          " to yourself to hit level 13."
        ] }),
        myFamiliar() !== $familiar`none` && (currentXp < threshold ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Need ",
          threshold - currentXp,
          " XP on ",
          myFamiliar().identifierString,
          " ",
          "to graft."
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { fontWeight: "bold", children: [
          "Could graft ",
          myFamiliar().identifierString,
          " now!"
        ] })),
        !get$1("zootGraftedNippleLeftFamiliar") && familiarsWithGoals("Left Nipple", suggestedLeftNipple),
        !get$1("zootGraftedNippleRightFamiliar") && familiarsWithGoals("Right Nipple", suggestedRightNipple),
        !get$1("zootGraftedFootLeftFamiliar") && suggestedLeftKick.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Left Kick (free YR): ",
          commaSeparate(suggestedLeftKick),
          "."
        ] }),
        !get$1("zootGraftedFootRightFamiliar") && suggestedRightKick.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Right Kick (free banish): ",
          commaSeparate(suggestedRightKick),
          "."
        ] }),
        headShouldersButt.length < 5 && suggestedHead.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          separate(
            [
              !head && "Head",
              shoulders.some((s) => !s) && "Shoulders",
              butt.some((b2) => !b2) && "Butt"
            ],
            "/"
          ),
          ": ",
          commaSeparate(suggestedHead),
          "."
        ] })
      ]
    }
  );
};
const AdviceTooltip = ({ content: content2, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Tooltip,
  {
    openDelay: 0,
    contentProps: {
      css: { "--tooltip-bg": "bg" },
      color: "fg.subtle",
      bgColor: "bg",
      border: "1px solid border",
      shadow: "xs",
      rounded: "md",
      p: 2
    },
    content: content2,
    ...props
  }
);
const AdviceTooltipText = ({
  advice,
  textProps,
  children,
  ...props
}) => {
  const toolTip = /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { bg: "bg.muted", color: "fg.muted", p: 2, rounded: "md", fontSize: "xs", children: typeof advice === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: advice }) : advice });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltip, { content: toolTip, ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Text,
    {
      as: "span",
      textDecoration: "underline dotted",
      cursor: "pointer",
      ...textProps,
      children
    }
  ) });
};
const BATSNAKE = {
  monster: $monster`Batsnake`,
  locations: [$location`The Batrat and Ratbat Burrow`],
  item: "The Stankara Stone"
};
const FROZEN_SOLID_SNAKE = {
  monster: $monster`Frozen Solid Snake`,
  locations: [$location`Lair of the Ninja Snowmen`],
  item: "The First Pizza"
};
const BURNING_SNAKE_OF_FIRE = {
  monster: $monster`Burning Snake of Fire`,
  locations: [$location`The Castle in the Clouds in the Sky (Top Floor)`],
  item: "Murphy's Rancid Black Flag"
};
const SNAKE_WITH_LIKE_TEN_HEADS = {
  monster: $monster`The Snake With Like Ten Heads`,
  locations: [$location`The Hole in the Sky`],
  item: "The Eye of the Stars"
};
const FRATTLESNAKE = {
  monster: $monster`The Frattlesnake`,
  locations: [$location`The Smut Orc Logging Camp`],
  item: "The Lacrosse Stick of Lacoronado"
};
const SNAKELETON = {
  monster: $monster`Snakeleton`,
  locations: [
    $location`The Unquiet Garves`,
    $location`The VERY Unquiet Garves`
  ],
  item: "The Shield of Brook"
};
const SHEN_DAYS = [
  [BATSNAKE, FROZEN_SOLID_SNAKE, BURNING_SNAKE_OF_FIRE],
  [FRATTLESNAKE, SNAKELETON, SNAKE_WITH_LIKE_TEN_HEADS],
  [FROZEN_SOLID_SNAKE, BATSNAKE, SNAKELETON],
  [FRATTLESNAKE, BATSNAKE, SNAKELETON],
  [BURNING_SNAKE_OF_FIRE, FRATTLESNAKE, SNAKE_WITH_LIKE_TEN_HEADS],
  [BURNING_SNAKE_OF_FIRE, BATSNAKE, SNAKE_WITH_LIKE_TEN_HEADS],
  [FRATTLESNAKE, SNAKELETON, SNAKE_WITH_LIKE_TEN_HEADS],
  [SNAKELETON, BURNING_SNAKE_OF_FIRE, FRATTLESNAKE],
  [SNAKELETON, FRATTLESNAKE, SNAKE_WITH_LIKE_TEN_HEADS],
  [SNAKE_WITH_LIKE_TEN_HEADS, BATSNAKE, BURNING_SNAKE_OF_FIRE],
  [FROZEN_SOLID_SNAKE, BATSNAKE, BURNING_SNAKE_OF_FIRE]
];
function shenDay() {
  if (questStep("questL11Shen") < 1) return;
  const initiationDay = get$1("shenInitiationDay");
  return SHEN_DAYS[(initiationDay - 1) % SHEN_DAYS.length];
}
function remainingSnakes() {
  const day = shenDay();
  if (day === void 0) return;
  const questItem = get$1("shenQuestItem");
  const index = day.findIndex((s) => s.item === (questItem == null ? void 0 : questItem.identifierString));
  if (index < 0) return;
  return day.slice(index);
}
function currentSnake() {
  var _a2;
  return (_a2 = remainingSnakes()) == null ? void 0 : _a2[0];
}
const MACHETES = $items`antique machete, muculent machete, machetito`;
function haveMachete() {
  return MACHETES.some((item2) => have$b(item2));
}
function lianasCanBeFree() {
  return myPath() !== $path`Avant Guard` && myPath() !== $path`BIG!`;
}
function delayZones() {
  const snakes = remainingSnakes();
  return [
    {
      zone: $location`The Spooky Forest`,
      length: 5,
      needed: () => !questFinished("questL02Larva") || !hiddenTempleUnlocked()
    },
    {
      zone: $location`The Haunted Gallery`,
      length: 5,
      needed: () => !questFinished("questM21Dance")
    },
    {
      zone: $location`The Haunted Bathroom`,
      length: 5,
      needed: () => !questFinished("questM21Dance")
    },
    {
      zone: $location`The Haunted Bedroom`,
      length: 6,
      needed: () => !questFinished("questM21Dance")
    },
    {
      zone: $location`The Haunted Ballroom`,
      length: 5,
      needed: () => !questPastStep("questL11Manor", 1)
    },
    {
      zone: $location`The Penultimate Fantasy Airship`,
      length: haveUnrestricted($item`bat wings`) ? 20 : 25,
      needed: () => !questPastStep("questL10Garbage", 7)
    },
    {
      zone: $location`The Hidden Park`,
      length: 6,
      needed: () => !haveMachete() && lianasCanBeFree()
    },
    {
      zone: $location`The Upper Chamber`,
      length: 5,
      needed: () => !questPastStep("questL11Pyramid", 1)
    },
    {
      zone: $location`The Middle Chamber`,
      length: 10,
      needed: () => !questPastStep("questL11Pyramid", 3)
    },
    {
      zone: $location`The Castle in the Clouds in the Sky (Ground Floor)`,
      length: 10,
      needed: () => !questPastStep("questL10Garbage", 9)
    },
    ...snakes ? snakes.map(({ locations, item: item2 }) => ({
      zone: locations[0],
      length: 3,
      needed: () => !have$b(Item.get(item2)),
      available: () => {
        var _a2;
        return ((_a2 = get$1("shenQuestItem")) == null ? void 0 : _a2.identifierString) === item2;
      }
    })) : [],
    {
      zone: $location`The Copperhead Club`,
      length: 14,
      needed: () => !questFinished("questL11Shen")
    },
    {
      zone: $location`The Outskirts of Cobb's Knob`,
      length: 10,
      needed: () => !questPastStep("questL05Goblin", 1)
    },
    {
      zone: $location`The Boss Bat's Lair`,
      length: 4,
      needed: () => !questFinished("questL04Bat")
    }
  ];
}
function remainingDelay() {
  return delayZones().map(({ zone, length: length2, needed, available: available2 }) => ({
    zone,
    remaining: needed === void 0 || needed() ? length2 - zone.turnsSpent : 0,
    available: canAdventure(zone) && (available2 === void 0 || available2())
  })).filter(({ remaining }) => remaining > 0);
}
const ZoneList = ({ zones, disabledColor = "fg.subtle" }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: zones.map(({ zone, remaining, available: available2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ListItem,
  {
    color: available2 ? void 0 : disabledColor,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MainLink, { href: available2 ? parentPlaceLink(zone) : void 0, children: [
      plural(remaining, "turn"),
      " in ",
      zone.identifierString,
      "."
    ] })
  },
  zone.identifierString
)) });
const Delay = () => {
  let allRemaining = remainingDelay().sort(
    ({ available: availableA }, { available: availableB }) => +availableB - +availableA
  );
  let truncated = [];
  if (allRemaining.length > 7 && allRemaining.some(({ available: available2 }) => !available2)) {
    truncated = allRemaining.slice(7);
    allRemaining = allRemaining.slice(0, 7);
  }
  const total = sum(allRemaining, ({ remaining }) => remaining);
  if (total <= 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: `${plural(total, "turn")} of delay`,
      id: "delay-zones-tile",
      imageUrl: "/images/itemimages/al_dayshorter.gif",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use free runs and free wanderers to avoid spending turns." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ZoneList, { zones: allRemaining, disabledColor: "fg.subtle" }),
        truncated.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdviceTooltipText,
          {
            advice: /* @__PURE__ */ jsxRuntimeExports.jsx(ZoneList, { zones: truncated, disabledColor: "fg.muted" }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Later zones." })
          }
        )
      ]
    }
  );
};
const QuestTile = ({
  header,
  href,
  minLevel,
  children,
  ...props
}) => {
  return minLevel !== void 0 && myLevel() < minLevel ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header,
      headerSuffix: `(level ${minLevel})`,
      ...props,
      disabled: true
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Tile, { header, href, ...props, children });
};
const DigitalKeyQuest = () => {
  const continuumTransfunctioner = $item`continuum transfunctioner`;
  const digitalKey = $item`digital key`;
  const started = haveUnrestricted(continuumTransfunctioner);
  const finished = myPath() === $path`Community Service` || myPath() === $path`Kingdom of Exploathing` || get$1("kingLiberated") || have$b(digitalKey) || get$1("nsTowerDoorKeysUsed").includes("digital key");
  const currentScore = get$1("8BitScore");
  const currentColor = get$1("8BitColor") || "black";
  const helpfulModifier = {
    black: "Initiative",
    red: "Meat Drop",
    blue: "Damage Absorption",
    green: "Item Drop"
  };
  const minimumToAddPoints = {
    black: 300,
    red: 150,
    blue: 300,
    green: 100
  };
  const zoneMap = {
    black: "Vanya's Castle",
    red: "The Fungus Plains",
    blue: "Megalo-City",
    green: "Hero's Field"
  };
  const nextColor = {
    black: "blue",
    red: "black",
    blue: "green",
    green: "red"
  };
  const bonusTurnsRemaining = 5 - get$1("8BitBonusTurns");
  const userModifier = Object.fromEntries(
    Object.entries(helpfulModifier).map(([key, value]) => [
      key,
      numericModifier(value)
    ])
  );
  const expectedPoints = Object.fromEntries(
    Object.entries(helpfulModifier).map(([key]) => {
      const isCurrentZoneBonus = currentColor === key;
      const addedBonus = isCurrentZoneBonus ? 100 : 50;
      const denominator = isCurrentZoneBonus ? 10 : 20;
      const rawPoints = Math.min(
        300,
        Math.max(
          0,
          userModifier[key] - minimumToAddPoints[key]
        )
      );
      return [key, addedBonus + Math.round(rawPoints / denominator) * 10];
    })
  );
  const highestPointColor = maxBy(
    Object.entries(expectedPoints),
    ([, value]) => value
  )[0];
  if (finished) return null;
  if (!started) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      QuestTile,
      {
        header: "Get the continuum transfunctioner",
        id: "digital-key-quest",
        imageUrl: "/images/itemimages/pixelkey.gif",
        href: "/place.php?whichplace=forestvillage&action=fv_mystic",
        minLevel: 2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit the crackpot mystic for your transfunctioner." })
      }
    );
  }
  const activeMod = helpfulModifier[currentColor];
  const neededModifier = (minimumToAddPoints[currentColor] + 300).toString();
  const treasureLink = haveEquipped(continuumTransfunctioner) ? "/place.php?whichplace=8bit&action=8treasure" : void 0;
  const suffix = activeMod !== "Damage Absorption" ? "%" : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: `Get ${currentScore < 1e4 ? `${(1e4 - currentScore).toLocaleString()} digital key points` : "digital key"}`,
      id: "digital-key-quest",
      imageUrl: "/images/itemimages/pixelkey.gif",
      href: haveEquipped(continuumTransfunctioner) ? "/place.php?whichplace=8bit" : inventoryLink(continuumTransfunctioner),
      minLevel: 5,
      children: [
        currentScore >= 1e4 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: treasureLink, children: "Woah, 10000 points??? That's this life's high score!" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: treasureLink, children: [
            "Visit the ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Treasure House" }),
            " to claim your hard-earned Digital Key."
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "BONUS ZONE" }),
            ":",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { color: currentColor, children: zoneMap[currentColor] }),
            ` (${plural(bonusTurnsRemaining, "more fight", "more fights")})`
          ] }),
          expectedPoints[currentColor] === 400 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: currentColor, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "MAXIMUM POINTS!" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Adventure in",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: currentColor, children: zoneMap[currentColor] }),
              " ",
              "for 400 points per turn!"
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Current expected points: ",
              expectedPoints[currentColor],
              "."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Need ",
              activeMod === "Initiative" && `+${neededModifier}% init`,
              activeMod === "Meat Drop" && `+${neededModifier}% meat`,
              activeMod === "Damage Absorption" && `+${neededModifier} DA`,
              activeMod === "Item Drop" && `+${neededModifier}% item`,
              ". You have ",
              numericModifier(activeMod).toFixed(0),
              suffix,
              "."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "You need",
              " ",
              (minimumToAddPoints[currentColor] + 300 - userModifier[currentColor]).toFixed(0),
              suffix,
              " more for max points."
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "In ",
            plural(bonusTurnsRemaining, "more fight", "more fights"),
            ", bonus zone will be",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { color: nextColor[currentColor], children: zoneMap[nextColor[currentColor]] }),
            "."
          ] }),
          highestPointColor !== currentColor && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "gray", children: [
            "Alternate Route: At current stats, you'd earn",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
              expectedPoints[highestPointColor],
              " points"
            ] }),
            " per fight at ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: zoneMap[highestPointColor] }),
            ". Not recommended!"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "If you max your bonus, key in",
            " ",
            plural(Math.ceil((1e4 - currentScore) / 400), "turn"),
            "."
          ] })
        ] }),
        !haveEquipped(continuumTransfunctioner) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "equip acc3 continuum transfunctioner", color: "red", children: "Equip your transfunctioner to access the realm." })
      ]
    }
  );
};
const HeroKeys = () => {
  const fatLootTokens = availableAmount($item`fat loot token`);
  const towerKeysUsed = get$1("nsTowerDoorKeysUsed").split(",").filter((s) => s).map((name) => Item.get(name));
  const heroKeys = $items`Sneaky Pete's key, Jarlsberg's key, Boris's key`;
  const heroKeysUsed = heroKeys.filter((key) => towerKeysUsed.includes(key));
  const heroKeysAvailable = heroKeys.filter((key) => have$b(key));
  const heroKeysMissing = heroKeys.filter(
    (key) => !heroKeysUsed.includes(key) && !heroKeysAvailable.includes(key)
  );
  const neededTokensKeys = heroKeysMissing.length - fatLootTokens;
  const needKeys = myPath() !== $path`Community Service` && myPath() !== $path`Actually Ed the Undying` && neededTokensKeys > 0;
  const ringOfDetectBoringDoors = $item`ring of Detect Boring Doors`;
  const haveRingOfDetectBoringDoors = have$b(ringOfDetectBoringDoors);
  const haveRingEquipped = haveEquipped(ringOfDetectBoringDoors);
  const elevenFootPole = $item`eleven-foot pole`;
  const haveElevenFootPole = have$b(elevenFootPole);
  const pickOMaticLockpicks = $item`Pick-O-Matic lockpicks`;
  const havePickOMaticLockpicks = have$b(pickOMaticLockpicks);
  const gelatinousCubeling = $familiar`Gelatinous Cubeling`;
  const canTakeCubeling = have$b(gelatinousCubeling) && canEquip(gelatinousCubeling);
  const lastAdventure = myLocation();
  const dailyDungeonDone = get$1("dailyDungeonDone");
  const lastDailyDungeonRoom = get$1("_lastDailyDungeonRoom");
  const dailyDungeonRemaining = !haveRingOfDetectBoringDoors ? 15 - lastDailyDungeonRoom : lastDailyDungeonRoom > 10 ? 15 - lastDailyDungeonRoom : lastDailyDungeonRoom > 5 ? 13 - lastDailyDungeonRoom : 11 - lastDailyDungeonRoom;
  const looseTeethCount = availableAmount($item`loose teeth`);
  const skeletonBoneCount = availableAmount($item`skeleton bone`);
  const skeletonKeyCount = availableAmount($item`skeleton key`);
  const skeletonKeyCreatable = Math.min(looseTeethCount, skeletonBoneCount);
  const skeletonKeyAvailable = skeletonKeyCount + skeletonKeyCreatable;
  const canCast22 = canCast(22);
  const haveJustTheFacts = have$b($skill`Just the Facts`);
  const cyrptNookEvilness = get$1("cyrptNookEvilness");
  const cyrptAlcoveEvilness = get$1("cyrptAlcoveEvilness");
  const looseTeethSources = reactExports.useMemo(
    () => [
      {
        name: "casting Aug. 22",
        count: 4,
        condition: canCast22
      },
      {
        name: "toothy sklelton in the Nook",
        // Approximation of how many teeth you can get from the nook
        count: 1 + Math.ceil((cyrptNookEvilness - 13) / 8),
        condition: cyrptNookEvilness > 13
      },
      {
        name: "Alcove boss",
        count: 1,
        condition: cyrptAlcoveEvilness > 0
      }
    ],
    [canCast22, cyrptAlcoveEvilness, cyrptNookEvilness]
  );
  const skeletonBoneSources = reactExports.useMemo(
    () => [
      {
        name: "spiny skleleton in the Nook",
        // Approximation of how many bones you can get from the nook
        count: 1 + Math.ceil((cyrptNookEvilness - 13) / 5),
        condition: cyrptNookEvilness > 13
      },
      {
        name: "Nook boss",
        count: 3,
        condition: cyrptNookEvilness > 0
      },
      {
        name: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { target: "_blank", href: "https://bofa.loathers.net", children: "BOFA (approximate)" }),
        count: 1,
        condition: haveJustTheFacts
      }
    ],
    [cyrptNookEvilness, haveJustTheFacts]
  );
  const potentialLooseTeeth = looseTeethCount + sum(looseTeethSources, (source) => source.condition ? source.count : 0);
  const potentialSkeletonBones = skeletonBoneCount + sum(skeletonBoneSources, (source) => source.condition ? source.count : 0);
  const potentialSkeletonKeys = skeletonKeyCount + Math.min(potentialLooseTeeth, potentialSkeletonBones);
  const needMoreSkeletonKeysForDailyDungeon = needKeys && !dailyDungeonDone && !have$b($item`Platinum Yendorian Express Card`) && !have$b(pickOMaticLockpicks) && skeletonKeyAvailable <= 1;
  const needSkeletonKeyForTower = skeletonKeyAvailable === 0;
  const avoidUsingSkeletonKey = needMoreSkeletonKeysForDailyDungeon && potentialSkeletonKeys <= 2 && canTakeCubeling;
  const skeletonKeyOptions = reactExports.useMemo(
    () => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        "You need",
        " ",
        needMoreSkeletonKeysForDailyDungeon ? "more skeleton keys" : "a skeleton key for the tower",
        ". You have ",
        skeletonKeyAvailable,
        " keys (",
        looseTeethCount,
        " teeth,",
        " ",
        skeletonBoneCount,
        " bones)."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
        looseTeethSources.map((source, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
          source.count,
          " teeth from ",
          source.name,
          "."
        ] }, index)),
        skeletonBoneSources.map((source, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
          source.count,
          " bones from ",
          source.name,
          "."
        ] }, index))
      ] })
    ] }),
    [
      needMoreSkeletonKeysForDailyDungeon,
      skeletonKeyAvailable,
      looseTeethCount,
      skeletonBoneCount,
      looseTeethSources,
      skeletonBoneSources
    ]
  );
  useNag(() => {
    const nodes = {};
    if (needKeys && lastAdventure === $location`The Daily Dungeon` && lastDailyDungeonRoom < 14 && neededTokensKeys > 0) {
      if (haveRingOfDetectBoringDoors && !haveRingEquipped && !dailyDungeonDone && lastDailyDungeonRoom < 10) {
        nodes.ring = /* @__PURE__ */ jsxRuntimeExports.jsx(
          Tile,
          {
            header: "Wear ring of detect boring doors",
            linkedContent: ringOfDetectBoringDoors,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Speeds up daily dungeon." })
          }
        );
      }
      if (avoidUsingSkeletonKey) {
        nodes.skeletonKey = /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Tile,
          {
            header: "Avoid using your skeleton key in the daily dungeon",
            imageUrl: "/images/itemimages/skeletonkey.gif",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Running low, will need one for the tower." }),
              skeletonKeyOptions
            ]
          }
        );
      }
      if (canTakeCubeling && !havePickOMaticLockpicks && (skeletonKeyAvailable === 0 || avoidUsingSkeletonKey) || !haveElevenFootPole || !haveRingOfDetectBoringDoors) {
        nodes.cubeling = /* @__PURE__ */ jsxRuntimeExports.jsx(
          Tile,
          {
            header: "Use gelatinous cubeling first",
            linkedContent: gelatinousCubeling,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You're adventuring in the daily dungeon without cubeling drops." })
          }
        );
      }
    }
    return {
      id: "daily-dungeon-location-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/loottoken.gif",
      node: Object.keys(nodes).length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: Object.entries(nodes).map(([key, node2]) => /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: node2 }, key)) }) : null
    };
  }, [
    needKeys,
    lastAdventure,
    lastDailyDungeonRoom,
    neededTokensKeys,
    haveRingOfDetectBoringDoors,
    haveRingEquipped,
    dailyDungeonDone,
    avoidUsingSkeletonKey,
    canTakeCubeling,
    havePickOMaticLockpicks,
    skeletonKeyAvailable,
    haveElevenFootPole,
    ringOfDetectBoringDoors,
    skeletonKeyOptions,
    gelatinousCubeling
  ]);
  return (needKeys || needSkeletonKeyForTower) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: needKeys ? `Get ${plural(
        neededTokensKeys,
        "fat loot token"
      )} or ${pluralJustDesc(neededTokensKeys, "key")}` : "Get skeleton key for tower",
      id: "hero-key-quest",
      imageUrl: "/images/itemimages/loottoken.gif",
      children: [
        needKeys && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: !dailyDungeonDone ? "/da.php" : void 0, children: [
            "Explore",
            " ",
            dailyDungeonDone ? "" : `${plural(dailyDungeonRemaining, "more room")} of `,
            "the Daily Dungeon",
            " ",
            get$1("dailyDungeonDone") ? "again tomorrow " : "",
            "for a fat loot token.",
            have$b($item`candy cane sword cane`) && !get$1("candyCaneSwordDailyDungeon") && lastDailyDungeonRoom < 10 ? " Wear your candy cane sword for an extra token in room 10." : ""
          ] }),
          haveUnrestricted($skill`Lock Picking`) && !get$1("lockPicked") && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: skillLink($skill`Lock Picking`), children: [
            "Pick a lock for one of ",
            commaOr(heroKeysMissing),
            "."
          ] }),
          haveUnrestricted($item`Deck of Every Card`) && get$1("_deckCardsDrawn") <= 10 && !get$1("_deckCardsSeen").includes("Tower") && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`Deck of Every Card`), children: "Draw the Tower card from your Deck for a key." }),
          (get$1("_frToday") || get$1("frAlways")) && isUnrestricted($item`FantasyRealm guest pass`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Fight 5 fantasy bandits for a fat loot token." })
        ] }),
        needSkeletonKeyForTower ? skeletonKeyOptions : skeletonKeyCount <= 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Line,
          {
            command: `create ${Math.min(5, skeletonKeyCreatable)} skeleton key`,
            children: [
              "Make up to ",
              plural(skeletonKeyCreatable, "more skeleton key"),
              " for the dungeon."
            ]
          }
        ) : null
      ]
    }
  );
};
function FFT(size2) {
  this.size = size2 | 0;
  if (this.size <= 1 || (this.size & this.size - 1) !== 0)
    throw new Error("FFT size must be a power of two and bigger than 1");
  this._csize = size2 << 1;
  var table = new Array(this.size * 2);
  for (var i = 0; i < table.length; i += 2) {
    const angle = Math.PI * i / this.size;
    table[i] = Math.cos(angle);
    table[i + 1] = -Math.sin(angle);
  }
  this.table = table;
  var power = 0;
  for (var t2 = 1; this.size > t2; t2 <<= 1)
    power++;
  this._width = power % 2 === 0 ? power - 1 : power;
  this._bitrev = new Array(1 << this._width);
  for (var j = 0; j < this._bitrev.length; j++) {
    this._bitrev[j] = 0;
    for (var shift2 = 0; shift2 < this._width; shift2 += 2) {
      var revShift = this._width - shift2 - 2;
      this._bitrev[j] |= (j >>> shift2 & 3) << revShift;
    }
  }
  this._out = null;
  this._data = null;
  this._inv = 0;
}
var fft = FFT;
FFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {
  var res = storage || new Array(complex.length >>> 1);
  for (var i = 0; i < complex.length; i += 2)
    res[i >>> 1] = complex[i];
  return res;
};
FFT.prototype.createComplexArray = function createComplexArray() {
  const res = new Array(this._csize);
  for (var i = 0; i < res.length; i++)
    res[i] = 0;
  return res;
};
FFT.prototype.toComplexArray = function toComplexArray(input, storage) {
  var res = storage || this.createComplexArray();
  for (var i = 0; i < res.length; i += 2) {
    res[i] = input[i >>> 1];
    res[i + 1] = 0;
  }
  return res;
};
FFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {
  var size2 = this._csize;
  var half = size2 >>> 1;
  for (var i = 2; i < half; i += 2) {
    spectrum[size2 - i] = spectrum[i];
    spectrum[size2 - i + 1] = -spectrum[i + 1];
  }
};
FFT.prototype.transform = function transform(out, data) {
  if (out === data)
    throw new Error("Input and output buffers must be different");
  this._out = out;
  this._data = data;
  this._inv = 0;
  this._transform4();
  this._out = null;
  this._data = null;
};
FFT.prototype.realTransform = function realTransform(out, data) {
  if (out === data)
    throw new Error("Input and output buffers must be different");
  this._out = out;
  this._data = data;
  this._inv = 0;
  this._realTransform4();
  this._out = null;
  this._data = null;
};
FFT.prototype.inverseTransform = function inverseTransform(out, data) {
  if (out === data)
    throw new Error("Input and output buffers must be different");
  this._out = out;
  this._data = data;
  this._inv = 1;
  this._transform4();
  for (var i = 0; i < out.length; i++)
    out[i] /= this.size;
  this._out = null;
  this._data = null;
};
FFT.prototype._transform4 = function _transform4() {
  var out = this._out;
  var size2 = this._csize;
  var width = this._width;
  var step = 1 << width;
  var len = size2 / step << 1;
  var outOff;
  var t2;
  var bitrev = this._bitrev;
  if (len === 4) {
    for (outOff = 0, t2 = 0; outOff < size2; outOff += len, t2++) {
      const off = bitrev[t2];
      this._singleTransform2(outOff, off, step);
    }
  } else {
    for (outOff = 0, t2 = 0; outOff < size2; outOff += len, t2++) {
      const off = bitrev[t2];
      this._singleTransform4(outOff, off, step);
    }
  }
  var inv = this._inv ? -1 : 1;
  var table = this.table;
  for (step >>= 2; step >= 2; step >>= 2) {
    len = size2 / step << 1;
    var quarterLen = len >>> 2;
    for (outOff = 0; outOff < size2; outOff += len) {
      var limit = outOff + quarterLen;
      for (var i = outOff, k2 = 0; i < limit; i += 2, k2 += step) {
        const A2 = i;
        const B2 = A2 + quarterLen;
        const C2 = B2 + quarterLen;
        const D2 = C2 + quarterLen;
        const Ar = out[A2];
        const Ai2 = out[A2 + 1];
        const Br = out[B2];
        const Bi2 = out[B2 + 1];
        const Cr = out[C2];
        const Ci2 = out[C2 + 1];
        const Dr = out[D2];
        const Di2 = out[D2 + 1];
        const MAr = Ar;
        const MAi = Ai2;
        const tableBr = table[k2];
        const tableBi = inv * table[k2 + 1];
        const MBr = Br * tableBr - Bi2 * tableBi;
        const MBi = Br * tableBi + Bi2 * tableBr;
        const tableCr = table[2 * k2];
        const tableCi = inv * table[2 * k2 + 1];
        const MCr = Cr * tableCr - Ci2 * tableCi;
        const MCi = Cr * tableCi + Ci2 * tableCr;
        const tableDr = table[3 * k2];
        const tableDi = inv * table[3 * k2 + 1];
        const MDr = Dr * tableDr - Di2 * tableDi;
        const MDi = Dr * tableDi + Di2 * tableDr;
        const T0r = MAr + MCr;
        const T0i = MAi + MCi;
        const T1r = MAr - MCr;
        const T1i = MAi - MCi;
        const T2r = MBr + MDr;
        const T2i = MBi + MDi;
        const T3r = inv * (MBr - MDr);
        const T3i = inv * (MBi - MDi);
        const FAr = T0r + T2r;
        const FAi = T0i + T2i;
        const FCr = T0r - T2r;
        const FCi = T0i - T2i;
        const FBr = T1r + T3i;
        const FBi = T1i - T3r;
        const FDr = T1r - T3i;
        const FDi = T1i + T3r;
        out[A2] = FAr;
        out[A2 + 1] = FAi;
        out[B2] = FBr;
        out[B2 + 1] = FBi;
        out[C2] = FCr;
        out[C2 + 1] = FCi;
        out[D2] = FDr;
        out[D2 + 1] = FDi;
      }
    }
  }
};
FFT.prototype._singleTransform2 = function _singleTransform2(outOff, off, step) {
  const out = this._out;
  const data = this._data;
  const evenR = data[off];
  const evenI = data[off + 1];
  const oddR = data[off + step];
  const oddI = data[off + step + 1];
  const leftR = evenR + oddR;
  const leftI = evenI + oddI;
  const rightR = evenR - oddR;
  const rightI = evenI - oddI;
  out[outOff] = leftR;
  out[outOff + 1] = leftI;
  out[outOff + 2] = rightR;
  out[outOff + 3] = rightI;
};
FFT.prototype._singleTransform4 = function _singleTransform4(outOff, off, step) {
  const out = this._out;
  const data = this._data;
  const inv = this._inv ? -1 : 1;
  const step2 = step * 2;
  const step3 = step * 3;
  const Ar = data[off];
  const Ai2 = data[off + 1];
  const Br = data[off + step];
  const Bi2 = data[off + step + 1];
  const Cr = data[off + step2];
  const Ci2 = data[off + step2 + 1];
  const Dr = data[off + step3];
  const Di2 = data[off + step3 + 1];
  const T0r = Ar + Cr;
  const T0i = Ai2 + Ci2;
  const T1r = Ar - Cr;
  const T1i = Ai2 - Ci2;
  const T2r = Br + Dr;
  const T2i = Bi2 + Di2;
  const T3r = inv * (Br - Dr);
  const T3i = inv * (Bi2 - Di2);
  const FAr = T0r + T2r;
  const FAi = T0i + T2i;
  const FBr = T1r + T3i;
  const FBi = T1i - T3r;
  const FCr = T0r - T2r;
  const FCi = T0i - T2i;
  const FDr = T1r - T3i;
  const FDi = T1i + T3r;
  out[outOff] = FAr;
  out[outOff + 1] = FAi;
  out[outOff + 2] = FBr;
  out[outOff + 3] = FBi;
  out[outOff + 4] = FCr;
  out[outOff + 5] = FCi;
  out[outOff + 6] = FDr;
  out[outOff + 7] = FDi;
};
FFT.prototype._realTransform4 = function _realTransform4() {
  var out = this._out;
  var size2 = this._csize;
  var width = this._width;
  var step = 1 << width;
  var len = size2 / step << 1;
  var outOff;
  var t2;
  var bitrev = this._bitrev;
  if (len === 4) {
    for (outOff = 0, t2 = 0; outOff < size2; outOff += len, t2++) {
      const off = bitrev[t2];
      this._singleRealTransform2(outOff, off >>> 1, step >>> 1);
    }
  } else {
    for (outOff = 0, t2 = 0; outOff < size2; outOff += len, t2++) {
      const off = bitrev[t2];
      this._singleRealTransform4(outOff, off >>> 1, step >>> 1);
    }
  }
  var inv = this._inv ? -1 : 1;
  var table = this.table;
  for (step >>= 2; step >= 2; step >>= 2) {
    len = size2 / step << 1;
    var halfLen = len >>> 1;
    var quarterLen = halfLen >>> 1;
    var hquarterLen = quarterLen >>> 1;
    for (outOff = 0; outOff < size2; outOff += len) {
      for (var i = 0, k2 = 0; i <= hquarterLen; i += 2, k2 += step) {
        var A2 = outOff + i;
        var B2 = A2 + quarterLen;
        var C2 = B2 + quarterLen;
        var D2 = C2 + quarterLen;
        var Ar = out[A2];
        var Ai2 = out[A2 + 1];
        var Br = out[B2];
        var Bi2 = out[B2 + 1];
        var Cr = out[C2];
        var Ci2 = out[C2 + 1];
        var Dr = out[D2];
        var Di2 = out[D2 + 1];
        var MAr = Ar;
        var MAi = Ai2;
        var tableBr = table[k2];
        var tableBi = inv * table[k2 + 1];
        var MBr = Br * tableBr - Bi2 * tableBi;
        var MBi = Br * tableBi + Bi2 * tableBr;
        var tableCr = table[2 * k2];
        var tableCi = inv * table[2 * k2 + 1];
        var MCr = Cr * tableCr - Ci2 * tableCi;
        var MCi = Cr * tableCi + Ci2 * tableCr;
        var tableDr = table[3 * k2];
        var tableDi = inv * table[3 * k2 + 1];
        var MDr = Dr * tableDr - Di2 * tableDi;
        var MDi = Dr * tableDi + Di2 * tableDr;
        var T0r = MAr + MCr;
        var T0i = MAi + MCi;
        var T1r = MAr - MCr;
        var T1i = MAi - MCi;
        var T2r = MBr + MDr;
        var T2i = MBi + MDi;
        var T3r = inv * (MBr - MDr);
        var T3i = inv * (MBi - MDi);
        var FAr = T0r + T2r;
        var FAi = T0i + T2i;
        var FBr = T1r + T3i;
        var FBi = T1i - T3r;
        out[A2] = FAr;
        out[A2 + 1] = FAi;
        out[B2] = FBr;
        out[B2 + 1] = FBi;
        if (i === 0) {
          var FCr = T0r - T2r;
          var FCi = T0i - T2i;
          out[C2] = FCr;
          out[C2 + 1] = FCi;
          continue;
        }
        if (i === hquarterLen)
          continue;
        var ST0r = T1r;
        var ST0i = -T1i;
        var ST1r = T0r;
        var ST1i = -T0i;
        var ST2r = -inv * T3i;
        var ST2i = -inv * T3r;
        var ST3r = -inv * T2i;
        var ST3i = -inv * T2r;
        var SFAr = ST0r + ST2r;
        var SFAi = ST0i + ST2i;
        var SFBr = ST1r + ST3i;
        var SFBi = ST1i - ST3r;
        var SA = outOff + quarterLen - i;
        var SB = outOff + halfLen - i;
        out[SA] = SFAr;
        out[SA + 1] = SFAi;
        out[SB] = SFBr;
        out[SB + 1] = SFBi;
      }
    }
  }
};
FFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff, off, step) {
  const out = this._out;
  const data = this._data;
  const evenR = data[off];
  const oddR = data[off + step];
  const leftR = evenR + oddR;
  const rightR = evenR - oddR;
  out[outOff] = leftR;
  out[outOff + 1] = 0;
  out[outOff + 2] = rightR;
  out[outOff + 3] = 0;
};
FFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff, off, step) {
  const out = this._out;
  const data = this._data;
  const inv = this._inv ? -1 : 1;
  const step2 = step * 2;
  const step3 = step * 3;
  const Ar = data[off];
  const Br = data[off + step];
  const Cr = data[off + step2];
  const Dr = data[off + step3];
  const T0r = Ar + Cr;
  const T1r = Ar - Cr;
  const T2r = Br + Dr;
  const T3r = inv * (Br - Dr);
  const FAr = T0r + T2r;
  const FBr = T1r;
  const FBi = -T3r;
  const FCr = T0r - T2r;
  const FDr = T1r;
  const FDi = T3r;
  out[outOff] = FAr;
  out[outOff + 1] = 0;
  out[outOff + 2] = FBr;
  out[outOff + 3] = FBi;
  out[outOff + 4] = FCr;
  out[outOff + 5] = 0;
  out[outOff + 6] = FDr;
  out[outOff + 7] = FDi;
};
const FFT$1 = /* @__PURE__ */ getDefaultExportFromCjs(fft);
function nextPowerOf2(n2) {
  return Math.pow(2, Math.ceil(Math.log2(n2)));
}
function discreteTrianglePMF(n2) {
  const x2 = [];
  const pmf = [];
  for (let k2 = -n2; k2 <= n2; k2++) {
    x2.push(k2);
    pmf.push((n2 + 1 - Math.abs(k2)) / Math.pow(n2 + 1, 2));
  }
  return [x2, pmf];
}
function sumTriangleDistributions(n2, N2) {
  if (N2 === 1) {
    const [x2, pmf2] = discreteTrianglePMF(n2);
    return [x2[0], pmf2];
  }
  const [, pmf] = discreteTrianglePMF(n2);
  const finalSupport = 2 * N2 * n2 + 1;
  const fftSize = nextPowerOf2(finalSupport);
  const fft2 = new FFT$1(fftSize);
  const paddedPMF = new Float64Array(fftSize);
  const startIdx = Math.floor((fftSize - pmf.length) / 2);
  pmf.forEach((val, idx) => {
    paddedPMF[startIdx + idx] = val;
  });
  const spectrum = fft2.createComplexArray();
  fft2.realTransform(spectrum, paddedPMF);
  for (let i = 0; i < fftSize; i++) {
    const r2 = spectrum[2 * i];
    const j = spectrum[2 * i + 1];
    const magnitude = Math.pow(Math.sqrt(r2 * r2 + j * j), N2);
    const phase = Math.atan2(j, r2) * N2;
    spectrum[2 * i] = magnitude * Math.cos(phase);
    spectrum[2 * i + 1] = magnitude * Math.sin(phase);
  }
  const output = fft2.createComplexArray();
  fft2.inverseTransform(output, spectrum);
  const resultStart = Math.floor((fftSize - finalSupport) / 2);
  const resultEnd = resultStart + finalSupport;
  const resultPDF = [];
  for (let i = resultStart; i < resultEnd; i++) {
    resultPDF.push(Math.max(0, output[2 * i]));
  }
  const sum2 = resultPDF.reduce((a, b2) => a + b2, 0);
  const normalizedPDF = resultPDF.map((p2) => p2 / sum2);
  return [-N2 * n2, normalizedPDF];
}
function turnsToSeeNoncombat(combatRate, encounters = 1) {
  const noncombatRate = 1 - (combatRate + combatRateModifier()) / 100;
  return noncombatRate > 0 ? Math.ceil(encounters / noncombatRate) : Number.POSITIVE_INFINITY;
}
function turnsToSeeSingleNoncombatCapped(combatRate, cap, progress = 0) {
  const p2 = 1 - (combatRate + combatRateModifier()) / 100;
  cap -= progress;
  if (cap <= 0 || p2 >= 1) return 1;
  if (p2 <= 0) return cap;
  return 1 / p2 * (1 - Math.pow(1 - p2, cap));
}
function turnsToSeeSingleNoncombat(location) {
  const p2 = 1 - location.combatPercent / 100;
  if (location.forceNoncombat <= 0) {
    return 1 / p2;
  }
  const progress = clamp(
    location.turnsSpent - location.lastNoncombatTurnsSpent,
    0,
    location.forceNoncombat
  );
  const cap = location.forceNoncombat + 1 - progress;
  if (cap <= 0 || p2 >= 1) return 1;
  if (p2 <= 0) return cap;
  return 1 / p2 * (1 - Math.pow(1 - p2, cap));
}
function monsterLevelWithPercent() {
  return get("Monster Level") * (1 + get("Monster Level Percent") / 100);
}
function range(m2, n2) {
  const lo = n2 === void 0 ? 0 : m2;
  const hi2 = n2 === void 0 ? m2 : n2;
  return [...Array(Math.max(0, hi2)).keys()].slice(lo);
}
function factorialQuotient(n2, k2) {
  if (!Number.isSafeInteger(n2) || n2 < 0 || !Number.isSafeInteger(k2) || k2 < 0) {
    throw new Error(
      "Can't take factorial of anything but a nonnegative integer."
    );
  }
  return n2 <= k2 ? 1 : n2 * factorialQuotient(n2 - 1, k2);
}
function factorial(n2) {
  return factorialQuotient(n2, 1);
}
function binomialCoefficient(n2, k2) {
  const hi2 = Math.max(k2, n2 - k2);
  const lo = Math.min(k2, n2 - k2);
  return factorialQuotient(n2, hi2) / factorial(lo);
}
function binomialPdf(needed, trials, p2) {
  if (needed > trials) return 0;
  p2 = clamp(p2, 0, 1);
  return binomialCoefficient(trials, needed) * Math.pow(p2, needed) * Math.pow(1 - p2, trials - needed);
}
function binomialAtLeast(needed, trials, p2) {
  return sum(range(needed, trials + 1), (n2) => binomialPdf(n2, trials, p2));
}
function bitCount(n2) {
  n2 = n2 - (n2 >> 1 & 1431655765);
  n2 = (n2 & 858993459) + (n2 >> 2 & 858993459);
  return (n2 + (n2 >> 4) & 252645135) * 16843009 >> 24;
}
function triangleCdf(n2, desired) {
  if (desired < -n2) return 0;
  if (desired >= n2) return 1;
  desired = Math.floor(desired);
  if (desired <= 0) {
    const k2 = desired + n2 + 1;
    return k2 * (k2 + 1) / 2 / Math.pow(n2 + 1, 2);
  } else {
    const k2 = n2 - desired;
    return 1 - k2 * (k2 + 1) / 2 / Math.pow(n2 + 1, 2);
  }
}
function triangleAtLeast(n2, desired) {
  return 1 - triangleCdf(n2, desired - 1);
}
function meatAtLeast(low, high, meatNeeded, meatModifier) {
  if (meatModifier === void 0) meatModifier = meatDropModifier();
  const mid = Math.round((high + low) / 2);
  const n2 = Math.round((high - low) / 2);
  return triangleAtLeast(n2, meatNeeded / (1 + meatModifier / 100) - mid);
}
function meatTurnPdf(low, high, meatNeeded, meatModifier) {
  if (meatModifier === void 0) meatModifier = meatDropModifier();
  const mid = Math.round((high + low) / 2);
  const n2 = Math.round((high - low) / 2);
  const maxTurns = Math.ceil(meatNeeded / low);
  const turnCdf = [];
  turnCdf.push(meatNeeded <= 0 ? 1 : 0);
  for (let i = 1; i <= Math.min(20, maxTurns); i++) {
    const [x2, pdf] = sumTriangleDistributions(n2, i);
    const target = meatNeeded / (1 + meatModifier / 100) - i * mid;
    const startIdx = Math.max(0, Math.ceil(target - x2));
    turnCdf.push(sumNumbers(pdf.slice(startIdx)));
  }
  const result = [];
  result.push(turnCdf[0]);
  for (let i = 1; i < turnCdf.length; i++) {
    result.push(turnCdf[i] - turnCdf[i - 1]);
  }
  return result;
}
const ForestNoncombatAdvice = () => {
  const forest = $location`The Spooky Forest`;
  const progress = Math.max(
    0,
    forest.turnsSpent - forest.lastNoncombatTurnsSpent
  );
  const expectedTurns = progress >= 7 ? 0 : 0.5 * turnsToSeeSingleNoncombatCapped(85, 8 - progress) + 0.5 * turnsToSeeSingleNoncombatCapped(85, 9 - progress);
  return progress >= 8 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "NC guaranteed next turn." }) : progress === 7 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "50% chance of guaranteed NC next turn." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
    "Expected ",
    expectedTurns.toFixed(1),
    " turns until next NC."
  ] });
};
function hiddenTempleInfo() {
  const completed = hiddenTempleUnlocked();
  const needMap = !have$b($item`Spooky Temple map`);
  const needCoin = !have$b($item`tree-holed coin`) && needMap;
  const needFertilizer = !have$b($item`Spooky-Gro fertilizer`);
  const needSapling = !have$b($item`spooky sapling`);
  const ncsNeeded = +needMap + +needCoin + +needFertilizer + +needSapling;
  return {
    completed,
    needMap,
    needCoin,
    needFertilizer,
    needSapling,
    ncsNeeded
  };
}
const HiddenTemple = () => {
  const info = hiddenTempleInfo();
  if (info.completed) return null;
  const { needMap, needCoin, needFertilizer, needSapling, ncsNeeded } = info;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Find the Hidden Temple",
      imageUrl: "/images/itemimages/map.gif",
      href: ncsNeeded === 0 ? inventoryLink($item`Spooky Temple map`) : "/woods.php",
      linkEntireTile: true,
      children: [
        needCoin && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Explore the stream  Squeeze into the cave to obtain the tree-holed coin." }),
        needMap && !needCoin && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Brave the dark thicket  Follow the coin  Insert coin to continue to obtain the Spooky Temple map." }),
        needFertilizer && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Brave the dark thicket  Investigate the dense foliage to obtain Spooky-Gro fertilizer." }),
        needSapling && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Follow the old road  Talk to the hunter  Buy a tree for 100 Meat to obtain the spooky sapling.",
          needSapling && myMeat() < 100 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { color: "red.solid", children: "You need 100 meat!" })
          ] }) : null
        ] }),
        ncsNeeded === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use your Spooky Temple map!" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ForestNoncombatAdvice, {})
      ]
    }
  );
};
const AdviceTooltipIcon = ({
  advice,
  icon: TooltipIcon = Info
}) => {
  const toolTip = /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { px: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Image,
      {
        src: "/images/itemimages/yorick.gif",
        alt: "Yorick, the Skeleton",
        boxSize: "30px",
        fit: "contain"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(VStack, { align: "stretch", gap: 0.3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { bg: "bg.muted", p: 4, color: "fg.muted", rounded: "md", fontSize: "xs", children: advice }) })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltip, { content: toolTip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { color: "gray.solid", h: 3.5, w: 3.5, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipIcon, {}) }) });
};
function isNormalCampgroundPath(path) {
  const currentPath = path ?? myPath();
  if (myBasestat($stat`Muscle`) === 0) return false;
  if ([
    "Actually Ed the Undying",
    "Nuclear Autumn",
    "You, Robot",
    "WereProfessor"
  ].includes(currentPath.name)) {
    return false;
  }
  return true;
}
function canAccessGarden(path) {
  const actual_path = myPath();
  return isNormalCampgroundPath(actual_path) && actual_path.name !== "A Shrunken Adventurer am I";
}
const Island = () => {
  const shoreScrip = availableAmount($item`Shore Inc. Ship Trip Scrip`);
  const haveCcsc = haveUnrestricted($item`candy cane sword cane`);
  const haveCcscEquipped = haveEquipped($item`candy cane sword cane`);
  const requiredTrips = haveCcsc ? 2 : 3;
  const islandUnlocked = get$1("lastIslandUnlock") === myAscensions();
  const pixels = [
    [$item`yellow pixel`, 50],
    [$item`red pixel`, 5],
    [$item`green pixel`, 5],
    [$item`blue pixel`, 5]
  ];
  const pixelsNeeded = pixels.map(
    ([item2, count]) => [item2, count - availableAmount(item2)]
  ).filter(([, count]) => count > 0);
  const takerspace = $item`TakerSpace letter of Marque`;
  const takerspaceInstalled = getWorkshed() === takerspace;
  const haveTakerspace = have$b(takerspace) && isUnrestricted(takerspace) && isNormalCampgroundPath() && !get$1("_workshedItemUsed") || takerspaceInstalled;
  const canMakePirateDinghy = !get$1("_takerSpaceSuppliesDelivered") || get$1("takerSpaceAnchor") >= 1 && get$1("takerSpaceMast") >= 1 && get$1("takerSpaceSilk") >= 1;
  if (islandUnlocked) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Unlock Mysterious Island",
      imageUrl: "/images/itemimages/dinghy.gif",
      href: !have$b($item`dinghy plans`) ? "/place.php?whichplace=desertbeach" : void 0,
      children: [
        shoreScrip < 3 && !have$b($item`dinghy plans`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Visit The Shore, Inc.",
            " ",
            plural(requiredTrips - shoreScrip, "more time"),
            " to get enough scrip for the dinghy plans."
          ] }),
          haveCcsc && !haveCcscEquipped && !get$1("candyCaneSwordShore") && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Equip your candy cane sword to get extra scrip." })
        ] }),
        shoreScrip >= 3 && !have$b($item`dinghy plans`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/shop.php?whichshop=shore", children: "Buy dinghy plans." }),
        have$b($item`dinghy plans`) && (!have$b($item`dingy planks`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "buy dingy planks", children: "Get some dingy planks to make a boat." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "use dinghy plans", children: "Use your dinghy plans to make a boat." })),
        haveTakerspace && canMakePirateDinghy && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Line,
          {
            href: !takerspaceInstalled ? inventoryLink(takerspace) : "/campground.php?action=workshed",
            children: [
              "Or ",
              !takerspaceInstalled && "install TakerSpace and ",
              " get a pirate dinghy from your TakerSpace.",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipIcon, { advice: "Uses 1 anchor, 1 mast, and 1 silk." })
            ]
          }
        ),
        (haveUnrestricted($familiar`Puck Man`) || haveUnrestricted($familiar`Ms. Puck Man`)) && (pixelsNeeded.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Or get a yellow submarine from your Puck Man. Need",
          " ",
          commaAnd(
            pixelsNeeded.map(([item2, count]) => pluralItem(item2, count))
          ),
          "."
        ] }) : !have$b($item`yellow submarine`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/place.php?whichplace=forestvillage&action=fv_mystic", children: "You have all the pixels needed. Make a yellow submarine." }) : null)
      ]
    }
  );
};
const Level1 = () => {
  const step = questStep("questM05Toot");
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: "Toot Oriole",
      imageUrl: "/images/otherimages/oriole.gif",
      href: "/tutorial.php?action=toot",
      linkEntireTile: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit the Toot Oriole." })
    }
  );
};
const Level10 = () => {
  const step = questStep("questL10Garbage");
  const airship = $location`The Penultimate Fantasy Airship`;
  const groundFloor = $location`The Castle in the Clouds in the Sky (Ground Floor)`;
  const neededItems = [
    [$item`amulet of extreme plot significance`, "a Quiet Healer"],
    [$item`model airship`, "the noncombat"]
  ];
  if (!haveUnrestricted($skill`Comprehensive Cartography`)) {
    neededItems.push([$item`Mohawk wig`, "a Burly Sidekick"]);
  }
  if (!haveUnrestricted($item`unbreakable umbrella`)) {
    neededItems.push([$item`titanium assault umbrella`, "a Spunky Princess"]);
  }
  const immateria = $items`Tissue Paper Immateria, Tin Foil Immateria, Gauze Immateria, Plastic Wrap Immateria`;
  const neededImmateria = immateria.filter((item2) => !have$b(item2));
  const needs = neededImmateria.length > 0 ? [plural(neededImmateria.length, "more immateria")] : [];
  needs.push("to find Cid");
  const delayRemaining = (have$b($item`bat wings`) ? 20 : 25) - neededImmateria.length - airship.turnsSpent;
  const needUmbrella = !have$b($item`titanium assault umbrella`) && !haveUnrestricted($item`unbreakable umbrella`);
  const needAmulet = have$b($item`amulet of extreme plot significance`);
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Stop the Giant Trash",
      imageUrl: "/images/otherimages/sigils/recyctat.gif",
      href: atStep(step, [
        [Step.UNSTARTED, "/council.php"],
        [
          Step.STARTED,
          have$b($item`enchanted bean`) ? inventoryLink($item`enchanted bean`) : "/place.php?whichplace=plains"
        ],
        [1, "/place.php?whichplace=beanstalk"],
        [7, "/place.php?whichplace=giantcastle"],
        [10, "/council.php"],
        [Step.FINISHED, void 0]
      ]),
      minLevel: 10,
      children: step === Step.UNSTARTED ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." }) : step < 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !have$b($item`enchanted bean`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Acquire an enchanted bean from the Beanbat Chamber." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Plant an enchanted bean in the nearby plains." }) }) : step < 7 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        delayRemaining > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "You need to burn ",
          delayRemaining,
          " more total delay in the Airship."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "You need ",
          commaAnd(needs),
          "."
        ] }),
        step >= 2 && airship.turnsSpent / (have$b($item`bat wings`) ? 4 : 5) >= step - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You have an NC available, maximize -combat." })
      ] }) : step < 8 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !haveEquipped($item`amulet of extreme plot significance`) && !haveEquipped($item`titanium assault umbrella`) && !haveEquipped($item`unbreakable umbrella`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", color: "red.solid", children: "Equip an umbrella or the amulet of extreme plot significance." }),
        needAmulet && !needUmbrella && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Fish (1/3) for the umbrella NC, and skip the amulet NC if you hit that instead." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Maximize -combat and adventure in the castle basement." })
      ] }) : step < 9 ? groundFloor.turnsSpent < 10 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        "Delay ",
        10 - groundFloor.turnsSpent,
        " more turns on the ground floor to unlock the Castle Top Floor."
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Unlock the Castle Top Floor next turn." }) : step < 10 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !haveEquipped($item`Mohawk wig`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", color: "red.solid", children: "Equip a Mohawk wig." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Maximize -combat and adventure in the top floor." }),
        !have$b($item`steam-powered model rocketship`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Consider getting the rocketship to access the Hole in the Sky." })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit the council to inform them of your success." })
    }
  );
};
const BlackForest = () => {
  const step = questStep("questL11Black");
  const forestProgress = get$1("blackForestProgress");
  const blackForest = $location`The Black Forest`;
  const familiar = myFamiliar();
  const haveBlackbird = have$b($familiar`Reassembled Blackbird`);
  const haveBlackbirdEquipped = familiar === $familiar`Reassembled Blackbird`;
  const haveBlackbirdHatchling = have$b($item`reassembled blackbird`);
  const haveGaloshes = have$b($item`blackberry galoshes`);
  const haveGaloshesEquipped = haveEquipped($item`blackberry galoshes`);
  const combatRate = combatRateModifier();
  const turnsUntilNC = Math.max(
    0,
    blackForest.forceNoncombat - Math.max(0, blackForest.turnsSpent - blackForest.lastNoncombatTurnsSpent)
  );
  useNag(() => {
    const possibleNags = [
      [
        haveBlackbird && !haveBlackbirdHatchling && !haveBlackbirdEquipped,
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Take your Reassembled Blackbird." })
      ],
      [
        haveBlackbirdHatchling && familiar === $familiar`Reassembled Blackbird`,
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Don't need blackbird anymore - change familiars." })
      ],
      [
        haveGaloshes && !haveGaloshesEquipped,
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Equip your blackberry galoshes." })
      ],
      [
        !haveGaloshes && blackForest.turnsSpent > 0 && turnsUntilNC > 0 && combatRate < 5,
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Ensure you have +5% combat." })
      ],
      [turnsUntilNC === 0, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Noncombat guaranteed next turn." })]
    ];
    return {
      id: "black-forest-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/documents.gif",
      node: possibleNags.every(([show]) => !show) || myLocation() !== blackForest || step >= 2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
        QuestTile,
        {
          header: "Find the Black Market",
          imageUrl: "/images/itemimages/documents.gif",
          href: "/woods.php",
          children: possibleNags.map(
            ([show, node2], index) => show && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: node2 }, index)
          )
        }
      )
    };
  }, [
    blackForest,
    combatRate,
    familiar,
    haveBlackbird,
    haveBlackbirdEquipped,
    haveBlackbirdHatchling,
    haveGaloshes,
    haveGaloshesEquipped,
    step,
    turnsUntilNC
  ]);
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: have$b($item`forged identification documents`) ? "Vacation at the Shore" : "Find the Black Market",
      id: "black-market-quest",
      imageUrl: have$b($item`forged identification documents`) ? "/images/itemimages/book2.gif" : "/images/itemimages/documents.gif",
      href: atStep(step, [
        [Step.UNSTARTED, "/council.php"],
        [Step.STARTED, "/woods.php"],
        [
          2,
          have$b($item`forged identification documents`) ? "/place.php?whichplace=desertbeach" : "/shop.php?whichshop=blackmarket"
        ],
        [3, "/adventure.php?snarfblat=355"]
      ]),
      linkEntireTile: true,
      minLevel: 11,
      children: [
        step === Step.UNSTARTED && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." }),
        step === Step.STARTED && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          blackForest.turnsSpent === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Intro NC first to get black map." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Noncombat guaranteed",
            " ",
            turnsUntilNC === 0 ? "next turn" : `in ${plural(turnsUntilNC, "turn")}`,
            "."
          ] }),
          haveGaloshes && blackForest.turnsSpent > 0 && turnsUntilNC > 0 && combatRate < 5 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Run +5% combat to avoid NC." }),
          !haveGaloshes && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            turnsUntilNC > 0 && combatRate > -25 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Run -25% combat to find NC." }),
            have$b($item`blackberry`, 3) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Bring 3 blackberries to the cobbler for blackberry galoshes." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Get",
              " ",
              plural(
                3 - availableAmount($item`blackberry`),
                $item`blackberry`
              ),
              " ",
              "from blackberry bush."
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Black Forest exploration: ~",
            forestProgress * 20,
            "%."
          ] })
        ] }),
        [1, 2].includes(step) && (have$b($item`forged identification documents`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Take a trip at The Shore, Inc." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Buy the forged identification documents for",
            " ",
            npcPrice($item`forged identification documents`),
            " meat."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Consider buying a can of black paint for desert exploration." })
        ] })),
        step === 3 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Take a trip at The Shore, Inc." })
      ]
    }
  );
};
const Copperhead = () => {
  const step = questStep("questL11Shen");
  if (step === Step.FINISHED) {
    return null;
  }
  const { locations, item: item2 } = currentSnake() ?? {};
  const copperhead = $location`The Copperhead Club`;
  const copperheadTurns = copperhead.turnsSpent;
  const shenMeetings = atStep(step, [
    [1, 1],
    [3, 2],
    [5, 3]
  ]) ?? 0;
  const turnsUntilMeeting = shenMeetings * 5 - copperheadTurns;
  const remainingDelay2 = 14 - (3 - shenMeetings) - copperheadTurns;
  const disguised = have$b($effect`Crappily Disguised as a Waiter`);
  const couldUseDisguise = !disguised && have$b($item`crappy waiter disguise`) && myPath() !== $path`Two Crazy Random Summer`;
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Beat Shen Copperhead",
      minLevel: 11,
      imageUrl: "/images/itemimages/scharm2.gif",
      imageAlt: "Shen Copperhead",
      disabled: !questFinished("questL11Black"),
      children: atStep(step, [
        [
          Step.STARTED,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink(copperhead), children: "Go meet Shen in the Copperhead Club." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "If you meet him today, you will have to go to",
              " ",
              commaList(
                (SHEN_DAYS[(myDaycount() - 1) % SHEN_DAYS.length] ?? []).map(
                  (snake) => snake.locations[0].identifierString
                ),
                "and"
              ),
              "."
            ] })
          ] })
        ],
        [
          1,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            item2 && !have$b(Item.get(item2)) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Line,
              {
                href: locations ? parentPlaceLink(locations[0]) : void 0,
                children: [
                  "Adventure in",
                  " ",
                  locations == null ? void 0 : locations.map((l2) => l2.identifierString).join(" or "),
                  " to find",
                  " ",
                  item2,
                  "."
                ]
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: parentPlaceLink(copperhead), children: [
              "Return ",
              item2,
              " to Shen",
              turnsUntilMeeting > 0 && ` in ${plural(turnsUntilMeeting - 0.5, "turn")}`,
              "."
            ] }),
            copperheadTurns < 14 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(MainLink, { href: parentPlaceLink(copperhead), children: [
                !item2 || !have$b(Item.get(item2)) ? "Or work on burning" : "Still need to burn",
                " ",
                plural(remainingDelay2, "turn"),
                " of delay in the Copperhead Club."
              ] }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipIcon, { advice: "This delay count does not include the meetings with Shen." })
            ] }),
            turnsUntilMeeting === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Line,
              {
                href: couldUseDisguise ? inventoryLink($item`crappy waiter disguise`) : parentPlaceLink(copperhead),
                children: [
                  "50% chance of meeting Shen this turn.",
                  shenMeetings === 3 && couldUseDisguise && "Use a crappy waiter disguise for 25% chance of a turn saved."
                ]
              }
            ),
            turnsUntilMeeting <= 0 && (!item2 || have$b(Item.get(item2))) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: parentPlaceLink(copperhead), children: [
              "Meet Shen next turn",
              " ",
              shenMeetings === 3 ? "(last meeting)" : `(meeting ${shenMeetings + 1})`,
              "."
            ] })
          ] })
        ]
      ])
    }
  );
};
function currentExplorationPerTurn() {
  let exploration = 1;
  if (haveEquipped($item`ornate dowsing rod`)) {
    exploration += 2;
  }
  if (haveEquipped($item`UV-resistant compass`)) {
    exploration += 1;
  }
  if (myPath() === $path`License to Adventure` && get$1("bondDesert")) {
    exploration += 2;
  }
  if (myPath() === $path`Avatar of Sneaky Pete` && get$1("peteMotorbikeHeadlight") === "Blacklight Bulb") {
    exploration += 2;
  }
  if (haveEquipped($item`survival knife`) && have$b($effect`Ultrahydrated`)) {
    exploration += 2;
  }
  if (myFamiliar() === $familiar`Melodramedary`) {
    exploration += 1;
  }
  return exploration;
}
function possibleExplorationPerTurn() {
  let exploration = 1;
  if (have$b($item`ornate dowsing rod`)) {
    exploration += 2;
  }
  if (have$b($item`UV-resistant compass`) && (!have$b($item`ornate dowsing rod`) || haveUnrestricted($familiar`Left-Hand Man`))) {
    exploration += 1;
  }
  if (myPath() === $path`License to Adventure` && get$1("bondDesert")) {
    exploration += 2;
  }
  if (myPath() === $path`Avatar of Sneaky Pete` && get$1("peteMotorbikeHeadlight") === "Blacklight Bulb") {
    exploration += 2;
  }
  if (have$b($item`survival knife`)) {
    exploration += 2;
  }
  if (haveUnrestricted($familiar`Melodramedary`) && canEquip($familiar`Melodramedary`)) {
    exploration += 1;
  }
  return exploration;
}
function needStoneRose() {
  return !(get$1("gnasirProgress") & 1);
}
function needBlackPaint() {
  return !(get$1("gnasirProgress") & 2);
}
function needKillingJar() {
  return !(get$1("gnasirProgress") & 4);
}
function needManualPages() {
  return !(get$1("gnasirProgress") & 8);
}
function needWormRiding() {
  return !(get$1("gnasirProgress") & 16);
}
const BEACH_URL = "/place.php?whichplace=desertbeach";
const GNASIR_URL = "/place.php?whichplace=desertbeach&action=db_gnasir";
const Desert = () => {
  const step = questStep("questL11Desert");
  const desertExploration = get$1("desertExploration");
  const currentExploration = currentExplorationPerTurn();
  const possibleExploration = possibleExplorationPerTurn();
  const explorationItems = $items`UV-resistant compass, ornate dowsing rod, survival knife`;
  const explorationItemsToEquip = explorationItems.filter(
    (item2) => have$b(item2) && !haveEquipped(item2)
  );
  const melodramedary = $familiar`Melodramedary`;
  const haveMelodramedary = have$b(melodramedary);
  const usingMelodramedary = myFamiliar() === melodramedary;
  const needMoreExploration = currentExploration < possibleExploration;
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Explore the Desert",
      imageUrl: "/images/adventureimages/sandcactus.gif",
      imageAlt: "Desert",
      href: BEACH_URL,
      minLevel: 11,
      disabled: !questFinished("questL11Black"),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: BEACH_URL, children: [
          100 - desertExploration,
          "% exploration remaining."
        ] }),
        desertExploration < 10 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: BEACH_URL, children: [
          "Find Gnasir after",
          " ",
          Math.ceil((10 - desertExploration) / currentExploration),
          " turns."
        ] }),
        needStoneRose() && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: BEACH_URL, children: [
          have$b($item`stone rose`) && desertExploration >= 10 && "Give stone rose to Gnasir (15%).",
          !have$b($item`stone rose`) && "Adventure in Oasis for stone rose (15%)."
        ] }),
        needBlackPaint() && desertExploration >= 10 && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: have$b($item`can of black paint`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: GNASIR_URL, children: "Give can of black paint to Gnasir (15%)." }) : npcPrice($item`can of black paint`) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: BLACK_MARKET_URL, children: "Buy can of black paint from Black Market and give to Gnasir (15%)." }) }),
        needKillingJar() && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          have$b($item`killing jar`) && desertExploration >= 10 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: GNASIR_URL, children: "Give killing jar to Gnasir (15%)." }),
          !have$b($item`killing jar`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink($location`The Haunted Library`), children: "Find killing jar (10% drop from banshee librarian) (15%)." })
        ] }),
        needManualPages() && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: availableAmount($item`worm-riding manual page`) >= 15 ? "Give worm-riding manual pages to Gnasir." : `${have$b($effect`Ultrahydrated`) ? "Find" : "Get Ultrahydrated to find"} ${plural(15 - availableAmount($item`worm-riding manual page`), "more worm-riding manual page")}.` }),
        needWormRiding() && have$b($item`worm-riding hooks`) && (have$b($item`Apriling band quad tom`) && get$1("_aprilBandTomUses") < 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`Apriling band quad tom`), children: "Use Apriling quad tom to worm-ride (30%)." }) : have$b($item`drum machine`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`drum machine`), children: "Use drum machine to worm-ride (30%)." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Get",
          " ",
          commaOr([
            canAdventure($location`The Oasis`) && "drum machine from blur in the Oasis",
            canAdventure($location`The Oasis`) && have$b($item`cursed monkey's paw`) && get$1("_monkeyPawWishesUsed") < 5 && "drum machine from Monkey wish",
            have$b($item`Apriling band helmet`) && get$1("_aprilBandInstruments") < 2 && "Apriling band quad tom"
          ]),
          " ",
          "to worm-ride (30%)."
        ] })),
        !have$b($item`UV-resistant compass`) && (have$b($item`Shore Inc. Ship Trip Scrip`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Trade your Shore scrip for a UV-resistant compass." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Consider spending 3 turns at the shore for a UV-resistant compass." })),
        explorationItemsToEquip.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Equip",
          " ",
          commaAnd(
            explorationItemsToEquip.map((item2) => /* @__PURE__ */ jsxRuntimeExports.jsx(AsyncLink, { command: `equip ${item2.name}`, children: item2.name })),
            explorationItemsToEquip.map((item2) => item2.name)
          ),
          " ",
          "to speed up exploration",
          explorationItemsToEquip.includes($item`survival knife`) && !have$b($effect`Ultrahydrated`) && " (need Ultrahydrated for knife)",
          "."
        ] }),
        haveMelodramedary && !usingMelodramedary && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { takeFamiliar: $familiar`Melodramedary`, children: "Consider using Melodramedary for faster exploration." }),
        have$b($item`desert sightseeing pamphlet`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`desert sightseeing pamphlet`), children: [
          "Use your",
          " ",
          plural(
            availableAmount($item`desert sightseeing pamphlet`),
            "desert sightseeing pamphlet"
          ),
          " ",
          "for +15% exploration each."
        ] }),
        needMoreExploration && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Optimize your gear for ",
          possibleExploration,
          "% (current",
          " ",
          currentExploration,
          "%) exploration per turn."
        ] })
      ]
    }
  );
};
const CITY_LINK = "/place.php?whichplace=hiddencity";
const TAVERN_LINK = "/shop.php?whichshop=hiddentavern";
function tavernUnlocked() {
  return get$1("hiddenTavernUnlock") >= myAscensions();
}
function lianasFought(location) {
  return myPath() === $path`Avant Guard` ? location.turnsSpent / 2 : location.turnsSpent;
}
const Unlock = ({ shrine, location }) => {
  const lianasLeft = 3 - lianasFought(shrine);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: CITY_LINK, children: [
    "Unlock ",
    location.identifierString,
    " (",
    lianasLeft <= 0 ? "no" : lianasLeft,
    " ",
    "lianas left)."
  ] });
};
const Machete = () => {
  const hiddenPark = $location`The Hidden Park`;
  const delayRemaining = Math.max(0, 6 - hiddenPark.turnsSpent);
  const canadiaSign = canAdventure($location`Outskirts of Camp Logging Camp`);
  const janitorsRelocated = get$1("relocatePygmyJanitor") === myAscensions();
  const doneWithCursedPunch = get$1("hiddenApartmentProgress") >= 7 || have$b($effect`Thrice-Cursed`) || have$b($item`candy cane sword cane`) && !get$1("candyCaneSwordApartmentBuilding") && have$b($effect`Twice-Cursed`);
  const doneWithBowlOfScorpions = availableAmount($item`bowling ball`) + get$1("hiddenBowlingAlleyProgress") >= 6;
  const needBookOfMatches = get$1("hiddenTavernUnlock") < myAscensions() && !have$b($item`book of matches`) && !(doneWithCursedPunch && doneWithBowlOfScorpions);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink(hiddenPark), children: "Find a machete, maybe in the Hidden Park." }),
    delayRemaining > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      plural(delayRemaining, "turn"),
      " of delay for antique machete."
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Antique machete next turn." }),
    janitorsRelocated ? needBookOfMatches && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Find a book of matches from a pygmy janitor while you're there",
      numericModifier("Item Drop") < 400 ? " (need +400% item)" : "",
      "."
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Find NC to relocate janitors while you're there." }),
    canadiaSign && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink($location`Outskirts of Camp Logging Camp`), children: "Or find forest tears from Lucky! or a forest spirit in the Outskirts of Camp Logging Camp, for a muculent machete." })
  ] });
};
const Apartment = () => {
  const step = questStep("questL11Curses");
  const curses = have$b($effect`Once-Cursed`) ? 1 : have$b($effect`Twice-Cursed`) ? 2 : have$b($effect`Thrice-Cursed`) ? 3 : 0;
  const haveCcsc = have$b($item`candy cane sword cane`);
  const ccscEquipped = haveEquipped($item`candy cane sword cane`);
  const cursesNeeded = (haveCcsc ? 2 : 3) - curses;
  const mustEquipCcsc = haveCcsc && !ccscEquipped && curses === 2;
  const apartment = $location`The Hidden Apartment Building`;
  const apartmentTurns = apartment.turnsSpent;
  const nextElevator = apartment.forceNoncombat + apartment.lastNoncombatTurnsSpent;
  const apartmentReady = apartmentTurns === nextElevator || get$1("noncombatForcerActive");
  if (step === Step.FINISHED) return null;
  return atStep(step, [
    [
      Step.UNSTARTED,
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Unlock,
        {
          shrine: $location`An Overgrown Shrine (Northwest)`,
          location: apartment
        }
      )
    ],
    [
      Step.STARTED,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, fontWeight: "bold", children: "Hidden Apartment Building" }),
        cursesNeeded > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Get cursed ",
          plural(cursesNeeded, "more time"),
          ", from",
          " ",
          tavernUnlocked() ? /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: "/shop.php?whichshop=hiddentavern", children: "Cursed Punch" }) : "Cursed Punch (unlock tavern)",
          " ",
          "or ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: CITY_LINK, children: "finding pygmy shamans." })
        ] }),
        apartmentReady ? cursesNeeded <= 0 ? mustEquipCcsc ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`candy cane sword cane`), children: "Equip the candy cane sword cane and adventure in the Apartment Building." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, children: "Ready for Apartment boss! Adventure in the Apartment Building." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, color: "red.solid", children: "Apartment NC next turn! Try to get Thrice-Cursed first." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: CITY_LINK, children: [
          "Burn ",
          nextElevator - apartmentTurns,
          " turns of delay in the Apartment Building."
        ] })
      ] })
    ],
    [7, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, children: "Return the sphere to the NW shrine." })]
  ]) ?? null;
};
const Office = () => {
  const haveClip = have$b($item`boring binder clip`) || have$b($item`McClusky file (complete)`);
  const needToUseClip = have$b($item`boring binder clip`) && have$b($item`McClusky file (page 5)`);
  const files = [
    $item`McClusky file (page 1)`,
    $item`McClusky file (page 2)`,
    $item`McClusky file (page 3)`,
    $item`McClusky file (page 4)`,
    $item`McClusky file (page 5)`
  ];
  const neededFiles = have$b($item`McClusky file (complete)`) ? 0 : files.filter((file) => !have$b(file)).length;
  const office = $location`The Hidden Office Building`;
  const nextHoliday = office.forceNoncombat + office.lastNoncombatTurnsSpent;
  const officeReady = office.turnsSpent === nextHoliday || get$1("noncombatForcerActive");
  return atStep(get$1("hiddenOfficeProgress"), [
    [
      0,
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Unlock,
        {
          shrine: $location`An Overgrown Shrine (Northeast)`,
          location: office
        }
      )
    ],
    [
      1,
      /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: CITY_LINK, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: 0.5, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", children: "Hidden Office Building" }),
        needToUseClip ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Line,
          {
            href: inventoryLink($item`boring binder clip`),
            fontWeight: "bold",
            color: "red.solid",
            children: "Use the boring binder clip to complete the McClusky file."
          }
        ) : neededFiles > 0 || !haveClip ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Find",
          " ",
          commaAnd([
            neededFiles > 0 && `${plural(neededFiles, "more McClusky file")} from pygmy
              accountants`,
            !haveClip && "the boring binder clip from the NC"
          ]),
          "."
        ] }) : null,
        officeReady ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "red.solid", children: [
          "Office NC ",
          get$1("noncombatForcerActive") ? "(forced) " : "",
          "next turn!"
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Burn ",
          nextHoliday - office.turnsSpent,
          " turns of delay in the Office Building."
        ] })
      ] }) })
    ],
    [7, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, children: "Return the sphere to the NE shrine." })],
    [8, null]
  ]) ?? null;
};
const BowlingAlley = () => {
  const bowlingProgress = get$1("hiddenBowlingAlleyProgress");
  const scorchedStoneSphere = $item`scorched stone sphere`;
  const bowlingBall = $item`bowling ball`;
  const bowlOfScorpions = $item`Bowl of Scorpions`;
  const candyCaneSwordCane = $item`candy cane sword cane`;
  if (bowlingProgress >= 8) return null;
  const numberOfRollsLeft = 6 - bowlingProgress;
  const haveCcsc = have$b(candyCaneSwordCane);
  const ccscEquipped = haveEquipped(candyCaneSwordCane);
  const canSkipRoll = haveCcsc && !get$1("candyCaneSwordBowlingAlley");
  const bowlsNeeded = Math.max(0, numberOfRollsLeft - (canSkipRoll ? 1 : 0));
  const bowlingBallsNeeded = Math.max(
    0,
    bowlsNeeded - availableAmount(bowlingBall)
  );
  return bowlingProgress === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Unlock,
    {
      shrine: $location`An Overgrown Shrine (Southeast)`,
      location: $location`The Hidden Bowling Alley`
    }
  ) : bowlingProgress === 7 && have$b(scorchedStoneSphere) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, children: "Place scorched stone sphere in SE shrine." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, fontWeight: "bold", children: "Hidden Bowling Alley" }),
    haveCcsc && canSkipRoll && !ccscEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(candyCaneSwordCane), fontWeight: "bold", children: "Equip the candy cane sword cane to skip a roll." }),
    bowlingBallsNeeded > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: CITY_LINK, children: [
      "Find ",
      plural(bowlingBallsNeeded, "more bowling ball"),
      " by fighting pygmy bowlers."
    ] }),
    numberOfRollsLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: CITY_LINK, children: [
      "Adventure ",
      plural(bowlsNeeded, "more time"),
      " with bowling balls to fight spirit",
      canSkipRoll ? " (after skipping one roll with CCSC)" : "",
      "."
    ] }),
    tavernUnlocked() ? !get$1("banishedMonsters").includes("drunk pygmy") ? !have$b(bowlOfScorpions) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: TAVERN_LINK, fontWeight: "bold", color: "red.solid", children: "Buy Bowl of Scorpions from the Hidden Tavern to free run." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Use ",
      pluralItem(bowlOfScorpions),
      " on drunk pygmy for free run."
    ] }) : null : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "gray.solid", children: "Unlock the Hidden Tavern for free runs from drunk pygmies." })
  ] });
};
const Hospital = () => {
  const hospitalProgress = get$1("hiddenHospitalProgress");
  const drippingStoneSphere = $item`dripping stone sphere`;
  if (hospitalProgress >= 8) return null;
  const equippableOutfitPieces = [
    $item`bloodied surgical dungarees`,
    $item`surgical mask`,
    $item`head mirror`,
    $item`half-size scalpel`,
    $item`surgical apron`
  ].filter((item2) => canEquip(item2));
  const ownedOutfitPieces = equippableOutfitPieces.filter((item2) => have$b(item2));
  const unequippedOutfitPieces = ownedOutfitPieces.filter(
    (item2) => !haveEquipped(item2)
  );
  const numberOfEquippedPieces = ownedOutfitPieces.length - unequippedOutfitPieces.length;
  const hospital = $location`The Hidden Hospital`;
  return hospitalProgress === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Unlock,
    {
      shrine: $location`An Overgrown Shrine (Southwest)`,
      location: hospital
    }
  ) : hospitalProgress === 7 && have$b(drippingStoneSphere) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, children: "Place dripping stone sphere in SW shrine." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, fontWeight: "bold", children: "Hidden Hospital" }),
    unequippedOutfitPieces.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Line,
      {
        command: `equip ${unequippedOutfitPieces[0].name}`,
        fontWeight: "bold",
        color: "red.solid",
        children: [
          "Equip your ",
          commaAnd(unequippedOutfitPieces),
          " first."
        ]
      }
    ),
    ownedOutfitPieces.length < equippableOutfitPieces.length && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Fight pygmy surgeons to get surgeon gear:" }),
      equippableOutfitPieces.filter((item2) => availableAmount(item2) === 0).map((item2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { ml: 2, children: [
        " ",
        item2.name
      ] }, item2.name)),
      have$b($skill`Transcendent Olfaction`) && get$1("_olfactionsUsed") < 3 && get$1("olfactedMonster") !== $monster`pygmy witch surgeon` && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Olfact pygmy witch surgeon." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      numberOfEquippedPieces * 10,
      "% chance to fight spirit."
    ] }),
    hospital.turnsSpent >= 8 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "gray.solid", children: [
      "Alternatively, burn ",
      31 - hospital.turnsSpent,
      " more turns."
    ] })
  ] });
};
const Ziggurat = () => {
  const stoneTriangle = $item`stone triangle`;
  const atLastSpirit = availableAmount(stoneTriangle) === 4;
  const spheresAvailable = availableAmount($item`moss-covered stone sphere`) + availableAmount($item`dripping stone sphere`) + availableAmount($item`crackling stone sphere`) + availableAmount($item`scorched stone sphere`);
  const massiveZiggurat = $location`A Massive Ziggurat`;
  return lianasFought(massiveZiggurat) < 3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Unlock, { shrine: massiveZiggurat, location: massiveZiggurat }) : !atLastSpirit ? null : spheresAvailable > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, children: "Acquire stone triangles from shrines." }) : myPath() === $path`Actually Ed the Undying` ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, children: "Talk to the protector spectre." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CITY_LINK, children: "Fight the protector spectre!" });
};
const HiddenCity = () => {
  const step = questStep("questL11Worship");
  const ascensions = myAscensions();
  const lastTempleAdventures = get$1("lastTempleAdventures");
  const stoneFacedTurns = haveEffect($effect`Stone-Faced`);
  useNag(
    () => ({
      id: "stone-faced-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/stonewool.gif",
      node: stoneFacedTurns > 0 && (lastTempleAdventures < ascensions || step < Step.FINISHED) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        QuestTile,
        {
          header: "You Are Stone-Faced",
          imageUrl: "/images/itemimages/stonewool.gif",
          imageAlt: "stone wool",
          href: "/woods.php",
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Adventure in the Hidden Temple in the next ",
            stoneFacedTurns,
            " ",
            "turns."
          ] })
        }
      )
    }),
    [ascensions, lastTempleAdventures, step, stoneFacedTurns]
  );
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Secret of the Hidden City",
      minLevel: 11,
      imageUrl: "/images/adventureimages/ziggurat.gif",
      imageAlt: "Hidden City",
      href: step < 2 ? "/woods.php" : "/place.php?whichplace=hiddencity",
      disabled: !canAdventure($location`The Hidden Temple`) || !questFinished("questL11Black"),
      children: atStep(step, [
        [
          Step.STARTED,
          /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Find the Hidden Temple." }) })
        ],
        [
          1,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            stoneFacedTurns === 0 && (!have$b($item`stone wool`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Find some stone wool or otherwise get Stone-Faced." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`stone wool`), children: "Use your stone wool and go to the Hidden Temple." })),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink($location`The Hidden Temple`), children: !have$b($item`the Nostril of the Serpent`) ? "Find the Nostril of the Serpent." : "Find the pikachu door in the Hidden Heart." })
          ] })
        ],
        [
          2,
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You ain't no hollaback girl. B-A-N-A-N-A-S. Let it all burn." })
        ],
        [
          3,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            get$1("hiddenTavernUnlock") < myAscensions() && have$b($item`book of matches`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "use book of matches", children: "Use your book of matches to unlock the Hidden Tavern." }),
            !haveMachete() && lianasCanBeFree() ? /* @__PURE__ */ jsxRuntimeExports.jsx(Machete, {}) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Apartment, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Office, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(BowlingAlley, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Hospital, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Ziggurat, {})
            ] })
          ] })
        ]
      ])
    }
  );
};
const CELLAR_LINK = "/place.php?whichplace=manor4";
const LordSpookyraven = () => {
  const step = questStep("questL11Manor");
  const isPathBoris = myPath() === $path`Avatar of Boris`;
  const isPathActuallyEdTheUndying = myPath() === $path`Actually Ed the Undying`;
  const isPathNuclearAutumn = myPath() === $path`Nuclear Autumn`;
  const isPathVampire = myPath() === $path`Dark Gyffte`;
  const isInHardcore = inHardcore();
  const isInBadMoon = getProperty("moonTuned") === "true" && getProperty("charpanemode") === "badmoon";
  const canEquipAnyWeapon = canEquip($item`seal-clubbing club`);
  const useFastRoute = canEquipAnyWeapon && !(isPathNuclearAutumn && isInHardcore) && !isPathBoris && !isInBadMoon;
  const hauntedBallroomAvailable = canAdventure(
    $location`The Haunted Ballroom`
  );
  const delayRemaining = 5 - $location`The Haunted Ballroom`.turnsSpent;
  const haveSpectacles = have$b($item`Lord Spookyraven's spectacles`);
  const recipeWillBeAutoread = haveSpectacles && useFastRoute && get$1("autoCraft");
  const recipeWasReadWithGlasses = get$1("spookyravenRecipeUsed") === "with_glasses";
  const recipeWasRead = recipeWasReadWithGlasses || get$1("spookyravenRecipeUsed") === "no_glasses";
  const haveWineBomb = have$b($item`wine bomb`);
  const haveUnstableFulminate = have$b($item`unstable fulminate`);
  const haveUnstableFulminateEquipped = haveEquipped($item`unstable fulminate`);
  const haveChateauDeVinegar = have$b($item`bottle of Chateau de Vinegar`);
  const haveBlastingSoda = have$b($item`blasting soda`);
  const currentMl = numericModifier("Monster Level");
  const mlNeeded = 82 - currentMl;
  const searchables = {
    "The Haunted Kitchen": $item`loosening powder`,
    "The Haunted Conservatory": $item`powdered castoreum`,
    "The Haunted Bathroom": $item`drain dissolver`,
    "The Haunted Gallery": $item`triple-distilled turpentine`,
    "The Haunted Laboratory": $item`detartrated anhydrous sublicalc`,
    "The Haunted Storage Room": $item`triatomaceous dust`
  };
  const missingSearchables = Object.entries(searchables).filter(
    ([, item2]) => !have$b(item2)
  );
  const inBoilerRoom = myLocation() === $location`The Haunted Boiler Room`;
  useNag(
    () => ({
      id: "lord-spookyraven-quest-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/wine2.gif",
      node: step < Step.FINISHED && inBoilerRoom && haveUnstableFulminate && (!haveUnstableFulminateEquipped || mlNeeded > 0) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Make a wine bomb",
          imageUrl: "/images/itemimages/wine2.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Line,
            {
              href: inventoryLink($item`unstable fulminate`),
              color: "red.solid",
              children: !haveUnstableFulminateEquipped && mlNeeded > 0 ? `Equip unstable fulminate and get ${Math.ceil(mlNeeded)} more ML.` : !haveUnstableFulminateEquipped ? "Equip unstable fulminate." : `Get ${Math.ceil(mlNeeded)} more ML.`
            }
          )
        }
      )
    }),
    [
      haveUnstableFulminate,
      haveUnstableFulminateEquipped,
      inBoilerRoom,
      mlNeeded,
      step
    ]
  );
  if (step === Step.FINISHED) return null;
  const boilerFights = Math.ceil(
    50.1 / (10 + Math.floor(Math.max(currentMl, 0) / 2))
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: missingSearchables.length === 0 || haveWineBomb || step === 3 ? "Fight Lord Spookyraven" : "Find Lord Spookyraven",
      id: "lord-spookyraven-quest",
      imageUrl: "/images/adventureimages/lordspooky.gif",
      href: step < 1 || useFastRoute && !haveSpectacles && !recipeWasReadWithGlasses ? "/place.php?whichplace=manor2" : CELLAR_LINK,
      minLevel: 11,
      disabled: !hauntedBallroomAvailable,
      children: [
        step < 1 && (questFinished("questL11Black") ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: parentPlaceLink($location`The Haunted Ballroom`), children: [
          "Run -combat in the Haunted Ballroom.",
          delayRemaining > 0 && ` Delay for ${plural(delayRemaining, "turn")}.`
        ] }) }) : delayRemaining > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Pre-burn ",
          plural(delayRemaining, "turn"),
          " of delay in the Haunted Ballroom."
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "All delay burned. Find your dad's diary." })),
        step === 1 && (useFastRoute && !haveSpectacles && !recipeWasReadWithGlasses ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink($location`The Haunted Bedroom`), children: "Acquire Lord Spookyraven's spectacles from the Haunted Bedroom." }) : recipeWillBeAutoread ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CELLAR_LINK, children: "Click on the suspicious masonry in the basement." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CELLAR_LINK, children: "Click on the suspicious masonry in the basement, then read the recipe." })),
        step === 2 && !haveUnstableFulminate && !haveWineBomb && useFastRoute && (!recipeWasReadWithGlasses ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: parentPlaceLink($location`The Haunted Bedroom`), children: [
          "Need to",
          " ",
          !haveSpectacles && "acquire Lord Spookyraven's spectacles and ",
          "read the recipe before you can use the quick route."
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          !haveChateauDeVinegar && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CELLAR_LINK, children: "Find bottle of Chateau de Vinegar from possessed wine rack in the Haunted Wine Cellar." }),
          !haveBlastingSoda && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CELLAR_LINK, children: "Find blasting soda from the cabinet in the Haunted Laundry Room." }),
          haveChateauDeVinegar && haveBlastingSoda && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/craft.php?mode=cook", children: "Cook unstable fulminate." })
        ] })),
        step === 2 && !useFastRoute && (!recipeWasRead ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`recipe: mortar-dissolving solution`), children: "Read the recipe." }) : missingSearchables.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Go search in the Haunted",
          " ",
          commaOr(
            missingSearchables.map(([location]) => /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: parentPlaceLink(Location.get(location)), children: 'location.replace("The Haunted ", "")' })),
            missingSearchables.map(([location]) => location)
          ),
          "."
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CELLAR_LINK, children: "Use your mortar-dissolving ingredients to clear out the masonry." })),
        haveUnstableFulminate && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: CELLAR_LINK, children: [
            "Adventure in the haunted boiler room",
            mlNeeded > 0 && ` with +${mlNeeded} ML`,
            "."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: CELLAR_LINK, children: [
            boilerFights > 1 ? `~${boilerFights}` : boilerFights,
            " total boiler fights to charge fulminate."
          ] })
        ] }),
        haveWineBomb && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CELLAR_LINK, children: "Use the wine bomb to clear out the masonry." }),
        step === 3 && (isPathActuallyEdTheUndying ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CELLAR_LINK, children: "Talk to Lord Spookyraven." }) : isPathVampire ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CELLAR_LINK, children: "Fight the path-specific boss." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: CELLAR_LINK, children: "Fight Lord Spookyraven." }),
          !have$b($effect`Red Door Syndrome`) && myMeat() > 1e3 && !haveUnrestricted($item`can of black paint`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/shop.php?whichshop=blackmarket", children: [
            "A can of black paint can help with fighting him.",
            myMeat() < 2e4 && " Bit pricy. (1k meat)"
          ] })
        ] }))
      ]
    }
  );
};
const PALINDOME_URL = "/place.php?whichplace=palindome";
const WHITEYS_GROVE_URL = "/place.php?whichplace=woods";
const Level11Palindome = () => {
  const step = questStep("questL11Palindome");
  const talisman = $item`Talisman o' Namsilat`;
  const megaGem = $item`Mega Gem`;
  const canStart = have$b(talisman) || have$b($item`Copperhead Charm`) && have$b($item`Copperhead Charm (rampant)`);
  const talismanEquipped = haveEquipped($item`Talisman o' Namsilat`);
  const palindomeLink = talismanEquipped ? PALINDOME_URL : void 0;
  const neededNcPhotos = ["a red nugget", "an ostrich egg", "God"].filter(
    (item2) => !have$b($item`photograph of ${item2}`)
  );
  const needInstantCamera = !have$b($item`photograph of a dog`) && !have$b($item`disposable instant camera`) && step <= Step.STARTED && !have$b($item`"2 Love Me, Vol. 2"`);
  const drAwkwardOfficeUnlocked = step > Step.STARTED || get$1("palindomeDudesDefeated", 0) >= 5;
  const neededStewIngredients = $items`bird rib, lion oil`.filter(
    (item2) => !have$b(item2)
  );
  const haveOrCanMakeWetStew = have$b($item`wet stew`) || neededStewIngredients.length === 0;
  const haveOrCanMakeWetStuntNutStew = haveOrCanMakeWetStew && have$b($item`stunt nuts`);
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Palindome",
      href: talismanEquipped ? palindomeLink : void 0,
      imageUrl: "/images/adventureimages/drawkward.gif",
      minLevel: 11,
      disabled: !canStart,
      children: [
        step >= Step.STARTED && !talismanEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(talisman), children: "Equip the Talisman o' Nam!" }),
        atStep(step, [
          [
            Step.UNSTARTED,
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/craft.php?mode=combine", children: `"Paste the two copperhead charms together to acquire the Talisman o' Nam."` })
          ],
          [
            Step.STARTED,
            /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              needInstantCamera && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink($location`The Haunted Bedroom`), children: "Acquire a disposable instant camera from the haunted bedroom first." }),
              !have$b($item`photograph of a dog`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: palindomeLink, children: "Photograph Bob Racecar or Racecar Bob with disposable instant camera." }),
              !have$b($item`stunt nuts`) && !have$b($item`wet stunt nut stew`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: palindomeLink, children: "Possibly acquire stunt nuts from Bob Racecar or Racecar Bob (30% drop)." }),
              neededNcPhotos.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: palindomeLink, children: [
                "Find ",
                pluralJustDesc(neededNcPhotos.length, "photograph"),
                " of",
                " ",
                commaAnd(neededNcPhotos),
                " from non-combats."
              ] }),
              !drAwkwardOfficeUnlocked && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: palindomeLink, children: [
                "Defeat",
                " ",
                plural(5 - get$1("palindomeDudesDefeated", 0), "more dude"),
                " in the palindome."
              ] }),
              have$b($item`photograph of a dog`) && (have$b($item`stunt nuts`) || have$b($item`wet stunt nut stew`)) && neededNcPhotos.length === 0 && drAwkwardOfficeUnlocked && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MainLink,
                  {
                    href: inventoryLink($item`[7262]"I Love Me, Vol. I"`),
                    children: "Use I Love Me, Vol. I."
                  }
                ),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: palindomeLink, children: "Then place the photographs in Dr. Awkward's Office." })
              ] })
            ] })
          ],
          [
            1,
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`"2 Love Me, Vol. 2"`), children: "Use 2 Love Me, Vol. 2, then talk to Mr. Alarm in his office." })
          ],
          [2, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: palindomeLink, children: "Talk to Mr. Alarm in his office." })],
          [
            3,
            /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              !haveOrCanMakeWetStuntNutStew && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: WHITEYS_GROVE_URL, children: "Acquire and make wet stunt nut stew:" }),
              !have$b($item`stunt nuts`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: palindomeLink, children: "Acquire stunt nuts from Bob Racecar or Racecar Bob in Palindome. (30% drop)" }),
              !have$b($item`wet stew`) && (neededStewIngredients.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: WHITEYS_GROVE_URL, children: [
                "Adventure in Whitey's Grove to acquire",
                " ",
                commaAnd(neededStewIngredients),
                ".",
                numericModifier("Item Drop") + numericModifier("Food Drop") < 300 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  " ",
                  "Need +",
                  (301 - numericModifier("Food Drop") - numericModifier("Item Drop")).toFixed(0),
                  "% food drop."
                ] })
              ] }) : have$b($item`stunt nuts`) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Line,
                {
                  command: freeCrafts("food") > 0 ? "make wet stunt nut stew" : void 0,
                  href: "/craft.php?mode=cook",
                  children: "Cook wet stunt nut stew."
                }
              ))
            ] })
          ],
          [
            4,
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: palindomeLink, children: "Talk to Mr. Alarm with the wet stunt nut stew." })
          ],
          [
            5,
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Line,
              {
                href: haveEquipped(megaGem) ? palindomeLink : inventoryLink(megaGem),
                children: [
                  !haveEquipped(megaGem) ? "Equip the Mega Gem, then fight " : "Fight ",
                  "Dr. Awkward in his office."
                ]
              }
            )
          ]
        ])
      ]
    }
  );
};
function spinStatus() {
  const pyramidPosition = get$1("pyramidPosition");
  let nextPositionNeeded = -1;
  let additionalTurnsAfterThat = 0;
  let task = "";
  if (questFinished("questL11Pyramid")) {
    nextPositionNeeded = pyramidPosition;
    additionalTurnsAfterThat = 0;
    task = "";
  } else if (have$b($item`ancient bomb`) || get$1("pyramidBombUsed")) {
    nextPositionNeeded = 1;
    additionalTurnsAfterThat = 0;
    task = `fight Ed in the lower chambers`;
  } else if (have$b($item`ancient bronze token`)) {
    nextPositionNeeded = 3;
    additionalTurnsAfterThat = 3;
    task = `acquire ancient bomb in lower chamber`;
  } else {
    nextPositionNeeded = 4;
    additionalTurnsAfterThat = 3 + 4;
    task = "acquire token in lower chamber";
  }
  const spinsNeeded = (nextPositionNeeded - pyramidPosition + 10) % 5;
  const totalSpinsNeeded = spinsNeeded + additionalTurnsAfterThat;
  const spinsAvailable = availableAmount($item`tomb ratchet`) + availableAmount($item`crumbling wooden wheel`);
  const extraSpinsNeeded = Math.max(0, totalSpinsNeeded - spinsAvailable);
  return { extraSpinsNeeded, task, spinsNeeded };
}
const PYRAMID_URL = "/place.php?whichplace=pyramid";
const UpperChamber = () => {
  const upperChamberTurns = $location`The Upper Chamber`.turnsSpent;
  const turnsRemaining = Math.max(0, 6 - upperChamberTurns);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
    "Adventure in the Upper Chamber for ",
    plural(turnsRemaining, "more turn"),
    " ",
    "to unlock the Middle Chamber. Use -combat and free run skills if available."
  ] });
};
const MiddleChamber = ({ extraSpinsNeeded }) => {
  const middleChamberTurns = $location`The Middle Chamber`.turnsSpent;
  const turnsRemaining = Math.max(0, 11 - middleChamberTurns);
  const tangles = availableAmount($item`tangle of rat tails`);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Adventure in the Middle Chamber for",
      " ",
      plural(turnsRemaining, "more turn"),
      " to unlock the Control Room. Use free runs if available.",
      " "
    ] }),
    extraSpinsNeeded > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Use +400% item drop and olfact tomb rats to get ratchets.",
      tangles > 0 && ` Use ${plural(tangles, "tangle")} of rat tails on tomb rats.`
    ] })
  ] });
};
const ControlRoom = ({
  task,
  spinsNeeded,
  extraSpinsNeeded
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
  spinsNeeded > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
    "Spin the pyramid ",
    spinsNeeded,
    " time",
    spinsNeeded !== 1 ? "s" : "",
    ", then",
    " ",
    task,
    "."
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
    capitalize(task),
    "."
  ] }),
  extraSpinsNeeded > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
    "Need",
    " ",
    `${plural(extraSpinsNeeded, "more ratchet")}/${pluralJustDesc(extraSpinsNeeded, "wheel")}`,
    ". Adventure in the Middle Chamber (+400% item) or Upper Chamber (-combat) to acquire them."
  ] })
] });
const Pyramid = () => {
  const step = questStep("questL11Pyramid");
  if (questFinished("questL11MacGuffin")) return null;
  const haveHeadpiece = have$b($item`[2180]ancient amulet`) && have$b($item`[2286]Eye of Ed`) || have$b($item`headpiece of the Staff of Ed`);
  const haveStaffOfEd = have$b($item`[2325]Staff of Ed`) || haveHeadpiece && have$b($item`[2268]Staff of Fats`);
  const upperChamberTurns = $location`The Upper Chamber`.turnsSpent;
  const middleChamberTurns = $location`The Middle Chamber`.turnsSpent;
  const { task, spinsNeeded, extraSpinsNeeded } = spinStatus();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Descend the Pyramid",
      imageUrl: "/images/itemimages/nemes.gif",
      href: atStep(step, [
        [
          Step.UNSTARTED,
          "/place.php?whichplace=desertbeach&action=db_pyramid1"
        ],
        [Step.STARTED, PYRAMID_URL],
        [Step.FINISHED, "/council.php"]
      ]),
      linkEntireTile: true,
      minLevel: 11,
      disabled: !haveStaffOfEd && step < Step.STARTED,
      children: atStep(step, [
        [
          Step.UNSTARTED,
          !haveStaffOfEd ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Find the Staff of Ed before starting the Pyramid." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit the Pyramid to start the quest." })
        ],
        [
          Step.STARTED,
          upperChamberTurns < 6 ? /* @__PURE__ */ jsxRuntimeExports.jsx(UpperChamber, { extraSpinsNeeded }) : middleChamberTurns < 11 ? /* @__PURE__ */ jsxRuntimeExports.jsx(MiddleChamber, { extraSpinsNeeded }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            ControlRoom,
            {
              task,
              spinsNeeded,
              extraSpinsNeeded
            }
          )
        ],
        [
          Step.FINISHED,
          questStep("questL11MacGuffin") === 2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Return the Holy MacGuffin to the Council!" })
        ]
      ])
    }
  );
};
const ZeppelinMob = () => {
  const candyCaneSwordCane = $item`candy cane sword cane`;
  const haveCcsc = haveUnrestricted(candyCaneSwordCane);
  const sleazeProtestorsCleared = Math.max(
    3,
    Math.sqrt(
      numericModifier("sleaze damage") + numericModifier("sleaze spell damage")
    )
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    have$b($item`lynyrd musk`) && !have$b($effect`Musky`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red", href: "/inventory.php?ftext=lynyrd+musk", children: "Use lynyrd musk." }),
    have$b($item`lynyrd snare`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/inventory.php?ftext=lynyrd+snare", children: "Possibly use lynyrd snare. (free combat)" }),
    get$1("zeppelinProtestors") >= 80 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Finished. Adventure in the mob of protestors." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      haveCcsc && !haveEquipped(candyCaneSwordCane) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "equip candy cane sword cane", children: "Equip your candy cane sword cane!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        80 - get$1("zeppelinProtestors"),
        " protestors left."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        "Sleaze damage will clear ",
        sleazeProtestorsCleared.toFixed(1),
        " ",
        "protestors",
        haveCcsc && ` (doubled to ${(sleazeProtestorsCleared * 2).toFixed(1)} with CCSC)`,
        "."
      ] })
    ] })
  ] });
};
const ZeppelinShip = () => {
  const remaining = clamp(6 - get$1("zeppelinProgress"), 0, 6);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !have$b($item`Red Zeppelin ticket`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red", href: "/shop.php?whichshop=blackmarket", children: "Purchase a red zeppelin ticket in the black market." }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Search for Ron in the Zeppelin. Defeat",
      " ",
      plural(remaining, "more monster"),
      "."
    ] }),
    myPath() !== $path`Avant Guard` && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      have$b($item`glark cable`) && "Use glark cable in combat. ",
      get$1("_glarkCableUses"),
      "/5 glark cables used. (free kills)"
    ] })
  ] });
};
const getTooltip = (step) => {
  let tooltip;
  switch (step) {
    case 1:
      tooltip = "-combat, 567% item, sleaze dmg, sleaze spell dmg. Could adventure in the Copperhead Club first for Flamin' Whatshisnames";
      break;
    case 2:
      tooltip = "+234% item, banish Red Herring, banish Red Snapper";
      break;
  }
  return tooltip;
};
const Zeppelin = () => {
  const step = questStep("questL11Ron");
  const tooltip = getTooltip(step);
  const Component = atStep(step, [
    [Step.STARTED, ZeppelinMob],
    [2, ZeppelinShip],
    [4, () => /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Defeat Ron in the zeppelin." })]
  ]) ?? (() => null);
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Find Ron Copperhead",
      minLevel: 11,
      imageUrl: "/images/itemimages/scharm.gif",
      href: "/place.php?whichplace=zeppelin",
      tooltip: tooltip && /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipIcon, { advice: tooltip }),
      disabled: !questFinished("questL11Black"),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, {})
    }
  );
};
const Level11 = () => {
  if (questFinished("questL11MacGuffin")) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(BlackForest, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HiddenCity, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LordSpookyraven, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Copperhead, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Zeppelin, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Level11Palindome, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Desert, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Pyramid, {})
  ] });
};
const Arena = ({ disabled }) => {
  const currentPath = myPath();
  const flyeredML = get$1("flyeredML");
  const percentDone = Math.min(flyeredML / 1e4 * 100, 100);
  const mlRemaining = 1e4 - flyeredML;
  const jamBandFlyers = $item`jam band flyers`;
  const rockBandFlyers = $item`rock band flyers`;
  const haveFlyers = have$b(rockBandFlyers) || have$b(jamBandFlyers);
  const flyers = have$b(rockBandFlyers) ? rockBandFlyers : jamBandFlyers;
  if (currentPath === $path`G-Lover` || currentPath === $path`Pocket Familiars`) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Island War Arena",
      imageUrl: "/images/adventureimages/promoboard.gif",
      href: "/bigisland.php",
      disabled,
      children: flyeredML >= 1e4 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Turn in quest." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !haveFlyers && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Acquire flyers." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          percentDone.toFixed(1),
          "% ML completed, ",
          mlRemaining,
          " ML remains."
        ] }),
        mlRemaining > 0 && haveFlyers && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Flyer with ",
          flyers.name,
          " every combat."
        ] })
      ] })
    }
  );
};
const Farm = () => {
  const barn = $location`McMillicancuddy's Barn`;
  const knownNCs = [
    "Cornered!",
    "Cornered Again!",
    "How Many Corners Does this Stupid Barn Have!?"
  ];
  const seenNCs = (barn.noncombatQueue ?? "").split(",");
  const ncsSeen = knownNCs.filter((nc2) => seenNCs.includes(nc2)).length;
  const chaosButterfly = have$b($item`chaos butterfly`);
  const chaosButterflyThrown = get$1("chaosButterflyThrown");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Island War Farm",
      imageUrl: "/images/otherimages/bigisland/farmer.gif",
      href: "/bigisland.php?place=farm",
      children: [
        (ncsSeen < 3 || myLocation() === barn) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          !chaosButterflyThrown && chaosButterfly && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use a chaos butterfly in combat before clearing the barn." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Remember to:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Make a fence out of the barbed wire" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Knock over the lantern" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Dump out the drum" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use free runs and wanderers to burn 10-15 (?) turns of delay in the barn." })
      ]
    }
  );
};
const LOCATION_DATA = [
  {
    location: $location`Next to that Barrel with Something Burning in it`,
    shorthand: "Barrel",
    item: "molybdenum hammer"
  },
  {
    location: $location`Near an Abandoned Refrigerator`,
    shorthand: "Refrigerator",
    item: "molybdenum pliers"
  },
  {
    location: $location`Over Where the Old Tires Are`,
    shorthand: "Tires",
    item: "molybdenum crescent wrench"
  },
  {
    location: $location`Out by that Rusted-Out Car`,
    shorthand: "Car",
    item: "molybdenum screwdriver"
  }
];
const MonsterText = ({ monster, isBanished: isBanished2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: isBanished2 ? "fg.subtle" : void 0, children: monster });
function gremlinShortName(monster) {
  const name = monster.name;
  return `${name.includes("(tool)") ? "tool " : ""}${name.split(" ")[0]}`;
}
const Junkyard = () => {
  const getStasisAdvice = () => {
    if (have$b($item`dictionary`)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Read from the dictionary to stasis gremlins." });
    } else if (have$b($item`facsimile dictionary`)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Read from the facsimile dictionary to stasis gremlins." });
    } else if (have$b($item`seal tooth`)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use your seal tooth to stasis gremlins." });
    } else if (have$b($skill`Suckerpunch`)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Cast suckerpunch to stasis gremlins." });
    } else if (myPath() !== $path`Zombie Slayer`) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "coinmaster buy hermit seal tooth", children: "Acquire a seal tooth (from hermit) to stasis gremlins." });
    } else if (have$b($item`beehive`)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use your beehive to stasis gremlins." });
    }
    return null;
  };
  const haveAllItems = LOCATION_DATA.every(
    (location) => have$b($item`${location.item}`)
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Island War Junkyard",
      imageUrl: "/images/itemimages/magnet2.gif",
      href: "/bigisland.php?place=junkyard",
      children: !have$b($item`molybdenum magnet`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Talk to Yossarian first." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: haveAllItems ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Talk to Yossarian to complete quest." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        getStasisAdvice(),
        LOCATION_DATA.filter(({ item: item2 }) => !have$b($item`${item2}`)).map(
          ({ location, shorthand }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "strong", children: shorthand }),
            ":",
            " ",
            commaSeparate(
              getMonsters(location).map((monster) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                MonsterText,
                {
                  monster: gremlinShortName(monster),
                  isBanished: isBanished(monster)
                }
              )),
              getMonsters(location).map((monster) => monster.id)
            )
          ] }, location.id)
        ),
        !isBanished($monster`A.M.C. gremlin`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Potentially banish A.M.C. Gremlin." })
      ] }) })
    }
  );
};
const Lighthouse = () => {
  const sonofaBeach = $location`Sonofa Beach`;
  const lighthouseFinished = get$1("lighthouseQuestState") === "finished";
  const gunpowderCount = availableAmount($item`barrel of gunpowder`);
  const gunpowderNeeded = Math.max(0, 5 - gunpowderCount);
  const combatRate = combatRateModifier();
  const effectiveCombatRate = 11 / 12 * Math.max(0.1 + combatRate / 100, 0) + 1 / 12;
  const turnsPerLobster = effectiveCombatRate !== 0 ? 1 / effectiveCombatRate : -1;
  const turnsToComplete = gunpowderNeeded * turnsPerLobster;
  const canUseMacrometeorite = have$b($skill`Macrometeorite`) && get$1("_macrometeoriteUses") < 10;
  const canUseReplaceEnemy = have$b($item`Powerful Glove`) && 100 - get$1("_powerfulGloveBatteryPowerUsed") >= 10;
  const switchOptions = truthy([
    have$b($item`Powerful Glove`) && $skill`CHEAT CODE: Replace Enemy`,
    have$b($skill`Macrometeorite`) && $skill`Macrometeorite`
  ]);
  const sabersOwned = availableAmount($item`Fourth of May Cosplay Saber`) + availableAmount($item`replica Fourth of May Cosplay Saber`);
  const canUseSaber = sabersOwned > 0 && get$1("_saberForceUses") < 5 && gunpowderNeeded > 1;
  if (lighthouseFinished) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Island War Lighthouse",
      imageUrl: "/images/adventureimages/lobsterman.gif",
      href: "/bigisland.php?place=lighthouse",
      children: gunpowderNeeded > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Need ",
          plural(gunpowderNeeded, "more barrel", "more barrels"),
          " of gunpowder."
        ] }),
        have$6() && currentlyIn() === sonofaBeach && zoneItems() + gunpowderCount >= 5 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Autumn-aton will finish quest. Wait",
          " ",
          plural(turnsLeft(), "turn"),
          "."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "~",
          turnsToComplete.toFixed(1),
          " turns to complete quest at",
          " ",
          Math.floor(combatRate),
          "% combat. ",
          turnsPerLobster.toFixed(1),
          " turns per lobster."
        ] }),
        have$6() && currentlyIn() !== sonofaBeach && (sonofaBeach.turnsSpent > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Send autumn-aton in ",
          plural(turnsLeft(), "turn"),
          " for",
          " ",
          plural(zoneItems(), "barrel"),
          " per send."
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Spend a turn (maybe wanderer) in Sonofa Beach, then send autumn-aton." })),
        (canUseReplaceEnemy || canUseMacrometeorite) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Could use ",
            commaOr(switchOptions),
            " on a wanderer to guarantee an LFM."
          ] }),
          canUseReplaceEnemy && !haveEquipped($item`Powerful Glove`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Equip the Powerful Glove, first." })
        ] }),
        canUseSaber && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Could Use the Force (friends) on a LFM to guarantee two more." }),
          !have$b($item`Fourth of May Cosplay Saber`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Equip the Fourth of May saber, first." })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Talk to the lighthouse keeper to finish quest." })
    }
  );
};
function turnRangeString(range2) {
  return range2.low === range2.high ? `${plural(range2.low, "turn")} remaining` : `[${range2.low} to ${range2.high}] turns remaining`;
}
function getPotentialPulls(meatRemaining) {
  if (pullsRemaining() > 0 && meatDropModifier() < 1e3) {
    const limit = meatDropModifier() < 800 ? 50 : 100;
    const averageTurnsCurrently = meatRemaining / ((meatDropModifier() / 100 + 1) * 1e3);
    const possible = [
      $item`frost flower`,
      $item`Mick's IcyVapoHotness Inhaler`,
      $item`sorority brain`,
      $item`tempura cauliflower`,
      $item`bottle of Greedy Dog`,
      $item`The Inquisitor's unidentifiable object`,
      $item`jumping horseradish`,
      $item`sea truffle`,
      $item`dirt julep`,
      $item`Daily Affirmation: Always be Collecting`,
      $item`beggin' cologne`,
      $item`battery (car)`,
      $item`Boris's bread`,
      $item`lodestone`,
      $item`flapper fly`
    ];
    return possible.filter((item2) => isUnrestricted(item2) && !have$b(item2)).map((item2) => {
      const effect2 = effectModifier(item2, "Effect");
      const meatDroppedPerTurnWithItem = ((meatDropModifier() + numericModifier(effect2, "Meat Drop")) / 100 + 1) * 1e3;
      const turnsSaved = averageTurnsCurrently - meatRemaining / meatDroppedPerTurnWithItem;
      if (turnsSaved < 1) return null;
      return `${item2.name} (${Math.round(numericModifier(effect2, "Meat Drop"))}%, ${turnsSaved.toFixed(1)} turns saved)`;
    }).filter((x2) => x2).slice(0, limit);
  }
  return [];
}
const Nuns = ({ disabled }) => {
  const currentPath = myPath();
  const meatGotten = get$1("currentNunneryMeat");
  const meatRemaining = 1e5 - meatGotten;
  const meatModifier = meatDropModifier() + (+haveEquipped($item`Everfull Dart Holster`) && 55);
  const meatDropMultiplier = 1 + meatModifier / 100;
  const brigandMeatDropRange = {
    low: 800 * meatDropMultiplier,
    high: 1200 * meatDropMultiplier
  };
  const turnRange = {
    low: Math.ceil(meatRemaining / brigandMeatDropRange.high),
    high: Math.ceil(meatRemaining / brigandMeatDropRange.low)
  };
  const singTurnRange = {
    low: Math.ceil(meatRemaining / (brigandMeatDropRange.high + 25)),
    high: Math.ceil(meatRemaining / (brigandMeatDropRange.low + 25))
  };
  const potentialPulls = getPotentialPulls(meatRemaining);
  const songReady = have$7() && song() === "Total Eclipse of Your Meat";
  const turnPdf = reactExports.useMemo(
    () => turnRange.high <= 20 ? meatTurnPdf(
      songReady ? 825 : 800,
      songReady ? 1225 : 1200,
      meatRemaining,
      meatModifier
    ) : [],
    [turnRange.high, songReady, meatRemaining, meatModifier]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Island War Nuns",
      imageUrl: "/images/adventureimages/bandit.gif",
      href: "/bigisland.php?place=nunnery",
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          meatRemaining,
          " meat remaining."
        ] }),
        have$7() && (song() === "Total Eclipse of Your Meat" || songChangesLeft() > 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          song() !== "Total Eclipse of Your Meat" && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Change BoomBox song to Total Eclipse of Your Meat." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Be sure to Sing Along with your BoomBox every turn." }),
          (singTurnRange.high !== turnRange.high || singTurnRange.low !== turnRange.low) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            turnRangeString(singTurnRange),
            ", if you sing."
          ] })
        ] }),
        haveEquipped($item`Everfull Dart Holster`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Throw a dart at its torso each turn." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          turnRangeString(turnRange),
          "."
        ] }),
        turnRange.high <= 20 && turnPdf.slice(1).map(
          (p2, i) => p2 > 1e-3 && p2 < 0.999 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            (p2 * 100).toFixed(0),
            "% chance of completing in",
            " ",
            plural(i + 1, "turn"),
            "."
          ] }, i)
        ),
        have$b($item`Rufus's shadow lodestone`) && !have$b($effect`Shadow Waters`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/plains.php", fontWeight: "bold", children: "Go to a shadow rift for Shadow Waters!" }),
        !have$b($item`ice nine`) && availableAmount($item`ice harvest`) >= 9 && !have$b($item`miracle whip`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Possibly make and equip an ice nine. (+30% meat 1h weapon)" }),
        !have$b($effect`Sinuses For Miles`) && have$b($item`stone wool`) && get$1("lastTempleAdventures") < myAscensions() && hiddenTempleUnlocked() && turnRange.high > haveEffect($effect`Sinuses For Miles`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Potentially use stone wool and visit the hidden temple to extend Sinuses for Miles for 3 turns." }),
        currentPath === $path`Heavy Rains` && have$b($skill`Make it Rain`) && turnRange.high > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Cast Make it Rain each fight. (+300%? meat)" }),
        have$b($item`Sneaky Pete's leather jacket (collar popped)`) && turnRange.high > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Could unpop your collar. (+20% meat)" }),
        potentialPulls.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Could try pulling ",
          potentialPulls.join(", "),
          "."
        ] })
      ]
    }
  );
};
const ORCHARD_URL = "/bigisland.php?place=orchard";
const GlandAdvice = () => {
  const currentLocation = myLocation();
  if (currentLocation.toString().includes("filthworm")) {
    const effectiveItemDrop = itemDropModifier() / 100;
    const averageGlandsFoundPerCombat = Math.min(
      1,
      (effectiveItemDrop + 1) * 0.1
    );
    const turnsPerGland = averageGlandsFoundPerCombat !== 0 ? 1 / averageGlandsFoundPerCombat : -1;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "~",
      turnsPerGland.toFixed(1),
      " turns per gland."
    ] });
  }
  return null;
};
const PickpocketAdvice = () => {
  const totalInitiativeNeeded = $monster`filthworm drone`.baseInitiative;
  const initiativeNeeded = totalInitiativeNeeded - initiativeModifier();
  const sources = [$familiar`XO Skeleton`, $skill`Perpetrate Mild Evil`];
  if (sources.some((s) => have$b(s))) {
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Use",
      " ",
      commaAnd(sources.filter((s) => have$b(s)).map((s) => s.identifierString)),
      "to pickpocket."
    ] });
  }
  if (myPrimestat() === $stat`Moxie` && initiativeNeeded > 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Need ",
      initiativeNeeded,
      "% more initiative to pickpocket every turn."
    ] });
  }
  return null;
};
const Orchard = () => {
  const heartOfFilthwormQueen = $item`heart of the filthworm queen`;
  const guardGland = $item`filthworm royal guard scent gland`;
  const guardStench = $effect`Filthworm Guard Stench`;
  const droneGland = $item`filthworm drone scent gland`;
  const droneStench = $effect`Filthworm Drone Stench`;
  const larvaGland = $item`filthworm hatchling scent gland`;
  const larvaStench = $effect`Filthworm Larva Stench`;
  const mainAdvice = () => {
    if (have$b(heartOfFilthwormQueen)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: ORCHARD_URL, children: "Go talk to the hippies to complete quest." });
    } else if (have$b(guardStench) || have$b(guardGland)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !have$b(guardStench) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(guardGland), children: "Use filthworm royal guard scent gland." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: have$b(guardStench) ? ORCHARD_URL : void 0, children: "Defeat the filthworm queen in the queen's chamber." })
      ] });
    } else if (have$b(droneStench) || have$b(droneGland)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !have$b(droneStench) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(droneGland), children: "Use filthworm drone scent gland." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: have$b(droneStench) ? ORCHARD_URL : void 0, children: "Filthworms! Adventure with +item in the guards' chamber." })
      ] });
    } else if (have$b(larvaStench) || have$b(larvaGland)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !have$b(larvaStench) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(larvaGland), children: "Use filthworm hatchling scent gland." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: have$b(larvaStench) ? ORCHARD_URL : void 0, children: "Filthworms! Adventure with +item in the feeding chamber." })
      ] });
    } else {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: ORCHARD_URL, children: "Filthworms! Adventure with +item in the hatching chamber." });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Island War Orchard",
      imageUrl: "/images/itemimages/scentgland.gif",
      children: [
        mainAdvice(),
        /* @__PURE__ */ jsxRuntimeExports.jsx(GlandAdvice, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(PickpocketAdvice, {})
      ]
    }
  );
};
const ISLAND_PREWAR_URL = "/island.php";
const ISLAND_WAR_URL = "/bigisland.php";
function pluralEnemyCount(count, description, side) {
  return plural(
    count,
    `${description ? `${description} ` : ""}${side}`,
    `${description ? `${description} ` : ""}${side === "frat boy" ? "frat boys" : "hippies"}`
  );
}
const Level12 = () => {
  const islandUnlocked = get$1("lastIslandUnlock") === myAscensions();
  if (!islandUnlocked) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      QuestTile,
      {
        header: myLevel() < 12 ? "End the Island War (level 12)" : "End the Island War (unlock island)",
        id: "island-war-quest",
        imageUrl: "/images/itemimages/fmedbeta.gif",
        disabled: true
      }
    );
  }
  const ccsc = $item`candy cane sword cane`;
  const haveCcsc = have$b(ccsc);
  const ccscEquipped = haveEquipped(ccsc);
  const step = questStep("questL12War");
  const hippiesDefeated = get$1("hippiesDefeated");
  const fratboysDefeated = get$1("fratboysDefeated");
  const outfits = ["War Hippy Fatigues", "Frat Warrior Fatigues"];
  const haveHippyFatigues = haveOutfit("War Hippy Fatigues");
  const hippyFatiguesEquipped = isWearingOutfit("War Hippy Fatigues");
  const haveFratFatigues = haveOutfit("Frat Warrior Fatigues");
  const fratFatiguesEquipped = isWearingOutfit("Frat Warrior Fatigues");
  const sideQuestNames = [
    "Lighthouse",
    "Junkyard",
    "Arena",
    "Orchard",
    "Nuns",
    "Farm"
  ];
  const sideQuests = sideQuestNames.map((name) => `sidequest${name}Completed`);
  const remainingSidequestNames = sideQuestNames.filter(
    (name) => get$1(`sidequest${name}Completed`) === "none"
  );
  const completedHippyQuests = sideQuests.filter(
    (quest) => get$1(quest) === "hippy"
  ).length;
  const completedFratQuests = sideQuests.filter(
    (quest) => get$1(quest) === "fratboy"
  ).length;
  const hippiesLeft = 1e3 - hippiesDefeated;
  const fratboysLeft = 1e3 - fratboysDefeated;
  const mySide = (() => {
    if (completedFratQuests > 0) return "frat boy";
    if (completedHippyQuests > 0) return "hippy";
    if (haveFratFatigues) return "frat boy";
    if (haveHippyFatigues) return "hippy";
    return hippiesLeft > fratboysLeft ? "hippy" : "frat boy";
  })();
  const otherSide = mySide === "hippy" ? "frat boy" : "hippy";
  const completedMySideQuests = mySide === "hippy" ? completedHippyQuests : completedFratQuests;
  const otherSideLeft = mySide === "hippy" ? fratboysLeft : hippiesLeft;
  const otherSideDefeated = 1e3 - otherSideLeft;
  const defeatedPerCombat = 1 << completedMySideQuests;
  const thresholds = [64, 192, 458, 1e3];
  const nextThreshold = thresholds.findIndex((threshold) => otherSideDefeated < threshold) ?? 3;
  const enemiesToThreshold = thresholds[nextThreshold] - otherSideDefeated;
  const turnsToThreshold = Math.ceil(enemiesToThreshold / defeatedPerCombat);
  const nextQuest = nextThreshold === 3 ? null : mySide === "hippy" ? sideQuestNames[3 - nextThreshold] : sideQuestNames[3 + nextThreshold];
  const openQuests = mySide === "hippy" ? sideQuestNames.slice(3 - nextThreshold) : sideQuestNames.slice(0, 3 + nextThreshold);
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      QuestTile,
      {
        header: "End the Island War",
        id: "island-war-quest",
        imageUrl: "/images/itemimages/fmedbeta.gif",
        href: atStep(step, [
          [Step.UNSTARTED, "/council.php"],
          [Step.STARTED, ISLAND_PREWAR_URL],
          [1, ISLAND_WAR_URL]
        ]),
        linkEntireTile: step === Step.UNSTARTED || step === 1,
        minLevel: 12,
        children: atStep(step, [
          [Step.UNSTARTED, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit the Council to start the quest." })],
          [
            Step.STARTED,
            /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              haveCcsc && !ccscEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "fg.error", command: "equip candy cane sword cane", children: "Equip your candy cane sword cane first!" }),
              !haveHippyFatigues && !haveFratFatigues ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Acquire either war hippy fatigues or frat warrior fatigues." }) : !hippyFatiguesEquipped && !fratFatiguesEquipped ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "fg.error", children: [
                "Equip the",
                " ",
                commaOr(
                  outfits.map(
                    (outfit) => haveOutfit(outfit) && /* @__PURE__ */ jsxRuntimeExports.jsx(AsyncLink, { command: `outfit ${outfit}`, children: outfit })
                  ),
                  outfits
                ),
                "."
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                hippyFatiguesEquipped ? "War Hippy Fatigues equipped." : "Frat Warrior Fatigues equipped.",
                " ",
                "Start the war!"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Run -combat and adventure in the enemy camp." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                turnsToSeeNoncombat(85, haveCcsc ? 1 : 3).toFixed(1),
                " turns expected."
              ] })
            ] })
          ],
          [
            1,
            otherSideDefeated < 1e3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                "Defeat ",
                pluralEnemyCount(otherSideLeft, "more", otherSide),
                ". (",
                plural(Math.ceil(otherSideLeft / defeatedPerCombat), "turn"),
                " ",
                "remaining)."
              ] }),
              remainingSidequestNames.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                  "Quests to complete: ",
                  remainingSidequestNames.join(", "),
                  "."
                ] }),
                nextQuest && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                  plural(turnsToThreshold, "turn"),
                  " (",
                  pluralEnemyCount(enemiesToThreshold, null, otherSide),
                  ")",
                  " ",
                  "until ",
                  nextQuest,
                  " opens."
                ] })
              ] })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Defeat the",
              " ",
              hippiesLeft <= 0 ? "Big Wisniewski in the Hippy Camp!" : "Man in the Frat House!"
            ] })
          ]
        ])
      }
    ),
    step === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      get$1("sidequestArenaCompleted") === "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(Arena, { disabled: !openQuests.includes("Arena") }),
      get$1("sidequestJunkyardCompleted") === "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(Junkyard, {}),
      get$1("sidequestLighthouseCompleted") === "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(Lighthouse, {}),
      get$1("sidequestOrchardCompleted") === "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(Orchard, {}),
      get$1("sidequestNunsCompleted") === "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(Nuns, { disabled: !openQuests.includes("Nuns") }),
      get$1("sidequestFarmCompleted") === "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(Farm, {})
    ] })
  ] });
};
const OTHER_QUESTS = [
  "questM05Toot",
  "questL02Larva",
  "questL03Rat",
  "questL04Bat",
  "questL05Goblin",
  "questL06Friar",
  "questL07Cyrptic",
  "questL08Trapper",
  "questL09Topping",
  "questL10Garbage",
  "questL11MacGuffin",
  "questL12War"
];
const elements = ["hot", "cold", "spooky", "stench", "sleaze"];
function isElement(name) {
  return elements.includes(name);
}
const telescope3Map = {
  "creepy-looking black bushes on the outskirts of a hedge maze": "spooky",
  "nasty-looking, dripping green bushes on the outskirts of a hedge maze": "stench",
  "purplish, greasy-looking hedges": "sleaze",
  "smoldering bushes on the outskirts of a hedge maze": "hot",
  "frost-rimed bushes on the outskirts of a hedge maze": "cold"
};
const telescope4Map = {
  "a greasy purple cloud hanging over the center of the maze": "sleaze",
  "smoke rising from deeper within the maze": "hot",
  "a miasma of eldritch vapors rising from deeper within the maze": "spooky",
  "a cloud of green gas hovering over the maze": "stench",
  "wintry mists rising from deeper within the maze": "cold"
};
const telescope5Map = {
  "occasionally disgorging a bunch of ice cubes": "cold",
  "that occasionally vomits out a greasy ball of hair": "sleaze",
  "surrounded by creepy black mist": "spooky",
  "disgorging a really surprising amount of sewage": "stench",
  "with lava slowly oozing out of it": "hot"
};
const Race = ({ name, contestants, value, needed, percent }) => contestants !== 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
  isElement(name) ? /* @__PURE__ */ jsxRuntimeExports.jsx(ElementName, { element: name, children: capitalize(name) }) : capitalize(name),
  " ",
  "Race:",
  " ",
  contestants < 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Text,
      {
        as: "span",
        color: value >= needed ? "fg.success" : "fg.error",
        fontWeight: value >= needed ? void 0 : "bold",
        children: [
          value.toFixed(0),
          "/",
          needed,
          percent && "%"
        ]
      }
    ),
    "."
  ] }),
  contestants > 0 && `${plural(contestants, "contestant")} left.`
] });
const NSTOWER_URL = "/place.php?whichplace=nstower";
function damageEffects() {
  return $effects`Jalapeo Saucesphere, Scarysauce, Spiky Shell, Psalm of Pointiness`;
}
function damageItems() {
  return $items`Hand in Glove, bottle opener belt buckle, Buddy Bjorn, smirking shrunken head, Kremlin's Greatest Briefcase, tiny bowler`;
}
const Level13 = () => {
  var _a2, _b2;
  const step = questStep("questL13Final");
  const inActuallyEdTheUndying = myPath() === $path`Actually Ed the Undying`;
  if (step === Step.UNSTARTED && inActuallyEdTheUndying) {
    return null;
  }
  const statRaceType = get$1("nsChallenge1");
  const statRaceModifier = statRaceType == null ? void 0 : statRaceType.identifierString;
  const elementalDamageRaceType = capitalize(get$1("nsChallenge2"));
  const pastRaces = step >= 4;
  const pastHedgeMaze = step >= 5;
  const pastKeys = step >= 6;
  const pastTowerLevel1 = step >= 7;
  const pastTowerLevel2 = step >= 8;
  const pastTowerLevel3 = step >= 9;
  const pastTowerLevel4 = step >= 10;
  const pastTowerLevel5 = step >= 11;
  const kingWaitingToBeFreed = step >= 13;
  const keysUsed = get$1("nsTowerDoorKeysUsed").split(",");
  if (!pastRaces) {
    const potions = $items`tomato juice of powerful power, philter of phorce, ointment of the occult, serum of sarcasm`;
    const availablePotions = potions.filter(
      (potion2) => Object.entries(getIngredients(potion2)).every(
        ([name, count]) => have$b(Item.get(name), count)
      ) && statRaceModifier && statRaceType && (get(statRaceModifier, potion2) > 0 || get(
        `${statRaceType.identifierString} Percent`
      ) > 0)
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      QuestTile,
      {
        header: "Find the Naughty Sorceress",
        id: "level-13-quest",
        href: NSTOWER_URL,
        linkEntireTile: true,
        imageUrl: "/images/adventureimages/regdesk.gif",
        minLevel: 13,
        disabled: OTHER_QUESTS.some((quest) => !questFinished(quest)),
        children: [
          step <= 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            step === Step.STARTED && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Register for the races at the registration desk." }),
            step === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Defeat the race contestants at the base of the tower." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Race,
              {
                name: "Initiative",
                contestants: get$1("nsContestants1"),
                value: get("Initiative"),
                needed: 400,
                percent: true
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Race,
              {
                name: statRaceModifier ?? "Elemental",
                contestants: get$1("nsContestants2"),
                value: statRaceType ? myBuffedstat(statRaceType) : 0,
                needed: 600
              }
            ),
            statRaceModifier && get$1("nsContestants3") < 0 && get(statRaceModifier) < 600 && availablePotions.length > 0 && freeCrafts("food") > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Could make ",
              commaOr(availablePotions),
              " to boost",
              " ",
              statRaceModifier,
              "."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Race,
              {
                name: elementalDamageRaceType || "Stat",
                contestants: get$1("nsContestants3"),
                value: get(
                  `${elementalDamageRaceType} Damage`
                ) + get(
                  `${elementalDamageRaceType} Spell Damage`
                ),
                needed: 100
              }
            )
          ] }),
          step === 2 && // TODO: Link directly to registration desk.
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Return to the registration desk and claim your prize!" }),
          step === 3 && // TODO: Link directly to courtyard.
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Attend your coronation in the courtyard." })
        ]
      }
    );
  }
  if (!pastHedgeMaze) {
    const elements2 = [
      telescope3Map[get$1("telescope3")],
      telescope4Map[get$1("telescope4")],
      telescope5Map[get$1("telescope5")]
    ].filter((e2) => e2);
    const damages = elements2.map((element, index) => [
      element,
      myMaxhp() * (0.9 - 0.1 * index) * (1 - elementalResistance(Element$1.get(element)) / 100)
    ]);
    const totalDamage = sum(damages, ([, d2]) => Math.ceil(d2));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: "Hedge Maze",
        id: "level-13-quest",
        href: NSTOWER_URL,
        imageUrl: "/images/adventureimages/hedgemaze.gif",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkBlock, { href: NSTOWER_URL, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Navigate the Hedge Maze below the tower." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Choose the second option each time." }),
            elements2.every((e2) => e2) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                "Elements needed:",
                " ",
                commaAnd(
                  elements2.map(
                    (element) => element && /* @__PURE__ */ jsxRuntimeExports.jsx(ElementName, { element })
                  ),
                  elements2
                ),
                "."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                "Predicted damage:",
                " ",
                separate(
                  damages.map(
                    ([element, damage]) => element && /* @__PURE__ */ jsxRuntimeExports.jsx(ElementName, { element, children: Math.ceil(damage) })
                  ),
                  " + ",
                  elements2
                ),
                " ",
                "= ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: totalDamage }),
                "."
              ] })
            ] })
          ] }),
          totalDamage > myMaxhp() ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "You do not have enough resistance / max HP." }) : totalDamage > myHp() && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Line,
            {
              color: "red.solid",
              command: haveUnrestricted($skill`Cannelloni Cocoon`) ? `cast ${Math.ceil((myMaxhp() - myHp()) / 999)} Cannelloni Cocoon` : void 0,
              children: "Restore your HP first."
            }
          )
        ]
      }
    );
  }
  if (!pastKeys) {
    const missingKeys = [
      "Boris's key",
      "Jarlsberg's key",
      "Sneaky Pete's key",
      "skeleton key",
      "Richard's star key",
      "digital key"
    ].filter((key) => !keysUsed.includes(key));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Tile,
      {
        header: "Tower Door",
        id: "level-13-quest",
        href: NSTOWER_URL,
        linkEntireTile: true,
        imageUrl: "/images/itemimages/keya.gif",
        children: missingKeys.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Missing keys: ",
          commaAnd(missingKeys),
          "."
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Open the tower door." })
      }
    );
  }
  if (!pastTowerLevel1) {
    const haveBeehive = have$b($item`beehive`);
    const effectSources = damageEffects().filter((effect2) => !have$b(effect2));
    const itemSources = damageItems().filter(
      (item2) => have$b(item2) && !haveEquipped(item2)
    );
    const familiars = [
      [$familiar`Mu`, 5],
      [$familiar`Imitation Crab`, 4],
      [$familiar`Sludgepuppy`, 3],
      [$familiar`Mini-Crimbot`, 3]
    ];
    const bestFamiliar = (_a2 = familiars.find(([familiar]) => have$b(familiar))) == null ? void 0 : _a2[0];
    const elements2 = [
      "hot",
      "cold",
      "spooky",
      "sleaze",
      "stench"
    ];
    const missingElements = elements2.filter(
      (element) => numericModifier(`${capitalize(element)} Damage`) <= 0
    );
    const elementalDamage2 = 5 - missingElements.length;
    const buttSkill = have$b($skill`Headbutt`) ? $skill`Headbutt` : have$b($skill`Kneebutt`) ? $skill`Kneebutt` : have$b($skill`Shieldbutt`) && itemType(equippedItem($slot`off-hand`)) === "shield" ? $skill`Shieldbutt` : null;
    const currentDirect = 1 + elementalDamage2 + +(buttSkill !== null) + get("Damage Aura") + (((_b2 = familiars.find(([familiar]) => familiar === myFamiliar())) == null ? void 0 : _b2[1]) ?? 0);
    const currentThorns = get("Thorns");
    const ml2 = monsterLevelWithPercent();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: "Wall of Skin",
        id: "level-13-quest",
        href: NSTOWER_URL,
        linkEntireTile: haveBeehive,
        imageUrl: "/images/itemimages/beehive.gif",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: haveBeehive ? void 0 : NSTOWER_URL, children: "Defeat the Wall of Skin." }),
          haveBeehive ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use the beehive against it." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink($location`The Black Forest`), children: "Find the beehive in the Black Forest (-combat), or towerkill." }),
            ml2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", color: "red.solid", children: "Remove ML before fighting the Wall of Skin." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Current damage per turn: ",
              currentDirect,
              " direct and",
              " ",
              currentThorns,
              " thorns."
            ] }),
            elementalDamage2 < 5 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Need elements",
              " ",
              commaAnd(
                missingElements.map((element) => /* @__PURE__ */ jsxRuntimeExports.jsx(ElementName, { element })),
                missingElements
              ),
              "."
            ] }),
            effectSources.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Get effects:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: effectSources.map((effect2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                AsyncLink,
                {
                  alignSelf: "start",
                  command: `cast ${decode_1(toSkill(effect2).identifierString)}`,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: decode_1(effect2.identifierString) })
                },
                effect2.identifierString
              )) })
            ] }),
            itemSources.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Equip items:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: itemSources.map((item2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                AsyncLink,
                {
                  alignSelf: "start",
                  command: `equip ${decode_1(item2.identifierString)}`,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: decode_1(item2.identifierString) })
                },
                item2.identifierString
              )) })
            ] }),
            bestFamiliar && myFamiliar() !== bestFamiliar && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { command: `familiar ${bestFamiliar.identifierString}`, children: [
              "Take your ",
              bestFamiliar.identifierString,
              "."
            ] })
          ] })
        ]
      }
    );
  }
  if (!pastTowerLevel2) {
    const meat = meatDropModifier();
    const chance = meatAtLeast(160, 240, 1e3);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: "Defeat the Wall of Meat",
        id: "level-13-quest",
        href: NSTOWER_URL,
        linkEntireTile: true,
        imageUrl: "/images/itemimages/meat.gif",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Current meat drop: ",
            meat.toFixed(0),
            "/525%."
          ] }),
          meat < 525 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You need 525% meat drop to guarantee a one-turn kill." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Right now, ",
              (100 * chance).toFixed(0),
              "% chance to complete in one turn."
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You will kill the Wall of Meat in one turn." })
        ]
      }
    );
  }
  if (!pastTowerLevel3) {
    const haveBoningKnife = have$b($item`electric boning knife`);
    const candyCaneSwordCane = $item`candy cane sword cane`;
    const haveCcsc = haveUnrestricted(candyCaneSwordCane);
    const haveCcscEquipped = haveEquipped(candyCaneSwordCane);
    const slashAvailable = get$1("_surprisinglySweetSlashUsed") < 11;
    const haveSaucegeyser = have$b($skill`Saucegeyser`);
    const mlModifier = Math.max(
      0.5,
      1 - numericModifier("Monster Level") / 250
    );
    const saucegeyserDamage = 3 * mlModifier * (numericModifier("Spell Damage Percent") / 100 * (60 + 0.4 * myBuffedstat($stat`Mysticality`)) + numericModifier("Spell Damage"));
    const badEffects = damageEffects().filter(have$b);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Tile,
      {
        header: "Defeat the Wall of Bones",
        id: "level-13-quest",
        href: NSTOWER_URL,
        linkEntireTile: haveBoningKnife || badEffects.length === 0 && !(haveCcsc && slashAvailable && !haveCcscEquipped),
        imageUrl: "/images/itemimages/elecbone.gif",
        children: haveBoningKnife ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use the electric boning knife against it." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Find the electric boning knife on the ground floor of the Castle in the Clouds in the Sky (-combat), or towerkill." }),
          get("Thorns") + get("Sporadic Thorns") + get("Damage Aura") > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Remove damaging equipment and effects." }),
            badEffects.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Line,
              {
                command: badEffects.map((effect2) => `shrug ${effect2.name}`).join("; "),
                color: "red.solid",
                children: [
                  "Remove thorns effects: ",
                  commaAnd(badEffects),
                  "."
                ]
              }
            )
          ] }),
          haveCcsc && slashAvailable && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            !haveCcscEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "equip candy cane sword cane", color: "red.solid", children: "Equip the candy cane sword." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use Surprisingly Sweet Slash to reduce HP by 75%." })
          ] }),
          haveSaucegeyser && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Minimum Saucegeyser damage: ",
            saucegeyserDamage.toFixed(0),
            "/",
            haveCcsc && slashAvailable ? 1667 : 5e3
          ] })
        ] })
      }
    );
  }
  if (!pastTowerLevel4) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: "Consider the Mirror",
        id: "level-13-quest",
        href: NSTOWER_URL,
        linkEntireTile: true,
        imageUrl: "/images/adventureimages/mirror.gif",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Face the looking glass." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Gazing upon the looking glass will cost a turn, but makes the Naughty Sorceress much easier." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Breaking the mirror will save a turn, but makes the NS fight much more difficult." })
        ]
      }
    );
  }
  if (!pastTowerLevel5) {
    const items2 = $items`gauze garter, filthy poultice, scented massage oil, red pixel potion`;
    const available2 = items2.filter(have$b);
    const classId = myClass().id;
    const image = classId >= 1 && classId < 6 ? `${classId}1` : "11";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: "Your Shadow",
        id: "level-13-quest",
        href: NSTOWER_URL,
        linkEntireTile: true,
        imageUrl: `/images/otherimages/shadows/${image}.gif`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Fight your shadow." }),
          available2.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Healing items: ",
            commaAnd(available2.map((item2) => pluralItem(item2)))
          ] }),
          sum(available2, (item2) => availableAmount(item2)) < 4 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Need more healing items. Get scented massage oil or red pixel potion." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Current initiative: ",
            initiativeModifier().toFixed(0),
            ".",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipIcon, { advice: "You want enough initiative to go first against Your Shadow." })
          ] })
        ]
      }
    );
  }
  if (!kingWaitingToBeFreed) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: "Naughty Sorceress",
        id: "level-13-quest",
        href: NSTOWER_URL,
        linkEntireTile: true,
        imageUrl: "/images/adventureimages/sorcform1.gif",
        disabled: !have$b($item`Wand of Nagamar`),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Defeat the Naughty Sorceress." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Remember: she will remove all your buffs." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Good luck!" })
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: "Free King Ralph",
      id: "level-13-quest",
      href: NSTOWER_URL,
      linkEntireTile: true,
      imageUrl: "/images/otherimages/gash.gif",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Free King Ralph from his prism." })
    }
  );
};
const Level2 = () => {
  const forest = $location`The Spooky Forest`;
  const step = questStep("questL02Larva");
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Spooky Forest",
      imageUrl: "/images/adventureimages/forest.gif",
      href: atStep(step, [
        [Step.UNSTARTED, "/council.php"],
        [Step.STARTED, "/woods.php"],
        [1, "/council.php"],
        [Step.FINISHED, void 0]
      ]),
      linkEntireTile: true,
      minLevel: 2,
      children: atStep(step, [
        [Step.UNSTARTED, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." })],
        [
          Step.STARTED,
          forest.turnsSpent < 5 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Burn ",
            plural(5 - forest.turnsSpent, "turn"),
            " of delay in the Spooky Forest."
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Find NC for mosquito larva." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ForestNoncombatAdvice, {})
          ] })
        ],
        [1, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Turn in larva to the Council." })]
      ])
    }
  );
};
const Level3 = () => {
  const step = questStep("questL03Rat");
  const cold = numericModifier("Cold Damage");
  const hot = numericModifier("Hot Damage");
  const stench = numericModifier("Stench Damage");
  const spooky = numericModifier("Spooky Damage");
  const sleaze = numericModifier("Sleaze Damage");
  const combat = numericModifier("Combat Rate");
  const ml2 = monsterLevelWithPercent();
  const all = Object.entries({ cold, hot, stench, spooky, sleaze });
  const needed = all.filter(([, value]) => value < 20);
  const description = needed.map(([name, value]) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    Math.ceil(20 - value),
    " more ",
    /* @__PURE__ */ jsxRuntimeExports.jsx(ElementName, { element: name })
  ] }));
  const keys = needed.map(([name]) => name);
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Tavern Cellar",
      imageUrl: "/images/adventureimages/rat.gif",
      href: atStep(step, [
        [Step.UNSTARTED, "/council.php"],
        [Step.STARTED, "/tavern.php?place=barkeep"],
        [1, "/cellar.php"],
        [2, "/tavern.php?place=barkeep"]
      ]),
      linkEntireTile: true,
      minLevel: 3,
      disabled: !questFinished("questL02Larva"),
      children: atStep(step, [
        [Step.UNSTARTED, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." })],
        [Step.STARTED, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Talk to Bart Ender." })],
        [
          1,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Explore the cellar to find the rat faucet." }),
            needed.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Need ",
              commaAnd(description, keys),
              " damage."
            ] }),
            combat > -25 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Need ",
              25 + combat,
              "% more -combat."
            ] }),
            ml2 < 300 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Could use up to ",
              300 - ml2,
              " more ML."
            ] })
          ] })
        ],
        [
          2,
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Now that the rat supply is off, talk to Bart Ender again." })
        ]
      ])
    }
  );
};
const BAT_WINGS_LOCATIONS = [
  {
    name: "the Bat Hole Entrance",
    pref: "batWingsBatHoleEntrance",
    item: "bat wing"
  },
  {
    name: "Guano Junction",
    pref: "batWingsGuanoJunction",
    item: "sonar-in-a-biscuit"
  },
  {
    name: "the Batrat Burrow",
    pref: "batWingsBatratBurrow",
    item: "sonar-in-a-biscuit"
  },
  {
    name: "the Beanbat Chamber",
    pref: "batWingsBeanbatChamber",
    item: "enchanted bean"
  }
];
const BAT_HOLE_URL = "/place.php?whichplace=bathole";
const Level4 = () => {
  const step = questStep("questL04Bat");
  const bodyguards = $location`The Boss Bat's Lair`.turnsSpent;
  const beanstalk = questStep("questL10Garbage") >= 1;
  if (step === Step.FINISHED) return null;
  const batWings = $item`bat wings`;
  const haveBatWings = have$b(batWings);
  const haveBatWingsEquipped = haveEquipped(batWings);
  const availableLocations = BAT_WINGS_LOCATIONS.filter(
    ({ pref }) => !get$1(pref)
  );
  const sonar = $item`sonar-in-a-biscuit`;
  const sonarCount = availableAmount(sonar);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Explore the Bat Hole",
      imageUrl: "/images/adventureimages/bossbat.gif",
      href: atStep(step, [
        [Step.UNSTARTED, "/council.php"],
        [Step.STARTED, BAT_HOLE_URL],
        [4, "/council.php"]
      ]),
      minLevel: 4,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          LinkBlock,
          {
            href: haveBatWingsEquipped ? BAT_HOLE_URL : inventoryLink(batWings),
            children: [
              step >= 0 && !have$b($item`enchanted bean`) && !beanstalk && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                "Get an enchanted bean from",
                " ",
                haveBatWings ? "bat wings NC" : "a beanbat",
                " for the level 10 quest."
              ] }),
              haveBatWings && availableLocations.length > 0 && step < 3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                !haveBatWingsEquipped ? "Equip bat wings and adventure " : "Adventure",
                " ",
                "for stuff in",
                " ",
                commaAnd(
                  availableLocations.map(({ name, item: item2 }) => `${name} (${item2})`)
                ),
                "."
              ] })
            ]
          }
        ),
        step === Step.UNSTARTED ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." }) : step < 3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: sonarCount > 0 ? inventoryLink(sonar) : void 0, children: [
          "Blow down ",
          plural(3 - step, "bat hole wall"),
          " by fighting Screambats or using sonars-in-a-biscuit",
          sonarCount > 0 && ` (you have ${sonarCount})`,
          "."
        ] }) : step === 3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Face the fearsome Boss Bat in his lair!",
          " ",
          bodyguards < 4 ? `You must fight at least ${Math.max(0, 4 - bodyguards)} bodyguards to find him.` : bodyguards === 4 ? "Appears in the next three turns." : bodyguards === 5 ? "Appears in the next two turns." : "Appears next turn."
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Return to the council with news of your defeated foe." })
      ]
    }
  );
};
const Level5 = () => {
  const step = questStep("questL05Goblin");
  const turnsSpent = $location`The Outskirts of Cobb's Knob`.turnsSpent;
  const haveKey = have$b($item`Knob Goblin Encryption Key`);
  const veil = $item`Knob Goblin harem veil`;
  const pants = $item`Knob Goblin harem pants`;
  const outfit = have$b(veil) && have$b(pants);
  const havePerfume = have$b($item`Knob Goblin perfume`);
  const havePerfumeEffect = have$b($effect`Knob Goblin Perfume`);
  const equippedOutfit = haveEquipped(veil) && haveEquipped(pants);
  const haveFireExtinguisher = have$b($item`industrial fire extinguisher`);
  const fireExtinguisherCharge = get$1("_fireExtinguisherCharge");
  const haremExtinguished = get$1("fireExtinguisherHaremUsed");
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Knob Goblin King",
      imageUrl: "/images/adventureimages/cobbsknob.gif",
      href: step >= 1 ? parentPlaceLink($location`Cobb's Knob Harem`) : parentPlaceLink($location`The Outskirts of Cobb's Knob`),
      minLevel: haveKey ? 5 : void 0,
      children: step < 1 && turnsSpent < 10 && !haveKey ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        "Burn ",
        plural(10 - turnsSpent, "turn"),
        " of delay in the Outskirts to find the encryption key."
      ] }) : atStep(step, [
        [Step.UNSTARTED, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." })],
        [
          Step.STARTED,
          !haveKey ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Adventure in the Outskirts to find the encryption key." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "use Cobb's Knob map", children: "Use Cobb's Knob map to go inside." })
        ],
        [
          1,
          !outfit ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Acquire the Harem Girl Disguise." }),
            haveFireExtinguisher && fireExtinguisherCharge >= 20 && !haremExtinguished && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", children: "Use Fire Extinguisher: Foam the Place in Harem for free disguise." }),
            !havePerfume && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Get perfume if you can from a Knob Goblin Madam." })
          ] }) : !equippedOutfit ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink("Knob Goblin harem"), children: "Equip the Harem Girl Disguise." }) : !havePerfumeEffect ? havePerfume ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`Knob Goblin perfume`), children: "Use Knob Goblin perfume to get effect." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink($location`Cobb's Knob Harem`), children: "Adventure in the Harem to get the Knob Goblin Perfume effect." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Fight the Knob Goblin King!" })
        ]
      ])
    }
  );
};
const Chevrons = reactExports.forwardRef(({ usesLeft, totalUses, ...props }, ref2) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Text,
    {
      as: "span",
      verticalAlign: "middle",
      whiteSpace: "nowrap",
      ref: ref2,
      ...props,
      children: new Array(totalUses).fill(null).map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Icon$1,
        {
          color: index < usesLeft ? "black" : "fg.subtle",
          fontWeight: 300,
          ml: -2,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, {})
        },
        index
      ))
    }
  );
});
const ChevronsList = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ListIndicator,
  {
    asChild: true,
    display: "inline-flex",
    alignItems: "center",
    height: "1rem",
    mt: "1px",
    marginInlineEnd: 0.5,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chevrons, { ...props })
  }
);
const Level6 = () => {
  const step = questStep("questL06Friar");
  const hash2 = myHash();
  const hasCartography = have$b($skill`Comprehensive Cartography`);
  const combatModifier = combatRateModifier();
  const darkNeck = $location`The Dark Neck of the Woods`;
  const darkHeart = $location`The Dark Heart of the Woods`;
  const darkElbow = $location`The Dark Elbow of the Woods`;
  const friarZones = {
    "Dark Neck": darkNeck,
    "Dark Heart": darkHeart,
    "Dark Elbow": darkElbow
  };
  const inZone = [darkNeck, darkHeart, darkElbow].includes(myLocation());
  const listItems = Object.entries(friarZones).map(([zoneName, zone]) => {
    var _a2, _b2, _c2;
    const zoneQueue = ((_c2 = (_b2 = (_a2 = zone.noncombatQueue) == null ? void 0 : _a2.split(";")) == null ? void 0 : _b2.map((s) => s.trim())) == null ? void 0 : _c2.filter((s) => s && s !== "Dart Perks")) ?? [];
    const ncCompleted = zoneQueue.length + (zone === darkNeck && hasCartography ? 1 : 0);
    if (ncCompleted >= 4) return null;
    const expectedThisNc = turnsToSeeSingleNoncombat(zone);
    const expected = expectedThisNc + Math.max(0, 3 - ncCompleted) * turnsToSeeSingleNoncombatCapped(95, 6);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { pl: "1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronsList, { usesLeft: ncCompleted, totalUses: 4 }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
          zoneName,
          ":"
        ] }),
        " ",
        `${ncCompleted}/4 NCs (${expected === 1 ? "1 turn" : `~${expected.toFixed(1)} turns`} remaining).`
      ] })
    ] }, zoneName);
  });
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Deep Fat Friars",
      imageUrl: "/images/itemimages/dodecagram.gif",
      href: atStep(step, [
        [Step.UNSTARTED, "/council.php"],
        [Step.STARTED, `/friars.php?action=friars&pwd=${hash2}`],
        // I don't know why this requires a hash, but it does.
        [1, "/friars.php?"],
        [2, `/friars.php?action=ritual&pwd=${hash2}`],
        [Step.FINISHED, void 0]
      ]),
      minLevel: 6,
      children: atStep(step, [
        [Step.UNSTARTED, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." })],
        [
          Step.STARTED && 1,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            inZone && combatModifier > -25 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", color: "red.solid", children: "Your -combat% is less than 25%, you want more!" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { variant: "plain", children: listItems })
          ] })
        ],
        [2, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Conduct the ritual to finish the quest." })]
      ])
    }
  );
};
const Monsters = ({ location, target = [] }) => {
  const targets = Array.isArray(target) ? target : [target];
  const { monsterFrequency, queue } = monsterFrequencyAndQueue(location);
  const banishedMonsters = [...getBanishedMonsters().entries()];
  return monsterFrequency.length === 0 ? "No monsters." : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    "Monsters:",
    " ",
    separate(
      monsterFrequency.map(({ monster, frequency }) => {
        var _a2;
        const text = `${monster.name} (${queue.includes(monster) ? "Q " : ""}${(100 * frequency).toFixed(0)}%)`;
        const banisher = (_a2 = banishedMonsters.find(([, m2]) => m2 === monster)) == null ? void 0 : _a2[0];
        return targets.includes(monster) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: text }) : banisher ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { showArrow: true, content: `Banished: ${banisher.name}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "fg.subtle", children: text }) }) : text;
      }),
      ", ",
      monsterFrequency.map(({ monster }) => monster.id)
    ),
    "."
  ] });
};
const getZoneDisplay = (zone, evil, quickInfo, zoneStrategy) => {
  if (evil === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkBlock, { href: "/crypt.php", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
        zone,
        ":"
      ] }),
      " ",
      evil > 13 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        evil - 13,
        "/37 evil to boss. ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Em, { children: quickInfo })
      ] }) : "Fight the boss."
    ] }),
    evil > 13 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { orientation: "vertical" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: zoneStrategy.map((strat, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: strat }, typeof strat === "string" ? strat : index)) })
    ] })
  ] });
};
const Level7 = () => {
  const evilEye = $item`evil eye`;
  const evilEyeCount = availableAmount(evilEye);
  const evilEyePlural = evilEyeCount === 1 ? "evil eye" : evilEyeCount > 1 ? "evil eyes" : "";
  const header = `Use your ${evilEyePlural}`;
  const retroCape = $item`unwrapped knock-off retro superhero cape`;
  const retroCapeEquipped = haveEquipped(retroCape);
  const haveRetroCape = have$b(retroCape);
  const swordEquipped = itemType(equippedItem($slot`weapon`)) === "sword";
  const inCyrpt = $locations`The Defiled Nook, The Defiled Niche, The Defiled Cranny, The Defiled Alcove`.includes(
    myLocation()
  );
  const nookEvil = get$1("cyrptNookEvilness");
  const nicheEvil = get$1("cyrptNicheEvilness");
  const crannyEvil = get$1("cyrptCrannyEvilness");
  const alcoveEvil = get$1("cyrptAlcoveEvilness");
  useNag(
    () => ({
      id: "level-7-evil-eye-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/zomboeye.gif",
      node: evilEyeCount > 0 && nookEvil > 13 && /* @__PURE__ */ jsxRuntimeExports.jsx(Tile, { header, imageUrl: "/images/itemimages/zomboeye.gif", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { command: `use ${evilEyeCount} evil eye`, children: [
        "You have ",
        plural(evilEyeCount, "evil eye"),
        ". Use",
        " ",
        evilEyeCount === 1 ? "it" : "them",
        " to reduce Nook evilness by",
        " ",
        evilEyeCount * 3,
        "."
      ] }) })
    }),
    [evilEyeCount, header, nookEvil]
  );
  useNag(
    () => ({
      id: "level-7-retrocape-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/retrocape1.gif",
      node: inCyrpt && (nookEvil > 13 || nicheEvil > 13 || crannyEvil > 13 || alcoveEvil > 13) && haveRetroCape && (!retroCapeEquipped || !swordEquipped) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Slay the Dead",
          imageUrl: "/images/itemimages/retrocape1.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Equip your retro cape and a sword to clear additional evil." })
        }
      )
    }),
    [
      alcoveEvil,
      crannyEvil,
      haveRetroCape,
      inCyrpt,
      nicheEvil,
      nookEvil,
      retroCapeEquipped,
      swordEquipped
    ]
  );
  const step = questStep("questL07Cyrptic");
  const useFireExtinguisher = have$b($item`industrial fire extinguisher`) && get$1("_fireExtinguisherCharge") > 20 && !get$1("fireExtinguisherCyrptUsed");
  const dragonReady = nookEvil === 0 && nicheEvil === 0 && crannyEvil === 0 && alcoveEvil === 0;
  let mainElement = /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Kill the Bonerdagon." });
  if (!dragonReady) {
    mainElement = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      useFireExtinguisher && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use Fire Extinguisher: Replace the Chill for -10 evil in one zone." }),
      getZoneDisplay("Nook", nookEvil, "+item drop, banish", [
        `${Math.min(100, (1 + itemDropModifier() / 100) * 20).toFixed(
          0
        )}% chance of evil eyes.`
      ]),
      getZoneDisplay("Niche", nicheEvil, "sniff dirty old lihc, banish", [
        "banish all but dirty old lihc",
        // TODO: Something wrong with this...
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Monsters,
          {
            location: $location`The Defiled Niche`,
            target: $monster`dirty old lihc`
          }
        )
      ]),
      getZoneDisplay("Cranny", crannyEvil, "+ML, -combat", [
        `~${Math.max(3, Math.sqrt(monsterLevelWithPercent())).toFixed(
          1
        )} evil per swarm of ghuol whelps`,
        "Pick 4th option in NC."
      ]),
      getZoneDisplay("Alcove", alcoveEvil, "+init, -combat", [
        `${Math.min(100, (150 + initiativeModifier()) / 10).toFixed(
          1
        )}% chance of modern zmobie (${Math.ceil(
          (alcoveEvil - 13) / 5
        )} needed)`,
        "Pick 4th option in NC."
      ])
    ] });
  }
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Undefile the Cyrpt",
      imageUrl: "/images/adventureimages/foss_wyrm.gif",
      minLevel: 7,
      href: atStep(step, [
        [Step.UNSTARTED, "/council.php"],
        [
          Step.STARTED,
          get$1("cyrptTotalEvilness") !== 0 ? "/crypt.php" : void 0
        ],
        [1, "/council.php"]
      ]),
      children: atStep(step, [
        [Step.UNSTARTED, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." })],
        [Step.STARTED, mainElement],
        [1, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to finish quest." })]
      ])
    }
  );
};
function pastNinjaSnowmen() {
  return questStep("questL08Trapper") >= 3;
}
function neededNinjaItems() {
  if (pastNinjaSnowmen()) return [];
  const rope = $item`ninja rope`;
  const crampons = $item`ninja crampons`;
  const carabiner = $item`ninja carabiner`;
  return [rope, crampons, carabiner].filter((item2) => !have$b(item2));
}
function yetiCount() {
  return Math.floor(
    $location`Mist-Shrouded Peak`.turnsSpent / (myPath() === $path`Avant Guard` ? 2 : 1)
  );
}
const TRAPPER_URL = "/place.php?whichplace=mclargehuge&action=trappercabin";
const Level8 = () => {
  const step = questStep("questL08Trapper");
  const goatCheese = itemAmount($item`goat cheese`);
  const oreType = get$1("trapperOre");
  const ore = oreType !== null ? itemAmount(oreType) : 0;
  const neededNinja = neededNinjaItems();
  const neededNinjaCount = neededNinja.length;
  const haveDuffelBag = have$b($item`McHugeLarge duffel bag`);
  const duffelPieces = $items`McHugeLarge duffel bag, McHugeLarge right pole, McHugeLarge left pole, McHugeLarge right ski, McHugeLarge left ski`;
  const equippedDuffelPieces = duffelPieces.filter(
    (item2) => haveEquipped(item2)
  );
  const outfitPieces = $items`snowboarder pants, eXtreme mittens, eXtreme scarf`;
  const neededOutfitPieces = outfitPieces.filter((item2) => !have$b(item2));
  const nonEquippedOutfitPieces = outfitPieces.filter(
    (item2) => !haveEquipped(item2)
  );
  const coldRes = Math.floor(numericModifier("Cold Resistance"));
  if (step === Step.FINISHED) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Trapper",
      imageUrl: "/images/otherimages/thetrapper.gif",
      href: atStep(step, [
        [Step.UNSTARTED, "/council.php"],
        [Step.STARTED, TRAPPER_URL],
        [1, "/place.php?whichplace=mclargehuge"]
      ]),
      minLevel: 8,
      children: atStep(step, [
        [Step.UNSTARTED, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." })],
        [Step.STARTED, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit the Trapper to get your assignment." })],
        [
          1,
          goatCheese < 3 || ore < 3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/place.php?whichplace=mclargehuge", children: [
              "Acquire",
              " ",
              commaAnd(
                truthy([
                  goatCheese < 3 && `${3 - goatCheese} goat cheese`,
                  ore < 3 && `${3 - ore} ${oreType}`
                ])
              ),
              "."
            ] }),
            goatCheese < 3 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Monsters,
              {
                location: $location`The Goatlet`,
                target: $monster`dairy goat`
              }
            ) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: TRAPPER_URL, children: "Return to the trapper." })
        ],
        [
          2,
          neededNinjaCount === 0 || get$1("currentExtremity") === 3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            coldRes >= 5 ? "Climb " : `Get 5 cold resistance (+${5 - coldRes}) and climb `,
            "the Icy Peak."
          ] }) : neededOutfitPieces.length === 0 || have$b($item`McHugeLarge left pole`) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            have$b($item`McHugeLarge left pole`) ? equippedDuffelPieces.length < 5 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Equip",
              " ",
              plural(
                5 - equippedDuffelPieces.length,
                "McHugeLarge item"
              ),
              " ",
              "before adventuring."
            ] }) : nonEquippedOutfitPieces.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Equip ",
              commaAnd(nonEquippedOutfitPieces),
              " before adventuring."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Get ",
              plural(3 - get$1("currentExtremity"), "more NC"),
              " on the eXtreme slope."
            ] })
          ] }) : haveDuffelBag ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`McHugeLarge duffel bag`), children: "Open duffel bag for outfit." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Complete your outfit: get ",
              commaAnd(neededOutfitPieces),
              " from NCs or from monsters on the eXtreme slope."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Low drop rate, so try to get noncombats if you can." })
          ] })
        ],
        [
          3,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            coldRes >= 5 ? "Fight " : `Get 5 cold resistance (+${5 - coldRes}) and fight `,
            yetiCount() < 3 ? `${plural(3 - yetiCount(), "yeti")} and Groar` : "Groar",
            "."
          ] })
        ],
        [5, /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Return fur to the Trapper." })]
      ])
    }
  );
};
const elementalDamage = (base, element) => {
  if (base < 0) return 1;
  const res = elementalResistance(element);
  return Math.max(1, Math.ceil(base - base * res / 100));
};
const ABooPeak = () => {
  const step = questStep("questL09Topping");
  const haunt = get$1("booPeakProgress", 100);
  const lit = get$1("booPeakLit");
  const clue = $item`A-Boo clue`;
  const clueCount = availableAmount(clue);
  const itemDrop = itemDropModifier() + +(haveEquipped($item`Everfull Dart Holster`) && 30);
  const cluePerAdv = Math.min(1, (100 + itemDrop) * 0.15 / 100);
  const turnsTo90 = Math.ceil((haunt - 90) / 2);
  const p3CluesBefore90 = binomialAtLeast(
    clamp(3 - clueCount, 0, 3),
    Math.max(0, turnsTo90),
    cluePerAdv
  );
  const damage = [13, 25, 50, 125, 250];
  const spookyDamage = sum(
    damage,
    (dmg) => elementalDamage(dmg, $element`spooky`)
  );
  const coldDamage = sum(damage, (dmg) => elementalDamage(dmg, $element`cold`));
  const totalDamage = spookyDamage + coldDamage;
  if (lit) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Light A-Boo Peak",
      minLevel: 9,
      href: "/place.php?whichplace=highlands",
      imageUrl: "/images/itemimages/map.gif",
      disabled: step < 2,
      children: haunt === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Light the fire!" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          haunt,
          "% haunted.",
          clueCount * 30 < haunt && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Em, { children: "+item" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Have ",
          plural(clueCount, "clue"),
          ".",
          " ",
          cluePerAdv === 1 ? `${cluePerAdv} clue` : `${cluePerAdv.toFixed(2)} clues`,
          "/adv at +",
          itemDrop.toFixed(0),
          "% item."
        ] }),
        haunt > 90 && clueCount < 3 && 3 - clueCount <= turnsTo90 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(turnsTo90, "turn"),
          " until 90% haunted.",
          " ",
          (100 * p3CluesBefore90).toFixed(0),
          "% chance of getting to 3 clues first."
        ] }),
        clueCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink(clue), children: [
          "Have",
          " ",
          myHp() > 1.5 * totalDamage ? "plenty of HP" : `${myHp()}/${totalDamage} HP needed`,
          " ",
          "for ",
          spookyDamage,
          " spooky and ",
          coldDamage,
          " cold dmg to de-haunt by 30% via clue."
        ] })
      ] })
    }
  );
};
const Angus = () => {
  const step = questStep("questL09Topping");
  if (step !== 1 && step !== 3) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Highland Lord's Tower",
      imageUrl: "/images/itemimages/mistcloak.gif",
      href: "/place.php?whichplace=highlands",
      children: [
        step === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Talk to Angus to start Peak quests!" }),
        step === 3 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Talk to Angus to finish quest!" })
      ]
    }
  );
};
const OilPeak = () => {
  const step = questStep("questL09Topping");
  const lit = get$1("oilPeakLit");
  const ml2 = monsterLevelAdjustment();
  const pressure = get$1("oilPeakProgress");
  const needJar = availableAmount($item`jar of oil`) === 0 && availableAmount($item`bubblin' crude`) < 12 && get$1("twinPeakProgress", 0) < 4 && myPathId() !== 4;
  let pressureReduction = 6.34;
  if (ml2 >= 100) {
    pressureReduction = 63.4;
  } else if (ml2 >= 50) {
    pressureReduction = 31.7;
  } else if (ml2 >= 20) {
    pressureReduction = 19.02;
  }
  if (equippedAmount($item`dress pants`) > 0) pressureReduction += 6.34;
  const dropRates = [100];
  if (ml2 >= 50) dropRates.push(30);
  if (ml2 >= 100 || ml2 < 50 && ml2 >= 20) dropRates.push(10);
  const itemDropRate = (100 + itemDropModifier()) / 100;
  const crudePA = dropRates.reduce(
    (prev2, cur) => prev2 + Math.min(1, cur / 100 * itemDropRate),
    0
  );
  if (lit && !needJar) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: !lit ? "Light Oil Peak" : "Find More Oil",
      id: "oil-peak-quest",
      imageUrl: "/images/adventureimages/oilslick.gif",
      minLevel: 9,
      href: "/place.php?whichplace=highlands",
      disabled: step < 2,
      children: [
        needJar && ml2 < 100 && pressure > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Em, { children: commaSeparate([
          "100ML",
          needJar && "+item",
          needJar && have$b($item`Duskwalker syringe`) && "use Duskwalker syringe in combat"
        ]) }) }),
        (needJar && ml2 < 100 || pressure > 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          ml2,
          " ML",
          ml2 >= 100 ? null : " of 20/50/100",
          ".",
          pressure > 0 && ` ${Math.ceil(pressure / pressureReduction)} turns left.`
        ] }),
        needJar && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "+item for ",
          " more bubbling' crude. ~",
          crudePA.toFixed(1),
          " crude/adv."
        ] }),
        pressure === 0 && !lit && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Adventure once more to light the peak!" })
      ]
    }
  );
};
function countItems(items2, multiplier = 1) {
  return items2.map((item2) => availableAmount(item2) * multiplier).reduce((prev2, current) => prev2 + current);
}
function bridgeItemsNeeded() {
  const bridgeNeeded = have$b($item`bat wings`) ? 25 : 30;
  const bridgeProgress = get$1("chasmBridgeProgress");
  const numExtras = countItems($items`smut orc keepsake box, snow boards`, 5);
  const numFasteners = countItems(
    $items`thick caulk, long hard screw, messy butt joint`
  );
  const fastenersNeeded = Math.max(
    0,
    bridgeNeeded - bridgeProgress - numFasteners - numExtras
  );
  const numLumber = countItems(
    $items`morningwood plank, raging hardwood plank, weirdwood plank`
  );
  const lumberNeeded = Math.max(
    0,
    bridgeNeeded - bridgeProgress - numLumber - numExtras
  );
  const possibleProgress = bridgeProgress + Math.min(numFasteners, numLumber);
  const needBatWings = have$b($item`bat wings`) && possibleProgress >= 25 && possibleProgress < 30;
  return { fastenersNeeded, lumberNeeded, needBatWings };
}
const OrcChasm = () => {
  const step = questStep("questL09Topping");
  const orcProgress = get$1("smutOrcNoncombatProgress");
  const { fastenersNeeded, lumberNeeded, needBatWings } = bridgeItemsNeeded();
  const needs = [
    fastenersNeeded > 0 && plural(fastenersNeeded, "fastener"),
    lumberNeeded > 0 && `${lumberNeeded} lumber`
  ];
  const needMoreItems = lumberNeeded > 0 || fastenersNeeded > 0;
  const musclePieces = Math.min(
    14,
    Math.floor(
      Math.sqrt(
        (myBuffedstat($stat`Muscle`) + get("Weapon Damage")) / 15 * (1 + get("Weapon Damage Percent") / 100)
      )
    )
  );
  const mysticalityPieces = Math.min(
    14,
    Math.floor(
      Math.sqrt(
        (myBuffedstat($stat`Mysticality`) + get("Spell Damage")) / 15 * (1 + get("Spell Damage Percent") / 100)
      )
    )
  );
  const moxiePieces = Math.min(
    14,
    Math.floor(
      Math.sqrt(
        myBuffedstat($stat`Moxie`) / 30 * (1 + get("Sleaze Resistance") * 0.69)
      )
    )
  );
  if (step >= 1) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Bridge the Orc Chasm",
      imageUrl: "/images/itemimages/plank1.gif",
      minLevel: 9,
      href: atStep(step, [
        [Step.UNSTARTED, "/council.php"],
        [
          Step.STARTED,
          needMoreItems ? "/place.php?whichplace=orc_chasm" : "/place.php?whichplace=orc_chasm&action=label1"
        ]
      ]),
      linkEntireTile: !(!needMoreItems && needBatWings && !haveEquipped($item`bat wings`)),
      children: [
        step === Step.UNSTARTED && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit Council to start quest." }),
        step === Step.STARTED && (needMoreItems ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Build a bridge. ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Em, { children: "(+item, -ML)" })
          ] }),
          orcProgress < 15 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Overkill orcs with cold damage: ",
            orcProgress,
            "/15 to NC."
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Blech House next turn!" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Muscle/Weapon Dmg:" }),
                " ",
                musclePieces,
                "/14",
                " ",
                pluralJustDesc(musclePieces, "piece"),
                "."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Myst/Spell Dmg:" }),
                " ",
                mysticalityPieces,
                "/14",
                " ",
                pluralJustDesc(mysticalityPieces, "piece"),
                "."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Moxie/Sleaze Res:" }),
                " ",
                moxiePieces,
                "/14",
                " ",
                pluralJustDesc(moxiePieces, "piece"),
                "."
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            commaAnd(needs),
            " needed."
          ] })
        ] }) : needBatWings && !haveEquipped($item`bat wings`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "equip bat wings", children: "Equip your bat wings and build the bridge!" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Build the bridge!" }))
      ]
    }
  );
};
const Requirement = ({
  met,
  disabled = false,
  children,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Badge,
  {
    colorScheme: disabled ? "gray" : met ? "blue" : "red",
    p: 0.5,
    textTransform: "uppercase",
    ...props,
    children
  }
);
const TwinPeak = () => {
  const step = questStep("questL09Topping");
  const res = Math.floor(numericModifier("stench resistance"));
  const jars = availableAmount($item`jar of oil`);
  const init = initiativeModifier();
  const hedgeTrimmers = $item`rusty hedge trimmers`;
  const haveTrimmers = have$b(hedgeTrimmers);
  const progress = get$1("twinPeakProgress");
  const stenchDone = (progress & 1) > 0;
  const itemDone = (progress & 2) > 0;
  const jarDone = (progress & 4) > 0;
  const initDone = (progress & 8) > 0;
  const ncsDone = +stenchDone + +itemDone + +jarDone + +initDone;
  const trimmersNeeded = 4 - ncsDone - availableAmount($item`rusty hedge trimmers`);
  const famWeight = familiarWeight(myFamiliar()) + numericModifier("familiar weight");
  const equipWeight = numericModifier(
    familiarEquippedEquipment(myFamiliar()),
    "familiar weight"
  );
  const famItemDrop = numericModifier(
    myFamiliar(),
    "item drop",
    famWeight - equipWeight,
    familiarEquippedEquipment(myFamiliar())
  );
  const nonFamItemDrop = itemDropModifier() - famItemDrop + numericModifier("food drop");
  const stenchMet = res >= 4;
  const itemMet = nonFamItemDrop >= 50;
  const jarMet = jars >= 1;
  const initMet = init >= 40;
  const ncsReady = +(stenchMet && !stenchDone) + +(itemMet && !itemDone) + +(jarMet && !jarDone) + +(initMet && !initDone);
  if (initDone) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Light Twin Peak",
      minLevel: 9,
      href: "/place.php?whichplace=highlands",
      imageUrl: "/images/adventureimages/mansion.gif",
      disabled: step < 2,
      children: [
        haveTrimmers && (ncsReady > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(hedgeTrimmers), children: "Use hedge trimmers for next NC." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Meet one of the NC requirements, then use hedge trimmers." })),
        trimmersNeeded > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontStyle: "italic", children: "-combat, +item, olfact topiary animal" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Need ",
            plural(trimmersNeeded, "more hedge trimmer"),
            " from topiary animals."
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { display: "flex", flex: "row", flexWrap: "wrap", gap: 1, rowGap: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Chevrons, { ml: 2, mr: -1, usesLeft: ncsDone, totalUses: 4 }),
          !stenchDone && /* @__PURE__ */ jsxRuntimeExports.jsxs(Requirement, { met: stenchMet, children: [
            res,
            "/4 stench res"
          ] }),
          !itemDone && /* @__PURE__ */ jsxRuntimeExports.jsxs(Requirement, { met: itemMet, children: [
            nonFamItemDrop.toFixed(0),
            "/50 non-fam +item/food"
          ] }),
          !jarDone && /* @__PURE__ */ jsxRuntimeExports.jsxs(Requirement, { met: jarMet, children: [
            jars,
            "/1 jar of oil"
          ] }),
          !initDone && /* @__PURE__ */ jsxRuntimeExports.jsxs(Requirement, { disabled: ncsDone < 3, met: initMet, children: [
            init,
            "/40 +init"
          ] })
        ] })
      ]
    }
  );
};
const Level9 = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(OrcChasm, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Angus, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ABooPeak, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TwinPeak, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OilPeak, {})
  ] });
};
const Hot = ({ ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ElementName, { element: "hot", ...props });
};
const Stench = ({ ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ElementName, { element: "stench", ...props });
};
const HauntedKitchen = () => {
  const kitchen = $location`The Haunted Kitchen`;
  const hotResistance = Math.min(
    Math.floor(numericModifier("Hot Resistance")),
    9
  );
  const stenchResistance = Math.min(
    Math.floor(numericModifier("Stench Resistance")),
    9
  );
  const drawersPerTurn = 1 + Math.max(hotResistance / 6, 0) + Math.max(stenchResistance / 6, 0);
  const drawersNeeded = Math.max(0, 21 - get$1("manorDrawerCount"));
  const kitchenTurns = Math.ceil(drawersNeeded / drawersPerTurn) + 1;
  const vhs = getCounter("Spooky VHS tape");
  const wandererSources = truthy([
    vhs >= 0 && `VHS tape in ${plural(vhs, "turn")}`,
    haveUnrestricted($item`2002 Mr. Store Catalog`) && `later VHS tapes`,
    haveUnrestricted($item`cursed magnifying glass`) && "void wanderers",
    haveUnrestricted($skill`Just the Facts`) && (get$1("_monsterHabitatsRecalled") < 3 || get$1("_monsterHabitatsFightsLeft") > 0) && "habitats"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink(kitchen), children: "Adventure in the Haunted Kitchen to unlock the Billiards Room." }),
    wandererSources.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Place ",
      commaOr(wandererSources),
      " for free progress."
    ] }),
    (hotResistance < 9 || stenchResistance < 9) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Run",
      " ",
      commaAnd(
        [
          hotResistance < 9 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", children: [
            9 - hotResistance,
            " more ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Hot, {}),
            " resistance"
          ] }),
          stenchResistance < 9 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", children: [
            9 - stenchResistance,
            " more ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Stench, {}),
            " resistance"
          ] })
        ],
        ["hot", "stench"]
      ),
      " ",
      "to search faster."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      drawersPerTurn.toFixed(1),
      " drawers per turn.",
      " ",
      drawersNeeded > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        hotResistance >= 9 && stenchResistance >= 9 ? "" : "~",
        plural(drawersNeeded, "drawer"),
        " (",
        plural(kitchenTurns, "turn"),
        ") left."
      ] }) : "Key next turn."
    ] }),
    inebrietyLimit() > 10 && myInebriety() < 10 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Try not to drink past ten, the billiards room is next." })
  ] });
};
const HauntedBilliardsRoom = () => {
  const billiards = $location`The Haunted Billiards Room`;
  const poolSkill = get$1("poolSkill") + numericModifier("Pool Skill");
  const theoreticalHiddenPoolSkill = myInebriety() <= 10 ? myInebriety() : 10 - (myInebriety() - 10) * 2;
  const estimatedPoolSkill = poolSkill + theoreticalHiddenPoolSkill + Math.min(Math.floor(2 * Math.sqrt(get$1("poolSharkCount"))), 10);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink(billiards), children: "Adventure in the Haunted Billiards Room to unlock the Library." }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Train pool skill via -combat. Need 14 up to 18 total pool skill. Have ~",
      estimatedPoolSkill,
      " pool skill."
    ] }),
    estimatedPoolSkill < 18 && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
      myInebriety() < 10 && inebrietyLimit() >= 10 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Drink to 10 inebrierty for +pool skill." }),
      have$b($item`Staff of Ed, almost`) && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Untinker the Staff of Ed, almost." }),
      have$b($item`[7964]Staff of Fats`) && !haveEquipped($item`[7964]Staff of Fats`) && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Equip the Staff of Fats for +pool skill." }),
      !have$b($item`pool cue`) && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Find pool cue." }),
      have$b($item`pool cue`) && !equippedAmount($item`pool cue`) && myPath() !== $path`Gelatinous Noob` && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: inventoryLink($item`pool cue`), children: "Equip pool cue for +pool skill." }) }),
      !haveEffect($effect`Chalky Hand`) && have$b($item`handful of hand chalk`) && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: inventoryLink($item`handful of hand chalk`), children: "Use handful of hand chalk for +pool skill and faster pool skill training." }) })
    ] })
  ] });
};
const HauntedLibrary = () => {
  const library = $location`The Haunted Library`;
  const gnasirProgress = get$1("gnasirProgress");
  const needKillingJar2 = !(gnasirProgress & 4);
  return have$b($item`Lady Spookyraven's necklace`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/place.php?whichplace=manor1&action=manor1_ladys", children: "Give Lady Spookyraven her necklace." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink(library), children: "Adventure in the Library to unlock the second floor." }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Defeat",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: plural(5 - get$1("writingDesksDefeated", 0), "more writing desk") }),
      " ",
      "to acquire a necklace."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Monsters, { location: library, target: $monster`writing desk` }) }),
    !have$b($item`killing jar`) && get$1("desertExploration") < 100 && needKillingJar2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Try to acquire a killing jar to speed up the desert later. 10% drop from banshee librarian. Use +900% item drop, YR, or pickpocket mechanism." })
  ] });
};
const SecondFloor = () => {
  const step = questStep("questM21Dance");
  const shoes = $item`Lady Spookyraven's dancing shoes`;
  const puff = $item`Lady Spookyraven's powder puff`;
  const gown = $item`Lady Spookyraven's finest gown`;
  const gallery = $location`The Haunted Gallery`;
  const bathroom = $location`The Haunted Bathroom`;
  const bedroom = $location`The Haunted Bedroom`;
  const ballroom = $location`The Haunted Ballroom`;
  const bedroomItems = $items`Lord Spookyraven's spectacles, disposable instant camera`;
  const bedroomItemsNeeded = bedroomItems.filter((item2) => !have$b(item2));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: step < 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/place.php?whichplace=manor2&action=manor2_ladys", children: "Talk to Lady Spookyraven on the second floor." }) : step < 3 ? (
    // step3 is right after giving all three items to Lady Spookyraven
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      !have$b(shoes) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: parentPlaceLink(gallery), children: [
        "Find Lady Spookyraven's dancing shoes in the Gallery.",
        gallery.turnsSpent < 5 ? ` ${plural(5 - gallery.turnsSpent, "more turn")} of delay.` : ""
      ] }),
      !have$b(puff) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: parentPlaceLink(bathroom), children: [
        "Find Lady Spookyraven's powder puff in the Bathroom.",
        " ",
        bathroom.turnsSpent < 5 ? `${plural(5 - bathroom.turnsSpent, "more turn")} of delay.` : `At ${combatRateModifier()}% combat, expected ${turnsToSeeNoncombat(85).toFixed(1)} turns.`
      ] }),
      !have$b(gown) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: parentPlaceLink(bedroom), children: [
          "Get Lady Spookyraven's finest gown from an elegant nightstand in the Bedroom.",
          bedroom.turnsSpent < 6 ? ` ${plural(6 - bedroom.turnsSpent, "more turn")} of delay.` : ""
        ] }),
        bedroomItemsNeeded.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Also get ",
          commaAnd(bedroomItemsNeeded),
          " from an ornate nightstand."
        ] })
      ] }),
      have$b(shoes) && have$b(puff) && have$b(gown) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink(ballroom), children: "Give Lady Spookyraven's items to her." })
    ] })
  ) : step === 3 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink(ballroom), children: "Dance with Lady Spookyraven in the Haunted Ballroom." }) });
};
const HauntedBallroom = () => {
  const ballroom = $location`The Haunted Ballroom`;
  const ballroomDelay = 5 - ballroom.turnsSpent;
  const needBallroomSongSet = get$1("lastQuartetAscension") < myAscensions() && (myPath() === $path`Gelatinous Noob` || inBadMoon() || myTurncount() < 200 && combatRateModifier() >= -25 && ballroomDelay > 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    needBallroomSongSet && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink($location`The Haunted Ballroom`), children: "Possibly set -combat ballroom song." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Do not skip the curtains NC the first time, this will make the ballroom song more likely to appear." })
    ] }),
    ballroomDelay > 0 && questStep("questL11Manor") < 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: parentPlaceLink($location`The Haunted Ballroom`), children: [
      "Burn ",
      plural(ballroomDelay, "turn"),
      " of delay in the Ballroom."
    ] })
  ] });
};
const Manor = () => {
  const billiardsKey = $item`Spookyraven billiards room key`;
  const libraryKey = $item`[7302]Spookyraven library key`;
  const ballroom = $location`The Haunted Ballroom`;
  const ballroomProbablyOpen = ballroom.turnsSpent > 0 || questFinished("questM21Dance");
  const secondFloorProbablyOpen = get$1("lastSecondFloorUnlock") >= myAscensions() || questFinished("questM20Necklace") || have$b($item`ghost of a necklace`);
  const allDone = get$1("questL11Manor") === "finished" || ballroomProbablyOpen && ballroom.turnsSpent >= 5;
  if (allDone) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    QuestTile,
    {
      header: "Unlock Spookyraven Manor",
      imageUrl: "/images/adventureimages/lordspooky.gif",
      disabled: myAscensions() === 0 && myLevel() < 5,
      children: [
        have$b($item`telegram from Lady Spookyraven`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`telegram from Lady Spookyraven`), children: "Read telegram from Lady Spookyraven." }),
        !have$b(billiardsKey) && /* @__PURE__ */ jsxRuntimeExports.jsx(HauntedKitchen, {}),
        have$b(billiardsKey) && !have$b(libraryKey) && /* @__PURE__ */ jsxRuntimeExports.jsx(HauntedBilliardsRoom, {}),
        have$b(libraryKey) && !secondFloorProbablyOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(HauntedLibrary, {}),
        secondFloorProbablyOpen && !ballroomProbablyOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(SecondFloor, {}),
        ballroomProbablyOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(HauntedBallroom, {})
      ]
    }
  );
};
const SpaceJellyfishAdvice = ({
  turnsSpent,
  starChartsNeeded,
  starsNeeded,
  linesNeeded
}) => {
  const spaceJellyfish = $familiar`Space Jellyfish`;
  const turnsToNextNC = turnsSpent < 2 ? 2 - turnsSpent : 7 - (turnsSpent - 2) % 7;
  const ncUp = turnsSpent === 2 || (turnsSpent - 2) % 7 === 0;
  if (ncUp && getProperty("lastEncounter") !== "Space Directions") {
    const choices = [];
    if (starChartsNeeded > 0) choices.push("astronomer");
    if (starsNeeded > 0 || linesNeeded > 0) choices.push("camel's toe");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      !isCurrentFamiliar(spaceJellyfish) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "Bring along your space jellyfish!" }) : "Jellyfish NC next adventure",
      ", it'll let you choose a",
      choices[0] === "astronomer" ? "n" : "",
      " ",
      choices.join(" or "),
      " this adventure.",
      (starsNeeded > 0 || linesNeeded > 0) && /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: "Though that will reduce your +item, so choose wisely." })
    ] });
  } else {
    if (isCurrentFamiliar(spaceJellyfish)) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Switch to another familiar?" });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      plural(turnsToNextNC, "more turn"),
      " to jellyfish choice NC."
    ] });
  }
};
const StarKey = () => {
  const richardsStarKey = $item`Richard's star key`;
  const starChart = $item`star chart`;
  const star = $item`star`;
  const line2 = $item`line`;
  const spaceJellyfish = $familiar`Space Jellyfish`;
  const starChartsNeeded = Math.max(0, 1 - availableAmount(starChart));
  const starsNeeded = Math.max(0, 8 - availableAmount(star));
  const linesNeeded = Math.max(0, 7 - availableAmount(line2));
  const needIngredients = starChartsNeeded > 0 || starsNeeded > 0 || linesNeeded > 0;
  const holeInSky = $location`The Hole in the Sky`;
  const holeInSkyAvailable = canAdventure(holeInSky);
  const turnsSpent = holeInSky.turnsSpent;
  const topFloor = $location`The Castle in the Clouds in the Sky (Top Floor)`;
  if (have$b(richardsStarKey) || get$1("nsTowerDoorKeysUsed").includes("Richard's star key")) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Get Richard's star key",
      imageUrl: "/images/itemimages/starkey.gif",
      href: holeInSkyAvailable ? parentPlaceLink(topFloor) : parentPlaceLink(holeInSky),
      children: !holeInSkyAvailable && needIngredients ? canAdventure(topFloor) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink(topFloor), children: "Run -combat on the top floor of the castle for the steam-powered model rocketship." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          turnsToSeeSingleNoncombat(topFloor).toFixed(1),
          " turns until noncombat."
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Unlock the top floor of the castle to get the steam-powered model rocketship." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        needIngredients ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: parentPlaceLink(holeInSky), children: "Need Richard's star key." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Need: ",
            plural(starChartsNeeded, starChart),
            ",",
            " ",
            plural(starsNeeded, star),
            ", ",
            plural(linesNeeded, line2)
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "create Richard's star key", children: "Have all the ingredients. Make the star key." }),
        starChartsNeeded === 1 && starsNeeded === 0 && linesNeeded === 0 && !inHardcore() && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Can pull a star chart." }),
        (starsNeeded > 0 || linesNeeded > 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Olfact ",
          myAscensions() % 2 === 0 ? "skinflute" : "camel's toe",
          "."
        ] }),
        (starsNeeded > 0 || linesNeeded > 0) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "+234% item" }),
        canEquip(spaceJellyfish) && /* @__PURE__ */ jsxRuntimeExports.jsx(
          SpaceJellyfishAdvice,
          {
            turnsSpent,
            starChartsNeeded,
            starsNeeded,
            linesNeeded
          }
        ),
        get$1("shenInitiationDay") === 2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Could wait before going here? Shen will send you here later." })
      ] })
    }
  );
};
const INGREDIENTS = $items`ruby W, metallic A, lowercase N, heavy D`;
const Wand = () => {
  const haveWand = have$b($item`Wand of Nagamar`);
  const haveIngredients = INGREDIENTS.every((item2) => have$b(item2));
  const basement = $location`The Castle in the Clouds in the Sky (Basement)`;
  return !haveWand && /* @__PURE__ */ jsxRuntimeExports.jsx(
    QuestTile,
    {
      header: "Get the Wand of Nagamar",
      imageUrl: "/images/itemimages/wand.gif",
      children: haveIngredients ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "create Wand of Nagamar", children: "You have the ingredients. Make a Wand of Nagamar." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Line,
        {
          href: have$b($effect`Lucky!`) ? parentPlaceLink(basement) : canAdventure(basement) ? inventoryLink($item`11-leaf clover`) : void 0,
          children: [
            "Need ",
            commaAnd(INGREDIENTS.filter((item2) => !have$b(item2))),
            ". Clover the Castle Basement",
            canAdventure(basement) ? "" : " (once it's available)",
            "."
          ]
        }
      )
    }
  );
};
const QuestSection = () => {
  const showStandardQuests = inRun() && myPath() !== $path`Community Service` && myPath() !== $path`Grey Goo` && myBasestat($stat`Muscle`) > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TileSection,
    {
      name: "Quests",
      tiles: [
        ...[],
        ...showStandardQuests ? [
          Level1,
          Zootomist,
          Leveling,
          Delay,
          Manor,
          Level2,
          Level3,
          Level4,
          Level5,
          Level6,
          Level7,
          Level8,
          Level9,
          Level10,
          HiddenTemple,
          Level11,
          Island,
          Level12,
          HeroKeys,
          DigitalKeyQuest,
          StarKey,
          Wand,
          Level13
        ] : [Manor]
      ]
    }
  );
};
const banishSourceLength = {
  "banishing shout": -1,
  "batter up!": -1,
  chatterboxing: 20,
  "classy monkey": 20,
  "cocktail napkin": 20,
  "crystal skull": 20,
  deathchucks: -1,
  "dirty stinkbomb": -1,
  "divine champagne popper": 5,
  "harold's bell": 20,
  "howl of the alpha": -1,
  "ice house": -1,
  "louder than bomb": 20,
  nanorhino: -1,
  pantsgiving: 30,
  "peel out": -1,
  "pulled indigo taffy": 40,
  "smoke grenade": 20,
  "spooky music box mechanism": -1,
  "staff of the standalone cheese": -1,
  "stinky cheese eye": 10,
  "thunder clap": 40,
  "v for vivala mask": 10,
  "replica v for vivala mask": 10,
  "walk away from explosion": 30,
  "tennis ball": 30,
  "curse of vacation": -1,
  "ice hotel bell": -1,
  'bundle of "fragrant" herbs': -1,
  snokebomb: 30,
  beancannon: -1,
  "licorice rope": -1,
  "kgb tranquilizer dart": 20,
  "breathe out": 20,
  "daily affirmation: be a mind master": 80,
  "spring-loaded front bumper": 30,
  "mafia middle finger ring": 60,
  "throw latte on opponent": 30,
  "tryptophan dart": -1,
  "baleful howl": -1,
  "reflex hammer": 30,
  "saber force": 30,
  "human musk": -1,
  "ultra smash": -1,
  "b. l. a. r. t. spray (wide)": -1,
  "system sweep": -1,
  "feel hatred": 50,
  "show your boring familiar pictures": 100,
  "bowl a curveball": 5,
  "patriotic screech": 100,
  "roar like a lion": 30,
  "monkey slap": -1,
  "spring kick": -1
};
function activeBanishes() {
  const banishedMonstersString = getProperty("banishedMonsters");
  const banishedMonstersSplit = banishedMonstersString.split(":");
  const banishes = [];
  for (let i = 0; i < banishedMonstersSplit.length; i += 3) {
    if (banishedMonstersSplit[i] && banishedMonstersSplit[i + 1] && banishedMonstersSplit[i + 2]) {
      const banish = {
        banishedMonster: toMonster(banishedMonstersSplit[i]),
        banishSource: banishedMonstersSplit[i + 1],
        turnBanished: parseInt(banishedMonstersSplit[i + 2]),
        banishTurnLength: 0,
        customResetConditions: ""
      };
      const banishSource2 = banish.banishSource.toLowerCase();
      if (banishSourceLength[banishSource2] !== void 0) {
        banish.banishTurnLength = banishSourceLength[banishSource2];
      }
      if (banishSource2 === "bowl a curveball") {
        banish.banishTurnLength = get$1("cosmicBowlingBallReturnCombats");
      }
      if (banishSource2 === "roar like a lion") {
        banish.banishTurnLength = haveEffect($effect`Hear Me Roar`);
      }
      if ([
        "batter up!",
        "deathchucks",
        "dirty stinkbomb",
        "nanorhino",
        "spooky music box mechanism",
        "ice hotel bell",
        "beancannon",
        "monkey slap"
      ].includes(banishSource2)) {
        banish.customResetConditions = "rollover";
      }
      if (banishSource2 === "ice house" && (!isUnrestricted($item`ice house`) || get$1("inBadMoon"))) {
        continue;
      }
      banishes.push(banish);
    }
  }
  return banishes;
}
const ActiveBanishes = () => {
  const phylumBanishedString = get$1("banishedPhyla");
  const [phylumName, , phylumTurnString] = phylumBanishedString ? phylumBanishedString.split(":") : [null, null, null];
  const phylumTurn = phylumTurnString ? parseInt(phylumTurnString) : null;
  const phylumLength = phylumTurn ? 100 + phylumTurn - myTurncount() : null;
  const banishes = activeBanishes();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { header: "Active Banishes", imageUrl: "/images/itemimages/ballbat.gif", children: [
    phylumLength !== null && phylumLength > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
        "Phylum ",
        phylumName
      ] }),
      ": Patriotic Eagle (",
      plural(phylumLength, "turn"),
      ")."
    ] }),
    banishes.map((banish, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
        decode_1(banish.banishedMonster.name),
        ":"
      ] }),
      " ",
      banish.banishSource,
      " (",
      banish.banishTurnLength === -1 ? "Until Rollover" : plural(banish.banishTurnLength, "turn"),
      ")."
    ] }, index)),
    banishes.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "No active banishes." })
  ] });
};
const BeatenUp = () => {
  let method = "";
  let url = null;
  let command = null;
  if (have$b($skill`Tongue of the Walrus`)) {
    method = "Cast Tongue of the Walrus.";
    command = "cast Tongue of the Walrus";
  } else if (haveUnrestricted($item`Clan VIP Lounge key`) && get$1("_hotTubSoaks") < 5) {
    method = "Soak in VIP hot tub.";
    url = "/clan_viplounge.php";
  } else if (have$b($skill`Shake It Off`)) {
    method = "Cast Shake It Off.";
    url = skillLink($skill`Shake It Off`);
  } else if (get$1("timesRested") < totalFreeRests() && (!have$2() || currentCinch() + cinchRestoredBy() <= 100)) {
    method = `Free rest.`;
    url = "/campground.php";
  } else {
    const healingItems = [
      $item`tiny house`,
      $item`Space Tours Tripple`,
      $item`personal massager`,
      $item`CSA all-purpose soap`,
      $item`forest tears`
    ];
    for (const item2 of healingItems) {
      if (have$b(item2)) {
        method = `Use ${item2.name}.`;
        url = inventoryLink(item2);
        break;
      }
    }
  }
  useNag(
    () => ({
      id: "beaten-up-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/beatenup.gif",
      node: have$b($effect`Beaten Up`) && !have$b($effect`Once-Cursed`) && !have$b($effect`Twice-Cursed`) && !have$b($effect`Thrice-Cursed`) && method && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Remove beaten up",
          imageUrl: "/images/itemimages/beatenup.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: command ?? void 0, href: url ?? void 0, children: method })
        }
      )
    }),
    [command, method, url]
  );
  return null;
};
function useMaxObservedWeight(familiar) {
  const [maxObservedWeight, setMaxObservedWeight] = reactExports.useState(20);
  const Weight = totalFamiliarWeight(familiar, true);
  reactExports.useEffect(() => {
    if (Weight > maxObservedWeight) {
      setMaxObservedWeight(Weight);
    }
  }, [Weight, maxObservedWeight]);
  return maxObservedWeight;
}
function pluralCopies(count, description) {
  return plural(count, `${description} copy`, `${description} copies`);
}
const Copies = () => {
  const maxObservedProfWeight = useMaxObservedWeight(
    $familiar`Pocket Professor`
  );
  const copySources = reactExports.useMemo(
    () => [
      {
        name: "Wink",
        remaining: () => (
          // TODO: this doesn't work correctly when all used for the day
          get$1("_romanticFightsLeft") || (haveUnrestricted($familiar`Reanimated Reanimator`) || haveUnrestricted($familiar`Obtuse Angel`) && have$b($item`quake of arrows`) ? 3 : haveUnrestricted($familiar`Obtuse Angel`) ? 2 : 0)
        ),
        render: ({ remaining }) => {
          var _a2;
          const active = get$1("_romanticFightsLeft") > 0;
          const descriptor = haveUnrestricted($familiar`Reanimated Reanimator`) ? "wink" : "romantic arrow";
          return !active ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Line,
            {
              takeFamiliar: descriptor === "wink" ? $familiar`Reanimated Reanimator` : $familiar`Obtuse Angel`,
              children: [
                plural(remaining, `${descriptor} fight`),
                "."
              ]
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            plural(remaining, `${descriptor} fight`),
            " (",
            (_a2 = get$1("romanticTarget")) == null ? void 0 : _a2.identifierString,
            ")."
          ] });
        }
      },
      {
        name: "LOV Enamorang",
        remaining: () => +(haveUnrestricted($item`LOV Enamorang`) && !get$1("_enamorangs")),
        render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "1 LOV Enamorang copy." })
      },
      {
        name: "Pocket Professor",
        remaining: () => +haveUnrestricted($familiar`Pocket Professor`) && Math.ceil(Math.sqrt(maxObservedProfWeight)) + (+haveUnrestricted($item`Pocket Professor memory chip`) && 2) - get$1("_pocketProfessorLectures"),
        render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { takeFamiliar: $familiar`Pocket Professor`, children: [
          pluralCopies(remaining, "(?) Pocket Professor"),
          " (used",
          " ",
          get$1("_pocketProfessorLectures"),
          ")."
        ] })
      },
      {
        name: "backup camera",
        remaining: () => +haveUnrestricted($item`backup camera`) && 11 - get$1("_backUpUses"),
        render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`backup camera`), children: [
          pluralCopies(remaining, "backup camera"),
          "."
        ] })
      },
      {
        name: "Recall Habitat",
        remaining: () => +haveUnrestricted($skill`Recall Facts: Monster Habitats`) && 5 * (3 - get$1("_monsterHabitatsRecalled")) + get$1("_monsterHabitatsFightsLeft"),
        render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(remaining, "Habitat fight"),
          get$1("_monsterHabitatsFightsLeft") > 0 ? ` (current ${get$1("_monsterHabitatsMonster")})` : null,
          "."
        ] })
      },
      {
        name: "Spooky VHS Tape",
        remaining: () => availableAmount($item`Spooky VHS Tape`) + (+have$b($item`2002 Mr. Store Catalog`) && +!get$1("_2002MrStoreCreditsCollected") && 3) + get$1("availableMrStore2002Credits"),
        render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Line,
          {
            href: !have$b($item`Spooky VHS Tape`) ? `/inv_use.php?whichitem=11257&pwd=${getHashIfAvailable()}` : void 0,
            children: [
              plural(remaining, "Spooky VHS Tape"),
              !have$b($item`Spooky VHS Tape`) && haveUnrestricted($item`2002 Mr. Store Catalog`) && " (buy some)",
              "."
            ]
          }
        )
      },
      {
        name: "mimic egg",
        remaining: () => +haveUnrestricted($familiar`Chest Mimic`) && 11 - get$1("_mimicEggsObtained"),
        render: ({ remaining }) => {
          const xp = $familiar`Chest Mimic`.experience;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { takeFamiliar: $familiar`Chest Mimic`, children: [
            pluralCopies(remaining, "Chest Mimic egg"),
            xp < remaining * 50 ? ` (${Math.floor(xp / 50)} ready, ${50 - xp % 50} xp to next)` : null,
            "."
          ] });
        }
      }
    ],
    [maxObservedProfWeight]
  );
  const { total, rendered } = renderSourceList(copySources);
  if (total === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: `${total} monster copies`,
      id: "copies-tile",
      imageUrl: "/images/itemimages/sputtysheet.gif",
      children: rendered
    }
  );
};
const FAX_SOURCES = [
  {
    name: "Photocopy",
    remaining: () => haveUnrestricted($item`Clan VIP Lounge key`) && isUnrestricted($item`deluxe fax machine`) ? 1 - +get$1("_photocopyUsed") : 0,
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/clan_viplounge.php?action=faxmachine&whichfloor=2", children: [
      remaining,
      " fax machine fax."
    ] })
  },
  {
    name: "Chateau Painting",
    remaining: () => haveUnrestricted($item`Chateau Mantegna room key`) ? 1 - +get$1("_chateauMonsterFought") : 0,
    render: ({ remaining }) => {
      var _a2;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/chateau.php", children: [
        remaining,
        " chateau painting (currently",
        " ",
        (_a2 = get$1("chateauMonster")) == null ? void 0 : _a2.identifierString,
        ")."
      ] });
    }
  },
  {
    name: "Time-Spinner",
    remaining: () => +haveUnrestricted($item`Time-Spinner`) && Math.floor((10 - get$1("_timeSpinnerMinutesUsed")) / 3),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`Time-Spinner`), children: [
      remaining,
      " Time-Spinner recalls (e.g. drunk pygmies)."
    ] })
  },
  {
    name: "pocket wish",
    remaining: () => Math.min(
      (+haveUnrestricted($item`genie bottle`) && 3 - get$1("_genieWishesUsed")) + availableAmount($item`pocket wish`),
      3 - get$1("_genieFightsUsed")
    ),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`pocket wish`), children: [
      remaining,
      " pocket wishes."
    ] })
  },
  {
    name: "Cargo Shorts",
    remaining: () => +(haveUnrestricted($item`Cargo Cultist Shorts`) && !get$1("_cargoPocketEmptied")),
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`Cargo Cultist Shorts`), children: "1 cargo pocket (limited)." })
  },
  {
    name: "Locket",
    remaining: () => reminiscesLeft(),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/inventory.php?reminisce=1", children: [
      plural(remaining, "locket reminisce"),
      "."
    ] })
  },
  {
    name: "mimic egg",
    remaining: () => +haveUnrestricted($familiar`Chest Mimic`) && 11 - get$1("_mimicEggsObtained"),
    render: ({ remaining }) => {
      const xp = $familiar`Chest Mimic`.experience;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Line,
        {
          href: xp >= 100 ? "/place.php?whichplace=town_right&action=townright_dna" : void 0,
          takeFamiliar: xp < 100 ? $familiar`Chest Mimic` : void 0,
          children: [
            plural(remaining, "Chest Mimic egg"),
            xp < remaining * 100 ? ` (${Math.floor(xp / 100)} ready, ${100 - xp % 100} xp to next)` : null
          ]
        }
      );
    }
  }
];
const Faxes = () => {
  const { total, rendered } = renderSourceList(FAX_SOURCES);
  if (total === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: `${total} faxes`,
      id: "fax-tile",
      imageUrl: "/images/itemimages/photocopy.gif",
      children: rendered
    }
  );
};
const FREE_FIGHTS = [
  {
    name: "Snojo",
    remaining: () => +canAdventure($location`The X-32-F Combat Training Snowman`) && 10 - get$1("_snojoFreeFights"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/place.php?whichplace=snojo", children: [
      plural(remaining, "free Snojo fight"),
      "."
    ] })
  },
  {
    name: "NEP",
    remaining: () => +(isUnrestricted($item`Neverending Party invitation envelope`) && (get$1("_neverendingPartyToday") || get$1("neverendingPartyAlways"))) && 10 - get$1("_neverendingPartyFreeTurns"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/place.php?whichplace=town_wrong", children: [
      plural(remaining, "free NEP fight"),
      "."
    ] })
  },
  {
    name: "Witchess",
    remaining: () => +(getCampground()["Witchess Set"] && isUnrestricted($item`Witchess Set`)) && 5 - get$1("_witchessFights"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/campground.php?action=witchess", children: [
      plural(remaining, "Witchess fight"),
      "."
    ] })
  },
  {
    name: "CMG",
    remaining: () => +haveUnrestricted($item`cursed magnifying glass`) && 5 - get$1("_voidFreeFights"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { equipItem: $item`cursed magnifying glass`, children: [
      plural(remaining, "free void fight"),
      " (",
      get$1("cursedMagnifyingGlassCount"),
      "/13 charge)."
    ] })
  },
  {
    name: "Burning Leaves",
    remaining: () => +!!getCampground()["A Guide to Burning Leaves"] && 5 - get$1("_leafMonstersFought"),
    render: ({ remaining }) => {
      const leaves = availableAmount($item`inflammable leaf`);
      const leavesNeeded = 5 * remaining;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/campground.php?preaction=leaves", children: [
        remaining,
        " burning leaf fights",
        leaves < leavesNeeded ? ` (${leaves}/${leavesNeeded} leaves)` : "",
        "."
      ] });
    }
  },
  {
    name: "Trick-or-Treating",
    remaining: () => +(have$b($item`map to a candy-rich block`) && !get$1("_mapToACandyRichBlockUsed")) ? 5 : [...get$1("_trickOrTreatBlock")].filter((c2) => c2 === "D").length,
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Line,
      {
        href: [...get$1("_trickOrTreatBlock")].filter((c2) => c2 === "D").length > 0 ? "/place.php?whichplace=town&action=town_trickortreat" : have$b($item`map to a candy-rich block`) && !get$1("_mapToACandyRichBlockUsed") ? inventoryLink($item`map to a candy-rich block`) : void 0,
        children: [
          remaining,
          " trick-or-treat fights."
        ]
      }
    )
  },
  {
    name: "Seal Clubber Seals",
    remaining() {
      const inventorySummons = Math.min(
        availableAmount($item`seal-blubber candle`),
        availableAmount($item`figurine of a wretched-looking seal`)
      );
      const guildStoreOpen = get$1("lastGuildStoreOpen") >= myAscensions();
      const fightsRemaining = 5 + (+have$b($item`Claw of the Infernal Seal`) && 5) - get$1("_sealsSummoned");
      return +(myClass() === $class`Seal Clubber` && (inventorySummons > 0 || guildStoreOpen)) && fightsRemaining;
    },
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Line,
      {
        href: have$b($item`seal-blubber candle`) && have$b($item`figurine of a wretched-looking seal`) ? inventoryLink($item`figurine of a wretched-looking seal`) : "/shop.php?whichshop=guildstore3",
        children: [
          plural(remaining, "Seal Clubber seal"),
          "."
        ]
      }
    )
  },
  {
    name: "LOV Tunnel",
    remaining: () => +(get$1("loveTunnelAvailable") && !get$1("_loveTunnelUsed") && isUnrestricted($item`LOV Entrance Pass`)) && 3,
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/place.php?whichplace=town_wrong", children: "3 free LOV Tunnel fights." })
  },
  {
    name: "Quad Tom Sandworms",
    remaining: () => +haveUnrestricted($item`Apriling band quad tom`) && 3 - get$1("_aprilBandTomUses") - +(get$1("desertExploration") < 100 && !(get$1("gnasirProgress") & 16)),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`Apriling band quad tom`), children: [
      plural(remaining, "quad tom sandworm"),
      "."
    ] })
  },
  {
    name: "Forest Tentacle",
    remaining: () => +(questStarted("questL02Larva") || questStarted("questG02Whitecastle")) && 1 - +get$1("_eldritchTentacleFought"),
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/place.php?whichplace=forestvillage&action=fv_scientist", children: "1 free eldritch tentacle in the forest." })
  },
  {
    name: "Evoke Horror",
    remaining: () => +haveUnrestricted($skill`Evoke Eldritch Horror`) && 1 - +get$1("_eldritchHorrorEvoked"),
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: skillLink($skill`Evoke Eldritch Horror`), children: "1 free eldritch horror via Evoke Eldritch Horror." })
  }
];
const FreeFights = () => {
  if (myPath() === $path`Avant Guard`) return null;
  const { total, rendered } = renderSourceList(FREE_FIGHTS);
  if (total === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: `${plural(total, "free fight")}`,
      id: "free-fights-tile",
      imageUrl: "/images/adventureimages/eldtentacle.gif",
      tooltip: /* @__PURE__ */ jsxRuntimeExports.jsx(
        AdviceTooltipIcon,
        {
          advice: `These are inherently free fights. They do not cost a turn, nor do they
            decrement your effects. Many of them are scaling fights; by stacking
            large +mainstat% modifiers, they will give increasing amounts of stats
            and allow you to level very quickly!`,
          icon: CircleHelp
        }
      ),
      children: rendered
    }
  );
};
function haveSource(source) {
  return Array.isArray(source) ? source[1]() : have$b(source);
}
function nineVoltCount() {
  return Math.floor(
    (sum(
      [
        [$item`battery (AAA)`, 1],
        [$item`battery (AA)`, 2],
        [$item`battery (D)`, 3],
        [$item`battery (9-Volt)`, 4],
        [$item`battery (lantern)`, 4],
        [$item`battery (car)`, 4]
      ],
      ([item2, multiplier]) => multiplier * availableAmount(item2)
    ) + sum(get$1("_pottedPowerPlant").split(","), (s) => +s && parseInt(s))) / 4
  );
}
const SHERIFF_PIECES = $items`Sheriff pistol, Sheriff badge, Sheriff moustache`;
const FREE_KILL_SOURCES = [
  {
    source: $skill`Shattering Punch`,
    thing: $skill`Shattering Punch`,
    remaining: () => 3 - get$1("_shatteringPunchUsed"),
    captionPlural: () => "Shattering Punches"
  },
  {
    source: $skill`Gingerbread Mob Hit`,
    thing: $skill`Gingerbread Mob Hit`,
    remaining: () => get$1("_gingerbreadMobHitUsed") ? 0 : 1
  },
  {
    source: $item`Asdon Martin keyfob (on ring)`,
    thing: $skill`Asdon Martin: Missile Launcher`,
    caption: () => "Missile Launcher",
    remaining: () => getWorkshed() === $item`Asdon Martin keyfob (on ring)` && !get$1("_missileLauncherUsed") ? 1 : 0
  },
  {
    source: $item`Lil' Doctor bag`,
    thing: $skill`Chest X-Ray`,
    remaining: () => 3 - get$1("_chestXRayUsed")
  },
  {
    source: $item`replica bat-oomerang`,
    thing: $item`replica bat-oomerang`,
    remaining: () => 3 - get$1("_usedReplicaBatoomerang"),
    caption: () => "replica bat-oomerang use"
  },
  {
    source: ["Shocking Lick", () => true],
    thing: $skill`Shocking Lick`,
    remaining: () => get$1("shockingLickCharges") + nineVoltCount()
  },
  {
    source: $item`Everfull Dart Holster`,
    thing: $skill`Darts: Aim for the Bullseye`,
    caption: () => "darts bullseye",
    remaining: () => have$b($effect`Everything Looks Red`) ? 0 : 1
  },
  {
    source: [
      "Sheriff Outfit",
      () => SHERIFF_PIECES.every((item2) => have$b(item2))
    ],
    thing: $skill`Assert your Authority`,
    caption: () => "authority assertion",
    remaining: () => 3 - get$1("_assertYourAuthorityCast")
  },
  {
    source: $item`Breathitin`,
    thing: $item`Breathitin`,
    remaining: () => 5 * clamp(
      availableAmount($item`Breathitin`),
      0,
      Math.floor((spleenLimit() - mySpleenUse()) / 2)
    ) + get$1("breathitinCharges"),
    caption: () => "Breathitin charge"
  },
  {
    source: $item`shadow brick`,
    thing: $item`shadow brick`,
    remaining: () => Math.min(
      availableAmount($item`shadow brick`),
      13 - get$1("_shadowBricksUsed")
    )
  },
  {
    source: $item`groveling gravel`,
    thing: $item`groveling gravel`,
    remaining: () => availableAmount($item`groveling gravel`)
  },
  {
    source: $item`powdered madness`,
    thing: $item`powdered madness`,
    remaining: () => Math.min(
      availableAmount($item`powdered madness`),
      5 - get$1("_powderedMadnessUses")
    )
  },
  {
    source: $item`power pill`,
    thing: $item`power pill`,
    remaining: () => Math.min(availableAmount($item`power pill`), 20 - get$1("_powerPillUses"))
  }
];
const FreeKills = () => {
  const count = sum(
    FREE_KILL_SOURCES,
    ({ source, remaining }) => haveSource(source) ? remaining() : 0
  );
  return count > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: plural(count, "free kill"),
      id: "free-kills",
      imageUrl: "/images/itemimages/kneestick.gif",
      children: FREE_KILL_SOURCES.map(
        ({ source, thing, caption, captionPlural, remaining }) => !haveSource(source) || remaining() <= 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Line,
          {
            color: have$b(thing) ? void 0 : "fg.subtle",
            href: source instanceof Item && !have$b(thing) ? inventoryLink(source) : void 0,
            children: [
              plural(
                remaining(),
                (caption == null ? void 0 : caption()) ?? decode_1(thing.name),
                (captionPlural == null ? void 0 : captionPlural()) ?? (caption ? `${caption()}s` : "plural" in thing ? decode_1(thing.plural) : `${decode_1(thing.name)}s`)
              ),
              "."
            ]
          },
          Array.isArray(source) ? source[0] : source.identifierString
        )
      )
    }
  );
};
const freeRunSources = [
  {
    source: $skill`Snokebomb`,
    thing: $skill`Snokebomb`,
    remaining: () => 3 - get$1("_snokebombUsed")
  },
  {
    source: $item`Kremlin's Greatest Briefcase`,
    thing: $skill`KGB tranquilizer dart`,
    remaining: () => 3 - get$1("_kgbTranquilizerDartUses")
  },
  {
    source: $item`latte lovers member's mug`,
    thing: $skill`Throw Latte on Opponent`,
    caption: () => "latte banish",
    captionPlural: () => "latte banishes",
    remaining: () => 3 - get$1("_latteRefillsUsed") + (get$1("_latteBanishUsed") ? 0 : 1)
  },
  {
    source: $item`Lil' Doctor bag`,
    thing: $skill`Reflex Hammer`,
    remaining: () => 3 - get$1("_reflexHammerUsed")
  },
  {
    source: $skill`Emotionally Chipped`,
    thing: $skill`Feel Hatred`,
    remaining: () => 3 - get$1("_feelHatredUsed")
  },
  {
    source: $item`familiar scrapbook`,
    thing: $skill`Show your boring familiar pictures`,
    caption: () => "scrapbook banish",
    captionPlural: () => "scrapbook banishes",
    remaining: () => Math.floor(get$1("scrapbookCharges") / 100)
  },
  {
    source: $item`mafia middle finger ring`,
    thing: $skill`Show them your ring`,
    caption: () => "middle finger banish",
    captionPlural: () => "middle finger banishes",
    remaining: () => +!get$1("_mafiaMiddleFingerRingUsed")
  },
  {
    source: $item`stuffed yam stinkbomb`,
    thing: $item`stuffed yam stinkbomb`,
    remaining: () => availableAmount($item`stuffed yam stinkbomb`)
  },
  {
    source: $item`handful of split pea soup`,
    thing: $item`handful of split pea soup`,
    remaining: () => availableAmount($item`handful of split pea soup`) + Math.floor(availableAmount($item`whirled peas`) / 2)
  },
  {
    source: $item`anchor bomb`,
    thing: $item`anchor bomb`,
    remaining: () => availableAmount($item`anchor bomb`)
  },
  {
    source: $item`tennis ball`,
    thing: $item`tennis ball`,
    remaining: () => availableAmount($item`tennis ball`)
  },
  {
    source: $item`Louder Than Bomb`,
    thing: $item`Louder Than Bomb`,
    remaining: () => availableAmount($item`Louder Than Bomb`)
  }
];
const FreeRuns = () => {
  const count = sum(
    freeRunSources,
    ({ source, remaining }) => have$b(source) ? remaining() : 0
  );
  return count > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: plural(count, "free run"),
      id: "free-runs",
      imageUrl: "/images/itemimages/snokebomb.gif",
      children: freeRunSources.map(
        ({ source, thing, caption, captionPlural, remaining }) => !have$b(source) || remaining() <= 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Line,
          {
            color: have$b(thing) ? void 0 : "fg.subtle",
            href: source instanceof Item && !have$b(thing) ? inventoryLink(source) : void 0,
            children: [
              plural(
                remaining(),
                (caption == null ? void 0 : caption()) ?? thing.name,
                (captionPlural == null ? void 0 : captionPlural()) ?? ("plural" in thing ? thing.plural : `${thing.name}s`)
              ),
              "."
            ]
          },
          source.identifierString
        )
      )
    }
  );
};
const FREE_ZONES = [
  {
    name: "DMT",
    remaining: () => +haveUnrestricted($familiar`Machine Elf`) && 5 - get$1("_machineTunnelsAdv"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Line,
      {
        ...myFamiliar() === $familiar`Machine Elf` ? { href: "/place.php?whichplace=dmt" } : { command: "familiar Machine Elf" },
        children: [
          plural(remaining, "Machine Tunnels fight"),
          " (backups/wanderers)."
        ]
      }
    )
  },
  {
    name: "Speakeasy",
    remaining: () => +get$1("ownsSpeakeasy") && 3 - get$1("_speakeasyFreeFights"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/place.php?whichplace=speakeasy", children: [
      plural(remaining, "Speakeasy fight"),
      " (wanderers)."
    ] })
  },
  {
    name: "Shadow Affinity",
    remaining: () => +haveEffect($effect`Shadow Affinity`) || +(haveUnrestricted($item`closed-circuit pay phone`) && !get$1("_shadowAffinityToday")) && 11,
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Line,
      {
        href: have$b($effect`Shadow Affinity`) ? "/place.php?whichplace=cemetery" : inventoryLink($item`closed-circuit pay phone`),
        children: [
          plural(remaining, "Shadow Affinity fight"),
          " (",
          haveUnrestricted($item`backup camera`) && "backups/",
          "wanderers)."
        ]
      }
    )
  },
  {
    name: "CyberRealm",
    remaining: () => +(haveUnrestricted($item`server room key`) && haveUnrestricted($skill`OVERCLOCK(10)`)) && 10 - get$1("_cyberFreeFights"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/place.php?whichplace=serverroom", children: [
      plural(remaining, "Server Room fight"),
      " (",
      haveUnrestricted($skill`Recall Facts: Monster Habitats`) && get$1("_monsterHabitatsRecalled") < 3 && "habitats/",
      "wanderers)."
    ] })
  }
];
const FreeZones = () => {
  if (myPath() === $path`Avant Guard`) return null;
  const { total, rendered } = renderSourceList(FREE_ZONES);
  if (total === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: plural(total, "free zone fight"),
      id: "free-zones-resource",
      imageUrl: haveUnrestricted($familiar`Machine Elf`) && get$1("_machineTunnelsAdv") < 5 ? "/images/itemimages/machelf.gif" : "/images/itemimages/collins.gif",
      children: rendered
    }
  );
};
const LUCKY_SOURCES = [
  {
    name: "Hermit",
    remaining: () => 3 - get$1("_cloversPurchased") + availableAmount($item`11-leaf clover`),
    render: () => {
      const clover = $item`11-leaf clover`;
      const cloversAvailableToday = 3 - get$1("_cloversPurchased");
      const cloversInInventory = availableAmount(clover);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: inventoryLink(clover), children: plural(cloversInInventory, clover) }),
        cloversAvailableToday > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            AsyncLink,
            {
              command: `coinmaster buy hermit ${cloversAvailableToday} 11-leaf clover`,
              children: [
                "(can grab ",
                cloversAvailableToday,
                " more from Hermit)"
              ]
            }
          )
        ] }),
        "."
      ] });
    }
  },
  {
    name: "Apriling Sax",
    remaining: () => +haveUnrestricted($item`Apriling band saxophone`) && 3 - get$1("_aprilBandSaxophoneUses"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`Apriling band saxophone`), children: [
      plural(remaining, "Apriling Sax use"),
      "."
    ] })
  },
  {
    name: "August Scepter",
    remaining: () => +(haveUnrestricted($skill`Aug. 2nd: Find an Eleven-Leaf Clover Day`) && !get$1("_aug2Cast") && get$1("_augSkillsCast") < 5),
    render: () => {
      const aug2Skill = $skill`Aug. 2nd: Find an Eleven-Leaf Clover Day`;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: skillLink(aug2Skill), children: "1 August 2nd use." });
    }
  },
  {
    name: "Energy Drinks",
    remaining: () => 6 * availableAmount($item`[10882]carton of astral energy drinks`) + availableAmount($item`[10883]astral energy drink`),
    render: ({ remaining }) => {
      const drink = $item`[10883]astral energy drink`;
      const carton = $item`[10882]carton of astral energy drinks`;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink(have$b(drink) ? drink : carton), children: [
        remaining,
        " energy drinks."
      ] });
    }
  }
];
const WAND_INGREDIENTS = $items`ruby W, metallic A, lowercase N, heavy D`;
const luckyAdventureUses = [
  [
    "Wand",
    () => {
      const haveWand = have$b($item`Wand of Nagamar`);
      const haveIngredients = WAND_INGREDIENTS.every((item2) => have$b(item2));
      const basement = $location`The Castle in the Clouds in the Sky (Basement)`;
      return !haveWand && !haveIngredients && /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: parentPlaceLink(basement), children: "Castle Basement: Wand of Nagamar ingredients." });
    }
  ],
  [
    "Zeppelin",
    () => {
      if (questStep("questL11Ron") >= 2) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        MainLink,
        {
          href: parentPlaceLink($location`A Mob of Zeppelin Protesters`),
          children: "Zeppelin Mob: Choose NC (sleaze, Whatshisname, lynyrdness)."
        }
      );
    }
  ],
  [
    "A-Boo Peak",
    () => !get$1("booPeakLit") && /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: parentPlaceLink($location`A-Boo Peak`), children: "A-Boo Peak: Get 2 A-Boo clues." })
  ],
  [
    "Smut Orc Logging Camp",
    () => get$1("chasmBridgeProgress") < 30 && /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: parentPlaceLink($location`The Smut Orc Logging Camp`), children: "Smut Orcs: Get 3 lumber and 3 fasteners." })
  ],
  [
    "Itznotyerzitz Mine",
    () => questStep("questL08Trapper") <= 1 && availableAmount(get$1("trapperOre") ?? $item.none) < 3 && /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: parentPlaceLink($location`Itznotyerzitz Mine`), children: "Mine: Get one of each type of ore." })
  ],
  [
    "Castle Top Floor",
    () => get$1("sidequestNunsCompleted") === "none" && !questFinished("questL12War") && /* @__PURE__ */ jsxRuntimeExports.jsx(
      MainLink,
      {
        href: parentPlaceLink(
          $location`The Castle in the Clouds in the Sky (Top Floor)`
        ),
        children: "Castle Top Floor: Get inhaler, +200% meat potion for Nuns."
      }
    )
  ],
  [
    "Oasis",
    () => get$1("desertExploration") < 100 && /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: parentPlaceLink($location`The Oasis`), children: "Oasis: Get 20 turns of Ultrahydrated." })
  ]
];
const LuckyAdventures = () => {
  const isLucky = have$b($effect`Lucky!`);
  useNag(
    () => ({
      id: "lucky-adventures-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/11leafclover.gif",
      node: isLucky && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "You're lucky!",
          imageUrl: "/images/itemimages/11leafclover.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "green.solid", children: "Next adventure will be a lucky one." })
        }
      )
    }),
    [isLucky]
  );
  const { total: totalSources, rendered: renderedSources } = renderSourceList(LUCKY_SOURCES);
  if (totalSources === 0) return null;
  const renderedUses = luckyAdventureUses.map(([name, use2]) => {
    const rendered = use2();
    return rendered ? /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: rendered }, name) : false;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: plural(totalSources, "Lucky! adventure"),
      id: "lucky-adventure-tile",
      imageUrl: "/images/itemimages/11leafclover.gif",
      children: [
        renderedSources,
        renderedUses.some((use2) => use2) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Ideas for uses:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: renderedUses })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "No ideas for how to use these. Get creative!" })
      ]
    }
  );
};
const Muffin = () => {
  const muffin = get$1("muffinOnOrder");
  const muffinTin = $item`earthenware muffin tin`;
  const haveTin = haveUnrestricted(muffinTin);
  const muffinOnOrder = muffin && muffin.name.endsWith("muffin");
  const orderedMuffinToday = get$1("_muffinOrderedToday");
  useNag(
    () => ({
      id: "muffin-order-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/earthmuffin.gif",
      node: (muffin === muffinTin || haveTin && !orderedMuffinToday) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Order a muffin",
          id: "muffin-order-nag",
          imageUrl: "/images/itemimages/earthmuffin.gif",
          href: "/place.php?whichplace=monorail&action=monorail_downtown",
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Go to the Breakfast Counter." })
        }
      )
    }),
    [haveTin, muffin, muffinTin, orderedMuffinToday]
  );
  useNag(
    () => ({
      id: "muffin-pickup-nag",
      priority: NagPriority.LOW,
      imageUrl: `/images/itemimages/${muffin == null ? void 0 : muffin.image}`,
      node: muffinOnOrder && !orderedMuffinToday && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: `Pick up your ${muffin.name}`,
          id: "muffin-pickup-nag",
          imageUrl: `/images/itemimages/${muffin.image}`,
          href: "/place.php?whichplace=monorail&action=monorail_downtown",
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Go to the Breakfast Counter." })
        }
      )
    }),
    [muffin, muffinOnOrder, orderedMuffinToday]
  );
  return null;
};
const JELLYFISH_PROBABILITY = [1, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 20];
const FORCE_SOURCES = [
  {
    name: "Clara's bell",
    remaining: () => +haveUnrestricted($item`Clara's bell`) && 1 - +get$1("_claraBellUsed"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`Clara's bell`), children: [
      plural(remaining, "Clara's bell ring"),
      "."
    ] })
  },
  {
    name: "stench jelly",
    remaining: () => clamp(
      availableAmount($item`stench jelly`) + +haveUnrestricted($familiar`Space Jellyfish`) * Math.max(0, 3 - get$1("_spaceJellyfishDrops")),
      0,
      spleenLimit() - mySpleenUse() + clamp(
        availableAmount($item`mojo filter`),
        0,
        3 - get$1("currentMojoFilters")
      )
    ),
    render: () => {
      const available2 = availableAmount($item`stench jelly`);
      const probability = 100 * JELLYFISH_PROBABILITY[Math.min(5, get$1("_spaceJellyfishDrops"))];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`stench jelly`), children: [
        plural(available2, "stench jelly", "stench jellies"),
        " (",
        probability.toFixed(0),
        "% chance to extract next)."
      ] });
    }
  },
  {
    name: "Sneakisol",
    remaining: () => +haveUnrestricted($item`Eight Days a Week Pill Keeper`) && +!get$1("_freePillKeeperUsed") + Math.floor(
      Math.max(
        0,
        spleenLimit() - mySpleenUse() - availableAmount($item`stench jelly`)
      ) / 3
    ),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`Eight Days a Week Pill Keeper`), children: [
      plural(remaining, "Sneakisol force"),
      "."
    ] })
  },
  {
    name: "Cincho de Mayo",
    remaining: () => +haveUnrestricted($item`Cincho de Mayo`) && Math.floor(totalAvailableCinch() / 60),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Line,
      {
        href: haveEquipped($item`Cincho de Mayo`) ? skillLink($skill`Cincho: Fiesta Exit`) : inventoryLink($item`Cincho de Mayo`),
        children: [
          plural(remaining, "Cincho de Mayo force"),
          "."
        ]
      }
    )
  },
  {
    name: "Jurassic Parka",
    remaining: () => +haveUnrestricted($item`Jurassic Parka`) && 5 - get$1("_spikolodonSpikeUses"),
    render: ({ remaining }) => {
      const need = truthy([
        get$1("parkaMode") !== "spikolodon" && "parka spikolodon",
        !haveEquipped($item`Jurassic Parka`) && "equip Jurassic Parka"
      ]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Line,
        {
          color: need.length > 0 ? "gray.solid" : void 0,
          command: need.join("; "),
          children: [
            plural(remaining, "Jurassic Parka force"),
            "."
          ]
        }
      );
    }
  },
  {
    name: "Apriling band tuba",
    remaining: () => +(haveUnrestricted($item`Apriling band helmet`) && get$1("_aprilBandInstruments") < 2 || haveUnrestricted($item`Apriling band tuba`)) && 3 - get$1("_aprilBandTubaUses"),
    render({ remaining }) {
      const tuba = $item`Apriling band tuba`;
      const helmet = $item`Apriling band helmet`;
      const haveTuba = haveUnrestricted($item`Apriling band tuba`);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink(haveTuba ? tuba : helmet), children: [
        plural(remaining, "Apriling band tuba force"),
        haveTuba ? null : " (acquire tuba)",
        "."
      ] });
    }
  },
  {
    name: "McHugeLarge Avalanche",
    remaining: () => +haveUnrestricted($item`McHugeLarge duffel bag`) && 3 - get$1("_mcHugeLargeAvalancheUses"),
    render({ remaining }) {
      const leftSki = $item`McHugeLarge left ski`;
      const haveSki = haveUnrestricted(leftSki);
      const skiEquipped = haveEquipped(leftSki);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Line,
        {
          href: !skiEquipped ? inventoryLink(haveSki ? leftSki : $item`McHugeLarge duffel bag`) : void 0,
          color: !skiEquipped ? "gray.solid" : void 0,
          children: [
            plural(remaining, "McHugeLarge Avalanche"),
            "."
          ]
        }
      );
    }
  }
];
const NoncombatForces = () => {
  const active = get$1("noncombatForcerActive");
  useNag(
    () => ({
      id: "nc-forces-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/clarabell.gif",
      node: active && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Noncombat Forced",
          imageUrl: "/images/itemimages/clarabell.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit a zone with a key noncombat." })
        }
      )
    }),
    [active]
  );
  const { total, rendered } = renderSourceList(FORCE_SOURCES);
  if (total === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: plural(total, "noncombat force"),
      id: "nc-forces-tile",
      imageUrl: "/images/itemimages/clarabell.gif",
      children: rendered
    }
  );
};
const Pulls = () => {
  if (!inRun() || inHardcore() || canInteract()) {
    return null;
  }
  const path = myPath();
  const neededScrip = +(get$1("lastIslandUnlock") < myAscensions() && 3) + +!have$b($item`UV-resistant compass`);
  const { fastenersNeeded, lumberNeeded } = bridgeItemsNeeded();
  const pullList = truthy([
    {
      item: $item`bottle of Blank-Out`,
      turns: 5,
      description: "5 free runs."
    },
    ...fullnessLimit() - myFullness() >= 4 ? $items`Boris's key lime pie, Jarlsberg's key lime pie, Sneaky Pete's key lime pie`.map(
      (item2) => {
        const key = Item.get(item2.name.replace(" lime pie", ""));
        return !have$b(key) && !get$1("nsTowerDoorKeysUsed").includes(key.name) && {
          item: item2,
          turns: 4,
          description: `Eat (${item2.fullness} fullness) for ${key.name} for the tower.`
        };
      }
    ) : [],
    !have$b($item`Mega Gem`) && (!have$b($item`bird rib`) || !have$b($item`lion oil`)) && {
      item: $item`wet stew`,
      turns: 4,
      description: "Skips Whitey's Grove for Bird Rib & Lion Oil.."
    },
    ...neededNinjaItems().map((item2) => ({
      item: item2,
      turns: 3,
      description: "Allows ascending the Icy Peak."
    })),
    {
      item: $item`Shore Inc. Ship Trip Scrip`,
      turns: 3,
      description: `Skip a trip at the Shore (need ${commaAnd([
        get$1("lastIslandUnlock") < myAscensions() && "dinghy plans",
        !have$b($item`UV-resistant compass`) && "compass"
      ])})`,
      needed: neededScrip
    },
    !haveMachete() && lianasCanBeFree() && {
      item: $item`muculent machete`,
      turns: 3,
      description: "Avoids Hidden Park (banish janitors separately)."
    },
    get$1("hiddenTavernUnlock") < myAscensions() && {
      item: $item`book of matches`,
      turns: 3,
      description: "Access cursed punch and free-kill drunk pygmies."
    },
    get$1("zeppelinProtestors") < 80 && {
      item: $item`deck of lewd playing cards`,
      turns: 3,
      description: "Speeds up Zeppelin Mob/Tower Test with 138 sleaze/spell damage"
    },
    get$1("blackForestProgress") < 5 && {
      item: $item`blackberry galoshes`,
      turns: 2,
      description: "Accelerate Black Forest exploration."
    },
    fastenersNeeded + lumberNeeded > 0 && {
      item: $item`smut orc keepsake box`,
      turns: 2,
      description: "Bridge: 5 lumber + 5 fasteners."
    },
    !get$1("nsTowerDoorKeysUsed").includes("Richard's star key") && !have$b($item`Richard's star key`) && {
      item: $item`star chart`,
      turns: 2,
      description: "Skip finding Astronomer for star key."
    },
    get$1("desertExploration") < 100 && {
      item: $item`milestone`,
      turns: 2,
      description: "Advance desert exploration by 5.",
      needed: Number.POSITIVE_INFINITY
    },
    !hiddenTempleUnlocked() && {
      item: $item`Spooky-Gro fertilizer`,
      turns: 2,
      description: "One fewer Arboreal Respite encounter."
    },
    get$1("desertExploration") < 100 && needWormRiding() && {
      item: $item`drum machine`,
      turns: 2,
      description: "Skip finding Blur in Oasis to wormride."
    },
    {
      item: $item`pocket wish`,
      turns: 2,
      description: "Get any effect (Nuns, +item, etc.) or summon a monster.",
      needed: Number.POSITIVE_INFINITY
    },
    {
      item: $item`patent invisibility tonic`,
      turns: 2,
      description: "-15% combat potion. String a bunch of NC zones together, and this will save turns."
    },
    ...!questFinished("questL12War") && get$1("sidequestNunsCompleted") === "none" && path !== $path`Two Crazy Random Summer` ? [
      !have$b($effect`Sinuses For Miles`) && {
        item: $item`Mick's IcyVapoHotness Inhaler`,
        turns: 2,
        description: "+200% meat drop."
      },
      !have$b($effect`Low on the Hog`) && {
        item: $item`tempura cauliflower`,
        turns: 1,
        description: "+100% meat drop."
      },
      !have$b($item`Yeast of Boris`, 2) && !have$b($effect`Inspired Chef`) && {
        item: $item`Boris's bread`,
        turns: 1,
        description: "+100% meat drop."
      }
    ] : [],
    {
      item: $item`mafia middle finger ring`,
      turns: 2,
      description: "Accessory. Grants 1 free run-banish per day. Given how few banishes low-shiny users have, it's pretty easy to argue that a freerun banish like this (where you get 1 banish a day) saves you about 1.5-2 turns per day. Also, it's an 80-turn banish! The length of the banish is actually huge; it allows you to use it for multiple zones in the Junkyard quest (on AMC Gremlins) and the Hidden City (on janitors preferably, or Orderlies/Lawyers if needed)"
    },
    {
      item: $item`Spooky VHS Tape`,
      turns: 2,
      description: "Combat item. Throw at a monster to get a free, wandering copy of that monster 8 turns later that auto-YRs.",
      needed: Number.POSITIVE_INFINITY
    },
    {
      item: $item`Flash Liquidizer Ultra Dousing Accessory`,
      turns: 2,
      description: "Accessory. 20% item drop, grants Douse Water for 3 almost-guaranteed pickpockets per day."
    },
    {
      item: $item`stuffed yam stinkbomb`,
      turns: 2,
      description: "Combat item. Free run-banish.",
      needed: Number.POSITIVE_INFINITY
    },
    {
      item: $item`pro skateboard`,
      turns: 1,
      description: "Accessory. Grants Do an epic mctwist!, which duplicates a monster's items."
    },
    {
      item: $item`waffle`,
      turns: 1,
      description: "Combat item. 1 monster replacement with another in the zone.",
      needed: Number.POSITIVE_INFINITY
    },
    !questPastStep("questL10Garbage", Step.STARTED) && !have$b($item`bat wings`) && {
      item: $item`enchanted bean`,
      turns: 1,
      description: "Skip finding enchanted bean."
    },
    {
      item: $item`rusty hedge trimmers`,
      turns: 1,
      description: "Force NC in Twin Peak.",
      needed: 4 - bitCount(get$1("twinPeakProgress"))
    },
    questFinished("questL03Rat") && spinStatus().extraSpinsNeeded > 0 && {
      item: $item`tangle of rat tails`,
      turns: 1,
      description: "Summon tomb rat king for more tomb ratchets."
    },
    !questFinished("questL10Garbage") && {
      item: $item`Mohawk wig`,
      turns: 1,
      description: "For Giant's Castle top floor."
    },
    !questPastStep("questL11Desert", 2) && get$1("desertExploration") < 100 && needKillingJar() && {
      item: $item`killing jar`,
      turns: 1,
      description: "+15% desert exploration."
    },
    !questPastStep("questL11Palindome", 1) && !have$b($item`photograph of a dog`) && {
      item: $item`disposable instant camera`,
      turns: 1,
      description: "Photograph Racecar Bob in the Palindome."
    },
    {
      item: $item`11-leaf clover`,
      turns: 1,
      description: "Force NCs in Zeppelin Mob, bridge parts, helpful items, or semirare food and booze."
    },
    {
      item: $item`duonoculars`,
      turns: 1,
      description: "Accessory. -5% combat. Also has a very tiny amount of ML, +5."
    },
    (!have$b($item`June cleaver`) || !isUnrestricted($item`June cleaver`)) && {
      item: $item`iFlail`,
      turns: 1,
      description: "Weapon slot. Fam weight + -5% combat."
    }
  ]);
  const pullsUsed = get$1("_roninStoragePulls").split(",").map((s) => parseInt(s));
  const pullsNeeded = pullList.filter(
    ({ item: item2, needed }) => !have$b(item2, needed ?? 1) && isUnrestricted(item2) && !pullsUsed.includes(item2.id) && (storageAmount(item2) > 0 || item2.tradeable)
  );
  if (pullsNeeded.length === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: `${plural(pullsRemaining(), "pull")} from storage`,
      id: "pulls-resource",
      imageUrl: "/images/adventureimages/hagnk_tentacle.gif",
      href: "/storage.php",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: pullsNeeded.map(({ item: item2, turns, description }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MainLink,
        {
          href: storageAmount(item2) > 0 ? storageLink(item2) : item2.tradeable ? mallLink(item2) : void 0,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            AdviceTooltipText,
            {
              advice: description,
              textProps: { _hover: { textDecoration: "none" } },
              children: [
                item2.identifierString,
                ": ",
                plural(turns, "turn"),
                "."
              ]
            }
          )
        }
      ) }, item2.identifierString)) })
    }
  );
};
function inRunEffectWishes() {
  const needDigitalKey = !get$1("nsTowerDoorKeysUsed").includes("digital key") && !have$b($item`digital key`) && get$1("8BitScore") < 1e4;
  const needNuns = myPath() !== $path`Two Crazy Random Summer` && get$1("sidequestNunsCompleted") === "none" && !questFinished("questL12War");
  return [
    {
      target: $effect`Frosty`,
      additionalDescription: "init/item/meat",
      shouldDisplay: needDigitalKey || needNuns,
      currentlyAccessible: true
    },
    {
      target: $effect`Staying Frosty`,
      additionalDescription: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue.solid", children: "cold damage race" }),
      shouldDisplay: get$1("nsContestants3") !== -1 && get$1("nsChallenge2") === "cold",
      currentlyAccessible: true
    },
    {
      target: $effect`Dragged Through the Coals`,
      additionalDescription: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "hot damage race" }),
      shouldDisplay: get$1("nsContestants3") !== -1 && get$1("nsChallenge2") === "hot" && !haveUnrestricted($skill`Song of Sauce`),
      currentlyAccessible: true
    },
    {
      target: $effect`Bored Stiff`,
      additionalDescription: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray.solid", children: "spooky damage race" }),
      shouldDisplay: get$1("nsContestants3") !== -1 && get$1("nsChallenge2") === "spooky",
      currentlyAccessible: true
    },
    {
      target: $effect`Sewer-Drenched`,
      additionalDescription: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.solid", children: "stench damage race" }),
      shouldDisplay: get$1("nsContestants3") !== -1 && get$1("nsChallenge2") === "stench",
      currentlyAccessible: true
    },
    {
      target: $effect`Fifty Ways to Bereave Your Lover`,
      additionalDescription: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple.solid", children: "sleaze damage race / Zeppelin" }),
      shouldDisplay: get$1("nsContestants3") !== -1 && get$1("nsChallenge2") === "sleaze" && get$1("zeppelinProtestors") > 79,
      currentlyAccessible: true
    }
  ];
}
const GENIE_SOURCES = [
  {
    name: "Genie",
    remaining: () => +haveUnrestricted($item`genie bottle`) && 3 - get$1("_genieWishesUsed"),
    render: ({ remaining }) => `${remaining} genie`
  },
  {
    name: "Pocket",
    remaining: () => +isUnrestricted($item`pocket wish`) && availableAmount($item`pocket wish`),
    render: ({ remaining }) => `${remaining} pocket`
  },
  {
    name: "BOFA",
    remaining: () => +haveUnrestricted($skill`Just the Facts`) && 3 - get$1("_bookOfFactsWishes"),
    render: ({ remaining }) => `${remaining} BOFA`
  }
];
const WISH_SOURCES = [
  {
    name: "Genie Wish",
    remaining: () => sum(GENIE_SOURCES, ({ remaining }) => remaining()),
    render: () => {
      const { total, rendered, keys } = renderSourceList(GENIE_SOURCES);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryUseLink($item`pocket wish`), children: [
        plural(total, "wish", "wishes"),
        " (",
        commaAnd(rendered, keys),
        ")."
      ] });
    }
  },
  {
    name: "Cargo Shorts",
    remaining: () => +(haveUnrestricted($item`Cargo Cultist Shorts`) && !get$1("_cargoPocketEmptied")),
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryActionLink("pocket"), children: "1 cargo shorts pocket (limited)." })
  },
  {
    name: "Cursed Monkey's Paw",
    remaining: () => +have$1() && wishes(),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: mainActionLink("cmonk"), children: [
      plural(remaining, "monkey's paw wish", "monkey's paw wishes"),
      "."
    ] })
  }
];
const Wishes = () => {
  const { total, rendered } = renderSourceList(WISH_SOURCES);
  if (total <= 0) return null;
  const effects2 = inRunEffectWishes().filter(
    ({ shouldDisplay }) => shouldDisplay
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: plural(total, "effect wish", "effect wishes"),
      id: "wishes-resource",
      imageUrl: "/images/itemimages/whitecard.gif",
      children: [
        rendered,
        inRun() && effects2.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdviceTooltipText,
          {
            advice: /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: effects2.map(
              ({ target, additionalDescription, currentlyAccessible }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                ListItem,
                {
                  color: currentlyAccessible ? "fg.muted" : void 0,
                  children: [
                    target.identifierString,
                    additionalDescription && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      " (",
                      additionalDescription,
                      ")"
                    ] })
                  ]
                },
                target.identifierString
              )
            ) }),
            children: "Suggested effects."
          }
        )
      ]
    }
  );
};
const AvantGuard = () => {
  const pathCheck = myPath() === $path`Avant Guard`;
  const charged = get$1("bodyguardCharge") >= 50;
  const monster = get$1("bodyguardChatMonster");
  const bodyguard = $familiar`Burly Bodyguard`;
  const bodyguardOut = myFamiliar() === bodyguard;
  useNag(() => {
    const files = [
      $item`McClusky file (page 1)`,
      $item`McClusky file (page 2)`,
      $item`McClusky file (page 3)`,
      $item`McClusky file (page 4)`,
      $item`McClusky file (page 5)`
    ];
    const neededFiles = have$b($item`McClusky file (complete)`) ? 0 : 5 - files.findIndex((file) => !have$b(file));
    const recipeRead = get$1("spookyravenRecipeUsed") === "with_glasses";
    const recommended = truthy([
      questStep("questM21Dance") < 3 && !have$b($item`Lady Spookyraven's finest gown`) && $monster`animated ornate nightstand`,
      questStep("questL11Palindome") >= 1 && $monster`Astronomer`,
      !have$b($item`enchanted bean`) && questStep("questL10Garbage") <= 0 && $monster`beanbat`,
      questStep("twinPeakLit") >= 1 && $monster`bearpig topiary animal`,
      // FIXME: could be more precise
      questStep("questL11Desert") >= 1 && get$1("desertExploration") < 100 && $monster`blur`,
      recipeRead && questStep("questL11Manor") <= 2 && $monster`cabinet of Dr. Limpieza`,
      !have$b($item`Richard's star key`) && $monster`Camel's Toe`,
      questStep("questL08Trapper") === 1 && $monster`dairy goat`,
      get$1("sidequestJunkyardCompleted") === "none" && $monster`erudite gremlin`,
      questStep("questL12War") === 1 && $monster`Green Ops Soldier`,
      questStep("questL05Goblin") === 1 && $monster`Knob Goblin Harem Girl`,
      questStep("questL08Trapper") === 1 && $monster`mountain man`,
      recipeRead && questStep("questL11Manor") <= 2 && $monster`possessed wine rack`,
      1 <= get$1("hiddenBowlingAlleyProgress") && get$1("hiddenBowlingAlleyProgress") < 7 && $monster`pygmy bowler`,
      questStep("questL11Worship") >= 1 && $monster`pygmy janitor`,
      neededFiles > 0 && $monster`pygmy witch accountant`,
      1 <= get$1("hiddenHospitalProgress") && get$1("hiddenHospitalProgress") < 7 && $monster`pygmy witch surgeon`,
      questStep("questL12War") === 1 && $monster`War Frat 151st Infantryman`,
      questStep("questL11Palindome") >= 1 && $monster`white lion`,
      questStep("questL08Trapper") >= 1 && $monster`whitesnake`
    ]);
    return {
      id: "bodyguard-chat-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/bodyguard.gif",
      node: pathCheck && (charged ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: "Bodyguard ready to chat!",
          id: "bodyguard-chat-nag",
          href: bodyguardOut ? "/main.php?talktobg=1" : void 0,
          linkedContent: bodyguard,
          imageAlt: "Burly Bodyguard",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Your bodyguard is ready to talk to you.",
              bodyguardOut && " Take them with you.",
              " Recommended chats:"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { fontSize: ["2xs", "xs"], children: recommended.map((monster2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: monster2.identifierString }, monster2.identifierString)) })
          ]
        }
      ) : monster ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Bodyguard chat next fight.",
          id: "bodyguard-chat-nag",
          imageUrl: `/images/adventureimages/${monster.image}`,
          imageAlt: monster.name,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "You will fight a ",
            monster.name,
            " the next time you enter combat."
          ] })
        }
      ) : null)
    };
  }, [bodyguard, bodyguardOut, charged, monster, pathCheck]);
  return null;
};
const LIMITED_BUFFS = [
  [
    "Witchess",
    $effect`Puzzle Champ`,
    () => have$9() && !get$1("_witchessBuff")
  ],
  [
    "LOV",
    $effect`Open Heart Surgery`,
    () => get$1("loveTunnelAvailable") && isUnrestricted($item`LOV Entrance Pass`) && !get$1("_loveTunnelUsed")
  ],
  [
    "fortune",
    $effect`A Girl Named Sue`,
    () => haveUnrestricted($item`Clan VIP Lounge key`) && !get$1("_clanFortuneBuffUsed")
  ],
  [
    "pool",
    $effect`Billiards Belligerence`,
    () => haveUnrestricted($item`Clan VIP Lounge key`) && get$1("_poolGames") < 3
  ]
];
const FrumiousBandersnatch = () => {
  const current = myFamiliar();
  const bander = $familiar`Frumious Bandersnatch`;
  const boots = $familiar`Pair of Stomping Boots`;
  const familiar = [bander, boots].includes(current) ? current : have$b(bander) && bander.experience > boots.experience && have$b($skill`The Ode to Booze`) ? bander : boots;
  const maxObservedWeight = useMaxObservedWeight(familiar);
  const needOde = have$b($skill`The Ode to Booze`) && !have$b($effect`Ode to Booze`);
  useNag(
    () => ({
      id: "bandersnatch-nag",
      priority: NagPriority.ERROR,
      imageUrl: "/images/itemimages/odetobooze.gif",
      node: current === bander && needOde && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Cast Ode to Booze",
          imageUrl: "/images/itemimages/odetobooze.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "cast Ode to Booze", children: "Make sure you have Ode before adventuring with your Frumious Bandersnatch!" })
        }
      )
    }),
    [bander, current, needOde]
  );
  if (!have$b(familiar)) return null;
  const availableBuffs = LIMITED_BUFFS.filter(
    ([, effect2, available2]) => !have$b(effect2) && available2()
  );
  const possibleWeight = sum(
    availableBuffs,
    ([, effect2]) => numericModifier(effect2, "Familiar Weight")
  );
  const runs = get$1("_banderRunaways");
  const maxRuns = Math.floor(maxObservedWeight / 5);
  const maxPossibleRuns = Math.floor((maxObservedWeight + possibleWeight) / 5);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: familiar === bander ? "Bandersnatch Runaways" : "Boots Runaways",
      id: "bander-runs-resource",
      imageUrl: `/images/itemimages/${familiar.image}`,
      children: [
        familiar.experience < 400 && have$b($skill`Cannelloni Cannon`) && have$b($skill`Flavour of Magic`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          familiar.experience,
          " ",
          familiar === boots ? "boots" : "bander",
          " XP. Tune Cannelloni Cannon to monster element and use repeatedly for XP."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Used ",
          plural(runs, "run"),
          " out of at least ",
          maxRuns,
          " possible (at",
          " ",
          maxObservedWeight,
          " lbs)."
        ] }),
        possibleWeight > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Could get +",
          possibleWeight,
          " lbs from buffs (",
          commaSeparate(availableBuffs.map(([name]) => name)),
          ")."
        ] }),
        haveUnrestricted($skill`Meteor Shower`) && get$1("_meteorShowerUses") < 5 && runs < maxPossibleRuns + 4 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Meteor Shower in combat for up to",
          " ",
          plural(
            Math.min(
              4,
              4 + maxPossibleRuns - runs,
              5 - get$1("_meteorShowerUses")
            ),
            "more run"
          ),
          "."
        ] })
      ]
    }
  );
};
function makeSummon(cards, reason) {
  return {
    cards: Array.isArray(cards) ? cards : [cards],
    reason
  };
}
const DeckOfEveryCard = () => {
  const deckOfEveryCard = $item`Deck of Every Card`;
  const replicaDeckOfEveryCard = $item`replica Deck of Every Card`;
  const activeDeck = have$b(replicaDeckOfEveryCard) ? replicaDeckOfEveryCard : deckOfEveryCard;
  if (!haveUnrestricted(activeDeck)) return null;
  if (myPath() === $path`G-Lover`) return null;
  const cardSummonsLeft = getRemainingDraws();
  const cheatsLeft = getRemainingCheats();
  if (cardSummonsLeft === 0) return null;
  const summons = [];
  if (inRun()) {
    summons.push(makeSummon("XVI - The Tower", "Daily Dungeon key."));
  }
  if (myPath() !== $path`Slow and Steady`) {
    if (haveUnrestricted($skill`Ancestral Recall`)) {
      summons.push(
        makeSummon(
          ["Ancestral Recall", "Island"],
          "+3 adventures via Ancestral Recall."
        )
      );
    } else if (!inRun()) {
      summons.push(
        makeSummon("Ancestral Recall", "Gives +adventure summoning skill.")
      );
    }
  }
  if (get$1("hippyStoneBroken") === "true") {
    summons.push(makeSummon("X of Clubs", "+3 PVP fights."));
  }
  if (inRun()) {
    summons.push(
      makeSummon("X - The Wheel of Fortune", "+100% item for 20 turns.")
    );
  }
  if (inRun() && myPath() !== $path`The Source`) {
    const mainstat = myPrimestat();
    let cardName = "Cardiff";
    if (mainstat === $stat`Muscle`) {
      cardName = "XXI - The World";
    } else if (mainstat === $stat`Mysticality`) {
      cardName = "III - The Empress";
    } else if (mainstat === $stat`Moxie`) {
      cardName = "VI - The Lovers";
    }
    const statGain = Math.floor(
      500 * (1 + numericModifier(`${mainstat} Experience Percent`) / 100)
    );
    summons.push(makeSummon(cardName, `+${statGain} mainstat.`));
  }
  if (inRun() && questStep("questL08Trapper")) {
    summons.push(makeSummon("Mine", "One of every ore."));
  }
  if (!inRun() && !have$b($item`knife`)) {
    summons.push(makeSummon("Knife", "+50% meat farming weapon."));
  }
  const weaponChoices = [];
  if (inRun()) {
    const mainstat = get$1("mainStat");
    if (mainstat === "Muscle" && !have$b($skill`Summon Smithsness`)) {
      weaponChoices.push(makeSummon("Lead pipe", "+100% muscle, +HP club."));
    }
    if (mainstat === "Mysticality" && !have$b($skill`Summon Smithsness`)) {
      weaponChoices.push(makeSummon("Wrench", "+100% spell damage weapon."));
      weaponChoices.push(
        makeSummon(
          "Candlestick",
          "+100% myst, +2 myst/fight weapon. (wrench may be better)"
        )
      );
    }
    if (mainstat === "Moxie" && !have$b($skill`Summon Smithsness`)) {
      if (have$b($skill`Tricky Knifework`)) {
        weaponChoices.push(
          makeSummon("Knife", "+50% meat, +100% moxie knife.")
        );
      } else {
        weaponChoices.push(
          makeSummon("Revolver", "+50% init, +2 moxie/fight ranged weapon.")
        );
      }
    }
    weaponChoices.push(makeSummon("Rope", "+10 familiar weight weapon."));
  }
  summons.push(...weaponChoices);
  summons.push(makeSummon("1952 Mickey Mantle", "Autosells for 10k."));
  if (inRun() && myPath() !== $path`Community Service`) {
    let woolNeeded = 0;
    if (haveUnrestricted($item`Mayam Calendar`) && get$1("lastTempleAdventures") < myAscensions()) {
      woolNeeded += 1;
    }
    if (!canAdventure($location`The Hidden Park`)) {
      woolNeeded += 1;
      if (!have$b($item`the Nostril of the Serpent`) && !get$1("lastTempleButtonsUnlock")) {
        woolNeeded += 1;
      }
    }
    if (availableAmount($item`stone wool`) < woolNeeded) {
      summons.push(makeSummon("Sheep", "3 stone wool."));
    }
  }
  if (!inRun()) {
    summons.push(
      makeSummon("IV - The Emperor", "The Emperor's New Clothes outfit.")
    );
    summons.push(makeSummon("Gift card", "Sell to the needy."));
  }
  if (!inRun() && cardSummonsLeft >= 5) {
    summons.push(
      makeSummon(
        "Random card",
        `${cardSummonsLeft} luck${cardSummonsLeft > 1 ? "s" : ""} of the draw.`
      )
    );
  }
  const cardsAlreadyDrawn = getCardsSeen();
  const unusedSummons = summons.map(({ cards, reason }) => ({
    cards: cards.filter((card) => !cardsAlreadyDrawn.includes(card)),
    reason
  })).filter(({ cards }) => cards.length > 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: `${plural(cheatsLeft, "card")} drawable`,
      id: "deck-of-every-card-tile",
      href: inventoryLink(deckOfEveryCard),
      imageUrl: "/images/itemimages/deckdeck.gif",
      children: unusedSummons.map((summon) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: summon.cards.join(" / ") }),
        ": ",
        summon.reason
      ] }, summon.cards.join(" / ")))
    }
  );
};
const PuckMan = () => {
  const puckMan = have$b($familiar`Ms. Puck Man`) ? $familiar`Ms. Puck Man` : $familiar`Puck Man`;
  const powerPillDrops = get$1("_powerPillDrops");
  const powerPillMaxDrops = myDaycount() + 1;
  const yellowPixels = availableAmount($item`yellow pixel`);
  if (!have$b(puckMan) || !(powerPillDrops < powerPillMaxDrops)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      linkedContent: puckMan,
      imageUrl: `/images/itemimages/${puckMan.image || "puckman.gif"}`,
      children: [
        powerPillDrops < powerPillMaxDrops && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          powerPillDrops,
          "/",
          powerPillMaxDrops,
          " power pill",
          " ",
          pluralJustDesc(powerPillDrops, "drop"),
          "."
        ] }),
        inRun() && get$1("lastIslandUnlock") < myAscensions() && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Line,
          {
            command: yellowPixels >= 50 ? "acquire yellow submarine" : void 0,
            children: [
              "Open Mysterious Island with a yellow submarine",
              yellowPixels < 50 && ` (need ${50 - yellowPixels} more yellow pixels)`,
              "."
            ]
          }
        )
      ]
    }
  );
};
function canPossiblyDrink() {
  return inebrietyLimit() > 0 && myInebriety() < inebrietyLimit() + +(myFamiliar() === $familiar`Stooper` && -1) + +(haveUnrestricted($item`synthetic dog hair pill`) && !get$1("_syntheticDogHairPillUsed")) + +(haveUnrestricted($item`cuppa Sobrie tea`) && !get$1("_sobrieTeaUsed")) + +(have$b($item`spice melange`) && !get$1("spiceMelangeUsed") && 3) + +(have$b($item`Ultra Mega Sour Ball`) && !get$1("_ultraMegaSourBallUsed") && 3) + +(haveUnrestricted($item`designer sweatpants`) && clamp(3 - get$1("_sweatOutSomeBoozeUsed"), 0, 3));
}
function canPossiblyEat() {
  return fullnessLimit() > 0 && myFullness() < fullnessLimit() + +(myFamiliar() === $familiar`Stooper` && -1) + +(haveUnrestricted($item`distention pill`) && !get$1("_distentionPillUsed")) + +(haveUnrestricted($item`cuppa Voraci tea`) && !get$1("_voraciTeaUsed")) + +(have$b($item`spice melange`) && !get$1("spiceMelangeUsed") && 3) + +(have$b($item`Ultra Mega Sour Ball`) && !get$1("_ultraMegaSourBallUsed") && 3);
}
const detectiveBadges = [
  $item`plastic detective badge`,
  $item`bronze detective badge`,
  $item`silver detective badge`,
  $item`gold detective badge`
];
const detectiveSchoolApplication = $item`detective school application`;
const copDollar = $item`cop dollar`;
const DetectiveSchool = () => {
  if (!get$1("hasDetectiveSchool") || !isUnrestricted(detectiveSchoolApplication)) {
    return null;
  }
  const casesRemaining = Math.max(3 - get$1("_detectiveCasesCompleted"), 0);
  const haveBadge = detectiveBadges.some((badge) => have$b(badge));
  const copDollarsHave = availableAmount($item`cop dollar`);
  const buyables = [];
  const mlTypes = [];
  if (canPossiblyEat()) mlTypes.push("food");
  if (canPossiblyDrink()) mlTypes.push("drink");
  if (mlTypes.length > 0 && copDollarsHave >= 4) {
    buyables.push(mlTypes.join("/"));
  }
  if (copDollarsHave >= 10) {
    buyables.push("a -combat potion (50 turns)");
  }
  if (casesRemaining === 0 && haveBadge && !(inRun() && copDollarsHave > 0 && buyables.length > 0)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Detective School",
      imageUrl: "/images/itemimages/dbadge4.gif",
      href: "/place.php?whichplace=town_wrong&action=townwrong_precinct",
      children: [
        casesRemaining > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/place.php?whichplace=town_wrong&action=townwrong_precinct", children: [
          "Solve ",
          plural(casesRemaining, "more case"),
          " for cop dollars."
        ] }),
        !haveBadge && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/place.php?whichplace=town_wrong&action=townwrong_precinct", children: "Collect your Precinct badge." }),
        inRun() && copDollarsHave > 0 && buyables.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkBlock, { href: "/shop.php?whichshop=detective", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "You have ",
            plural(copDollarsHave, copDollar),
            "."
          ] }),
          buyables.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Buy ",
            buyables.length === 1 ? buyables[0] : buyables.join(" or "),
            "."
          ] })
        ] })
      ]
    }
  );
};
const ClanFloundry = () => {
  const vipAvailable = haveUnrestricted($item`Clan VIP Lounge key`);
  if (!vipAvailable || !isUnrestricted($item`Clan Floundry`)) return null;
  if (!inRun()) return null;
  const floundryItems = [
    $item`bass clarinet`,
    $item`fish hatchet`,
    $item`carpe`,
    $item`codpiece`,
    $item`troutsers`,
    $item`tunac`
  ];
  if (floundryItems.some((item2) => have$b(item2))) return null;
  const torsoAware = have$b($skill`Torso Awareness`);
  const canEquipWeapons = canEquip($item`bass clarinet`);
  const bridgeComplete = get$1("chasmBridgeProgress") >= 30;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Rent Floundry Equipment",
      imageUrl: "/images/itemimages/fishhatchet.gif",
      href: "/clan_viplounge.php?action=floundry",
      linkEntireTile: true,
      children: [
        canEquipWeapons && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Bass Clarinet (Ranged Weapon):" }),
            " -10% combat, +100% moxie, -3 MP skill cost, +50 ranged damage."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Fish Hatchet (Weapon):" }),
            " -10% combat, +100% muscle, +5 familiar weight, +50 weapon damage",
            !bridgeComplete && ", +5 bridge progress",
            "."
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Codpiece (Acc):" }),
          " -10% combat, +100% myst, +100 max MP, +50 spell damage",
          !get$1("oilPeakLit") && ", 8 bubblin' crudes",
          "."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Carpe (Back):" }),
          " +combat, +50% meat, +50% myst, regen ~8 MP."
        ] }),
        torsoAware && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Tunac (Shirt):" }),
          " +combat, +25 ML, +25% item, +50% muscle."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Troutsers (Pants):" }),
          " +50% moxie, +50% pickpocket, +5 all res, +11 prismatic damage."
        ] })
      ]
    }
  );
};
const ELEMENTS_TO_RESIST = {
  "Cobb's Knob Treasury": "spooky",
  "The Haunted Conservatory": "stench",
  "The Haunted Gallery": "hot",
  "The Haunted Kitchen": "cold",
  "The Haunted Wine Cellar": "sleaze",
  "The Icy Peak": "hot",
  "Inside the Palindome": "spooky",
  "Madness Bakery": "hot",
  "The Old Landfill": "stench",
  "The Overgrown Lot": "sleaze",
  "The Skeleton Store": "spooky",
  "The Smut Orc Logging Camp": "spooky",
  "The Spooky Forest": "spooky"
};
const ProtonicAcceleratorPack = () => {
  const protonPack = $item`protonic accelerator pack`;
  const haveProtonPack = haveUnrestricted(protonPack);
  const shouldFightGhosts = myPath() !== $path`Avant Guard`;
  const protonPackEquipped = haveEquipped(protonPack);
  const nextGhostTurn = get$1("nextParanormalActivity");
  const nextGhostTimer = nextGhostTurn - totalTurnsPlayed();
  const ghostLocation = get$1("ghostLocation");
  const streamsCrossed = get$1("_streamsCrossed");
  useNag(
    () => ({
      id: "protonic-pack-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/protonpack.gif",
      node: haveProtonPack && shouldFightGhosts && nextGhostTurn <= totalTurnsPlayed() && /* @__PURE__ */ jsxRuntimeExports.jsx(Tile, { header: "It's ghost bustin' time!", linkedContent: protonPack, children: !protonPackEquipped ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Equip the protopack first." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "blue.solid", children: "Who you gonna call? You!" }) })
    }),
    [
      haveProtonPack,
      nextGhostTurn,
      protonPack,
      protonPackEquipped,
      shouldFightGhosts
    ]
  );
  useNag(
    () => ({
      id: "protonic-pack-quest-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/protonpack.gif",
      node: questStarted("questPAGhost") && ghostLocation !== null && haveProtonPack && shouldFightGhosts && canAdventure(ghostLocation) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: `Defeat the ghost in ${ghostLocation.identifierString}`,
          linkedContent: protonPack,
          href: parentPlaceLink(ghostLocation),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "This won't cost a turn." }),
            protonPackEquipped ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: 'Cast "shoot ghost" three times, then "trap ghost".' }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "equip protonic accelerator pack", color: "red.solid", children: "Equip the protonic accelerator pack first." }),
            ghostLocation === $location`Inside the Palindome` && !haveEquipped($item`Talisman o' Namsilat`) && (have$b($item`Talisman o' Namsilat`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "equip Talisman o' Namsilat", children: "Equip the Talisman o' Namsilat first." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Need Talisman o' Namsilat first." })),
            Object.entries(ELEMENTS_TO_RESIST).map(
              ([location, element]) => (ghostLocation == null ? void 0 : ghostLocation.identifierString) === location && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ElementName, { element, children: `+${element} resist` }) }, location)
            )
          ]
        }
      )
    }),
    [
      ghostLocation,
      haveProtonPack,
      protonPack,
      protonPackEquipped,
      shouldFightGhosts
    ]
  );
  if (!haveProtonPack || !shouldFightGhosts || !(nextGhostTurn > totalTurnsPlayed()) && !(!streamsCrossed && inRun() && myPath() !== $path`G-Lover`)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: protonPack, children: [
    nextGhostTurn > totalTurnsPlayed() && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      nextGhostTimer,
      " adventures until your next protonic ghost."
    ] }),
    !streamsCrossed && inRun() && myPath() !== $path`G-Lover` && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Stream crossing available:" }),
        " +20% stats for 10 turns."
      ] }),
      !protonPackEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Equip the protonic accelerator pack first." })
    ] })
  ] });
};
const TERMINAL_URL = "/campground.php?action=terminal";
const SourceTerminalTile = () => {
  const sourceTerminal = $item`Source terminal`;
  const sourceEssence = $item`Source essence`;
  const haveTerminal = (isNormalCampgroundPath() || myPath() === $path`Nuclear Autumn`) && haveInCampground(sourceTerminal);
  const extrudes = get$1("_sourceTerminalExtrudes");
  const enquiry = get$1("sourceTerminalEnquiry");
  const installedChips = getChips();
  const activeSkills = getSkills();
  const digitizeActive = activeSkills.includes(Skills.Digitize);
  const extractActive = activeSkills.includes(Skills.Extract);
  const turboActive = activeSkills.includes(Skills.Turbo);
  const skillLimit = installedChips.includes("DRAM") ? 2 : 1;
  const skillsNeeded = skillLimit - activeSkills.length;
  const enhancementsRemaining = enhanceUsesRemaining();
  const turnDuration = enhanceBuffDuration();
  const digitizesLeft = getDigitizeUsesRemaining();
  useNag(
    () => ({
      id: "source-terminal-learn-skills-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/sourceterminal.gif",
      node: haveTerminal && skillsNeeded > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Source Terminal Skills",
          imageUrl: "/images/itemimages/sourceterminal.gif",
          href: TERMINAL_URL,
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Learn ",
            skillsNeeded,
            " skill",
            skillsNeeded > 1 ? "s" : "",
            ". Maybe",
            " ",
            commaAnd([!extractActive && "Extract", !turboActive && "Turbo"])
          ] })
        }
      )
    }),
    [haveTerminal, skillsNeeded, extractActive, turboActive]
  );
  if (!haveTerminal) return null;
  const targetMonsters = [
    !get$1("lighthouseFinished") && availableAmount($item`barrel of gunpowder`) < 5 && "lobsterfrogman",
    get$1("cyrptAlcoveEvilness") > 31 && "modern zmobie",
    !get$1("mountainClimbed") && !have$b($item`ninja rope`) && !have$b($item`ninja carabiner`) && !have$b($item`ninja crampons`) && "ninja assassin",
    get$1("_witchessFights") < 5 && "witchess knight/bishop/rook"
  ].filter(Boolean);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !enquiry && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: "Set Source Terminal Enquiry",
        imageUrl: "/images/itemimages/sourceterminal.gif",
        href: TERMINAL_URL,
        linkEntireTile: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Set an enquiry for rollover buffs." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "familiar.enq:" }),
            " +5 familiar weight."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "monsters.enq:" }),
            " +25 ML."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "stats.enq:" }),
            " +100% stats."
          ] })
        ]
      }
    ),
    enhancementsRemaining > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Tile,
      {
        header: plural(enhancementsRemaining, "enhancement"),
        id: "source-terminal-enhance-resource",
        imageUrl: "/images/itemimages/10101.gif",
        href: TERMINAL_URL,
        linkEntireTile: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "+30% item, +60% meat, or +50% init (",
          turnDuration,
          " turns)."
        ] })
      }
    ),
    digitizesLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: plural(digitizesLeft, "digitization"),
        id: "source-terminal-digitize-resource",
        imageUrl: "/images/itemimages/watch.gif",
        href: !digitizeActive ? TERMINAL_URL : void 0,
        linkEntireTile: !digitizeActive,
        children: [
          !digitizeActive && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", children: "Need to learn digitize!" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Could target a ",
            commaOr(targetMonsters),
            "."
          ] }),
          0 < digitizesLeft && getDigitizeMonster() !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Could re-digitize to reset the window." })
        ]
      }
    ),
    extrudes < 3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: plural(3 - extrudes, "extrusion"),
        id: "source-terminal-extrude-resource",
        imageUrl: "/images/itemimages/browsercookie.gif",
        href: TERMINAL_URL,
        linkEntireTile: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Food: 4 fullness epic food." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Drink: 4 drunkenness epic booze." }),
          availableAmount(sourceEssence) < 10 * (3 - extrudes) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use Extract skill in combat for more essence." })
        ]
      }
    )
  ] });
};
const Thanksgarden = () => {
  const turkeyBlaster = $item`turkey blaster`;
  const stuffingFluffer = $item`stuffing fluffer`;
  const cashew = $item`cashew`;
  const cornucopia = $item`cornucopia`;
  const cornucopiaCount = getCampground()["cornucopia"] ?? 0;
  const availableSpleen = spleenLimit() - mySpleenUse();
  const blasterTurnsUsed = get$1("_turkeyBlastersUsed");
  const blasterTurnsLeft = Math.min(
    3 - blasterTurnsUsed,
    Math.floor(availableSpleen / 2)
  );
  const delayAreas = [
    $location`The Outskirts of Cobb's Knob`,
    $location`The Spooky Forest`,
    $location`The Castle in the Clouds in the Sky (Ground Floor)`,
    $location`The Haunted Gallery`,
    $location`The Haunted Bathroom`,
    $location`The Haunted Ballroom`,
    $location`The Boss Bat's Lair`
  ].filter((l2) => l2.turnsSpent >= 1);
  if (!canAccessGarden() || !isUnrestricted(cornucopia)) return null;
  if (!have$b(cornucopia) && !have$b(cashew) && !have$b(turkeyBlaster) && !have$b(stuffingFluffer) && cornucopiaCount === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Thanksgarden Resources",
      imageUrl: "/images/itemimages/cornucopia.gif",
      children: [
        cornucopiaCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/campground.php", children: [
          "Harvest ",
          plural(cornucopiaCount, "cornucopia"),
          ", or wait til tomorrow for more."
        ] }),
        have$b(cornucopia) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(cornucopia), children: "Open for thanksgarden food." }),
        have$b(cashew) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: "/shop.php?whichshop=thankshop", children: [
          "Could make into",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { as: "span", children: [
            commaSeparate(
              [
                /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: "Requires 3 cashews each.", children: `${plural(
                  Math.floor(availableAmount(cashew) / 3),
                  turkeyBlaster
                )} to burn delay` }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: "Requires 3 cashews each.", children: `${plural(
                  Math.floor(availableAmount(cashew) / 3),
                  stuffingFluffer
                )} for the war` }),
                "various foods",
                /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: "Requires 3 cashews.", children: "gravy boat for the crypt (somewhat marginal)" })
              ],
              ["turkey", "stuffing", "foods", "boat"]
            ),
            "."
          ] })
        ] }),
        have$b(turkeyBlaster) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink(turkeyBlaster), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: "Will burn five turns of delay in the last area adventured." }),
          delayAreas.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
            "Suggested areas: ",
            commaAnd(delayAreas.map((l2) => l2.toString())),
            "."
          ] }),
          blasterTurnsLeft === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
            "Cannot use any more today",
            3 - blasterTurnsUsed > 0 ? "; no spleen room" : "",
            "."
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
            "Can use ",
            plural(blasterTurnsLeft, "more time"),
            " today."
          ] })
        ] }),
        have$b(stuffingFluffer) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(stuffingFluffer), children: "Clears out level 12 armies. Use before adventuring on the battlefield." })
      ]
    }
  );
};
const AsdonMartin = () => {
  const asdonMartinKeyfob = $item`Asdon Martin keyfob (on ring)`;
  const inFamiliarsPath = myPath() === $path`Pocket Familiars`;
  const inGLoverPath = myPath() === $path`G-Lover`;
  const freeRunsUsable = myPath() !== $path`BIG!`;
  const banisherActive = activeBanishes().find(
    (b2) => b2.banishSource === "Spring-Loaded Front Bumper"
  );
  const currentFuel = getFuel();
  const missileLauncherUsed = get$1("_missileLauncherUsed");
  const workshedAsdon = getWorkshed() === asdonMartinKeyfob;
  useNag(
    () => ({
      id: "asdon-martin-bumper",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/asdonfob.gif",
      node: workshedAsdon && !banisherActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Cast Spring-Loaded Front Bumper",
          imageUrl: "/images/itemimages/asdonfob.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            currentFuel >= 50 ? `Banish${freeRunsUsable ? "/free run" : ""}, costs 50 fuel.` : /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "Need 50 fuel first." }),
            inFamiliarsPath && /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: "In FantasyRealm, where you can extract for consumables." })
          ] })
        }
      )
    }),
    [
      workshedAsdon,
      banisherActive,
      currentFuel,
      freeRunsUsable,
      inFamiliarsPath
    ]
  );
  if (!workshedAsdon) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { header: "Asdon Martin", imageUrl: "/images/itemimages/asdonfob.gif", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Current Fuel: ",
      currentFuel
    ] }),
    !canInteract() && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Can create and feed loaf of soda breads." }),
    !missileLauncherUsed && !inFamiliarsPath && !inGLoverPath && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: currentFuel >= 100 ? void 0 : "red.solid", children: "Missile Launcher available. Costs 100 fuel, instakill + YR-equivalent." }) }),
    banisherActive && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      plural(
        banisherActive.banishTurnLength + banisherActive.turnBanished - myTurncount(),
        "turn"
      ),
      " ",
      "until next Asdon bumper (banish/runaway)."
    ] })
  ] });
};
const TunnelOfLove = () => {
  const heartShapedCrate = $item`heart-shaped crate`;
  const primestat = myPrimestat();
  const path = myPath();
  if (!isUnrestricted(heartShapedCrate) || !have$8() || isUsed()) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Take a Love Trip",
      imageUrl: "/images/itemimages/heart.gif",
      href: "/place.php?whichplace=town_wrong",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Three free fights: Attack, spell, and pickpocket respectively for elixirs." }),
        path.name === "Gelatinous Noob" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Equipment choice unimportant." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          path.name !== "Gelatinous Noob" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Strong,
                {
                  color: primestat === $stat`Muscle` && inRun() && myLevel() < 13 ? "green.solid" : void 0,
                  children: "Eardigan"
                }
              ),
              " ",
              "(+25% muscle exp, +25 ML)."
            ] }),
            path.name !== "G-Lover" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Strong,
                {
                  color: primestat === $stat`Mysticality` && inRun() && myLevel() < 13 ? "green.solid" : void 0,
                  children: "Epaulettes"
                }
              ),
              " ",
              "(+25% myst exp)."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Strong,
                {
                  color: primestat === $stat`Moxie` && inRun() && myLevel() < 13 || !inRun() || myLevel() >= 13 ? "green.solid" : void 0,
                  children: "Earrings"
                }
              ),
              " ",
              "(+25% moxie exp, +50% meat, +3 all res)."
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "50-turn buff:" }),
            " ",
            commaOr([
              path !== $path`G-Lover` && "+10 stats/fight",
              "+10 familiar weight",
              "+50% item"
            ]),
            "."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Useful item:" }),
            " ",
            commaOr([
              path !== $path`Live. Ascend. Repeat.` && "enamorang (wandering copier)",
              "chocolate (adventures)",
              haveUnrestricted($familiar`Space Jellyfish`) && "toast (jelly)"
            ]),
            "."
          ] })
        ] })
      ]
    }
  );
};
const VotingBooth = () => {
  const iVotedSticker = $item`"I Voted!" sticker`;
  const canVote = isUnrestricted(iVotedSticker) && (get$1("voteAlways") || get$1("_voteToday"));
  const haveSticker = haveUnrestricted(iVotedSticker);
  const votingMonster = get$1("_voteMonster");
  const voteFreeFights = get$1("_voteFreeFights");
  const voteFreeFightsLeft = 3 - voteFreeFights;
  const currentTurns = totalTurnsPlayed();
  const turnsBeforeVoteFight = 11 - (currentTurns % 11 - 1 + 11) % 11;
  const voteFightNow = currentTurns % 11 === 1 && get$1("lastVoteMonsterTurn") < currentTurns;
  const macrometeoriteUses = get$1("_macrometeoriteUses");
  const barrelOfGunpowder = $item`barrel of gunpowder`;
  const lighthouseComplete = get$1("questL12War") === "finished" || get$1("sidequestLighthouseCompleted") !== "none";
  const canDoLFMTrick = haveSticker && !lighthouseComplete && availableAmount(barrelOfGunpowder) < 5 && voteFreeFightsLeft <= 0 && voteFightNow && have$b($skill`Meteor Lore`) && macrometeoriteUses < 10 && getCounter("portscan.edu") !== 0 && canAdventure($location`Sonofa Beach`);
  useNag(
    () => ({
      id: "voting-monster-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: `/images/adventureimages/${(votingMonster == null ? void 0 : votingMonster.image) ?? ""}`,
      node: haveSticker && votingMonster && voteFreeFightsLeft > 0 && voteFightNow && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: `Fight ${votingMonster.name}`,
          imageUrl: `/images/adventureimages/${votingMonster.image}`,
          href: equippedAmount(iVotedSticker) === 0 ? "inventory.php?ftext=i+voted!" : void 0,
          children: [
            equippedAmount(iVotedSticker) === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Equip the I Voted! sticker first." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Free fight that burns delay. ",
              plural(voteFreeFightsLeft, "fight"),
              " ",
              "left."
            ] })
          ]
        }
      )
    }),
    [
      votingMonster,
      haveSticker,
      voteFreeFightsLeft,
      voteFightNow,
      iVotedSticker
    ]
  );
  useNag(
    () => ({
      id: "voting-lfm-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/vrform.gif",
      node: canDoLFMTrick && votingMonster && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: "Lobsterfrogman Voting Macrometeorite Trick",
          imageUrl: "/images/itemimages/vrform.gif",
          href: equippedAmount(iVotedSticker) === 0 ? "inventory.php?ftext=i+voted!" : void 0,
          children: [
            equippedAmount(iVotedSticker) === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Equip the I Voted! sticker first." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Adventure in the Sonofa Beach, macrometeorite the",
              " ",
              votingMonster.name,
              ", and you'll get a Lobsterfrogman."
            ] })
          ]
        }
      )
    }),
    [canDoLFMTrick, iVotedSticker, votingMonster]
  );
  if (!canVote && !haveSticker) return null;
  if (haveSticker && voteFreeFightsLeft === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Voting Booth",
      imageUrl: "/images/itemimages/vrform.gif",
      linkedContent: haveSticker ? iVotedSticker : void 0,
      href: !haveSticker ? "/place.php?whichplace=town_right&action=townright_vote" : void 0,
      children: [
        !haveSticker && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Vote! Gives special modifiers, and unlocks three free fights to burn delay." }),
        voteFreeFightsLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Voting monster appears in ",
          plural(turnsBeforeVoteFight, "turn"),
          ".",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AdviceTooltipIcon,
            {
              advice: `${plural(voteFreeFightsLeft, "free fight")} remaining.`
            }
          )
        ] })
      ]
    }
  );
};
const ClanFortune = () => {
  const clanCarnivalGame = $item`Clan Carnival Game`;
  const usedBuff = get$1("_clanFortuneBuffUsed");
  const consultUses = get$1("_clanFortuneConsultUses");
  const path = myPath();
  const isGLover = path === $path`G-Lover`;
  if (!haveUnrestricted($item`Clan VIP Lounge key`) || !isUnrestricted(clanCarnivalGame) || usedBuff && consultUses >= 3) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Fortune Teller",
      imageUrl: "/images/adventureimages/madamezatara.gif",
      href: "/clan_viplounge.php?preaction=lovetester",
      children: [
        !usedBuff && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Susie:" }),
            " +5 familiar weight, +familiar experience."
          ] }),
          !isGLover && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Hagnk:" }),
              " +50% item/booze/food."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Meatsmith:" }),
              " +100% meat, +50% gear drop."
            ] })
          ] }),
          inRun() && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            (myPrimestat() === $stat`Muscle` || path === $path`Community Service`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Gunther:" }),
              " +5 muscle stats/fight, +100% muscle, +50% HP."
            ] }),
            (myPrimestat() === $stat`Mysticality` || path === $path`Community Service`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Gorgonzola:" }),
              " +5 myst stats/fight, +100% myst, +50% MP."
            ] }),
            !isGLover && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Shifty:" }),
              " +5 moxie stats/fight, +100% moxie, +50% init."
            ] })
          ] })
        ] }),
        consultUses < 3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(3 - consultUses, "fortune clan consult"),
          " remaining."
        ] })
      ]
    }
  );
};
const KramcoSausageOMatic = () => {
  const replicaKramcoSausageOMatic = $item`replica Kramco Sausage-o-Matic`;
  const kramcoSausageOMatic = have$b(replicaKramcoSausageOMatic) ? replicaKramcoSausageOMatic : $item`Kramco Sausage-o-Matic`;
  const haveKramco = haveUnrestricted(kramcoSausageOMatic);
  const magicalSausageCasing = $item`magical sausage casing`;
  const magicalSausage = $item`magical sausage`;
  const path = myPath();
  const probabilityOfSausageFight = getKramcoWandererChance();
  const lastTurn = get$1("_lastSausageMonsterTurn");
  const turnsToNextGuaranteedFight = Math.round(
    1 / probabilityOfSausageFight * (1 + totalTurnsPlayed() - (lastTurn || totalTurnsPlayed()))
  );
  const kramcosEquipped = haveEquipped(kramcoSausageOMatic);
  const fightsToday = get$1("_sausageFights");
  const sausageCasings = availableAmount(magicalSausageCasing);
  const sausagesEaten = get$1("_sausagesEaten");
  const sausagesAvailable = availableAmount(magicalSausage);
  const possibleSausages = sausagesAvailable + sausageCasings;
  const sausagesMade = get$1("_sausagesMade");
  const meatCost = 111 * (sausagesMade + 1);
  useNag(
    () => ({
      id: "kramco-sausage-goblin-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/saugrinder.gif",
      node: haveKramco && path !== $path`Live. Ascend. Repeat.` && probabilityOfSausageFight >= 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: `Fight ${ordinal(fightsToday + 1)} sausage goblin`,
          id: "kramco-sausage-goblin-nag",
          linkedContent: kramcoSausageOMatic,
          children: !kramcosEquipped ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "red.solid", command: "equip Kramco Sausage-o-Matic", children: [
            "Equip the Kramco Sausage-o-Matic first.",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipIcon, { advice: "Free fight that burns delay." })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Free fight that burns delay." })
        }
      )
    }),
    [
      haveKramco,
      path,
      probabilityOfSausageFight,
      fightsToday,
      kramcoSausageOMatic,
      kramcosEquipped
    ]
  );
  if (!haveKramco || path === $path`Live. Ascend. Repeat.`) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: probabilityOfSausageFight >= 1 ? "Sausage goblin fight now" : `${Math.round(probabilityOfSausageFight * 100)}% chance of Kramco fight`,
      linkedContent: kramcoSausageOMatic,
      href: inventoryActionLink("grind"),
      children: [
        !kramcosEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "Equip the Kramco Sausage-o-Matic first." }) }),
        turnsToNextGuaranteedFight > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(turnsToNextGuaranteedFight, "turn"),
          " until next guaranteed goblin fight."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Does not cost a turn; burns delay." }),
        fightsToday > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Fought ",
          plural(fightsToday, "goblin"),
          " so far."
        ] }),
        possibleSausages > 0 && sausagesEaten < 23 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
            plural(
              Math.min(sausagesAvailable, 23 - sausagesEaten),
              "magical sausage"
            ),
            " ",
            "edible."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "+1 adventure and +999 MP each." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: sausageCasings }),
            " casings available,",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
              sausagesEaten,
              "/23"
            ] }),
            " eaten today."
          ] }),
          sausagesMade > 22 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { color: "purple.solid", children: [
            sausagesMade,
            " sausages made today."
          ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            plural(sausagesMade, "sausage"),
            " made; next costs ",
            meatCost,
            " ",
            "meat."
          ] })
        ] })
      ]
    }
  );
};
const POCKETS = [
  {
    pocket: 343,
    needed: () => get$1("sidequestOrchardCompleted") !== "none",
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Filthworm Drone Stench (343):" }),
      " Stinky!"
    ] })
  },
  {
    pocket: 666,
    needed: () => true,
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Smut Orc Pervert (666):" }),
      " 5 bridge fasteners/lumber.",
      have$b($familiar`Grey Goose`) && " Use a goose drone to copy the box."
    ] })
  },
  {
    pocket: 533,
    needed: () => availableAmount($item`star chart`) === 0 && availableAmount($item`Richard's star key`) === 0,
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Greasy Desk Bell (533):" }),
      " Star key components."
    ] })
  },
  {
    pocket: 565,
    needed: () => !canAdventure($location`The eXtreme Slope`),
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Mountain Man (565):" }),
      " YR for 2x ore."
    ] })
  },
  {
    pocket: 589,
    needed: () => !canAdventure($location`The Battlefield (Frat Uniform)`),
    render: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Green Ops Soldier (589):" }),
      " Olfact for funny meme strategies."
    ] })
  }
];
const CargoCultistShorts = () => {
  const shortsPocketEmptied = get$1("_cargoPocketEmptied");
  const youHaveTheShorts = haveUnrestricted($item`Cargo Cultist Shorts`);
  const emptyPockets = get$1("cargoPocketsEmptied").split(",").map(Number);
  if (!youHaveTheShorts || shortsPocketEmptied) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Cargo Cultist Shorts",
      imageUrl: "/images/itemimages/cultistshorts.gif",
      href: "/inventory.php?action=pocket",
      linkEntireTile: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Pick a pocket for something useful!" }),
        myPath() !== $path`Community Service` && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: POCKETS.filter(
          ({ pocket, needed }) => needed() && !emptyPockets.includes(pocket)
        ).map(({ pocket, render }) => /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: render() }, pocket)) })
      ]
    }
  );
};
class MapTarget {
  constructor(monster, zone, level, access, turnsTilGROPs) {
    __publicField(this, "monster");
    __publicField(this, "zone");
    __publicField(this, "level");
    __publicField(this, "access");
    __publicField(this, "turnsTilGROPs");
    this.monster = monster;
    this.zone = zone;
    this.level = level;
    this.access = access ?? true;
    this.turnsTilGROPs = turnsTilGROPs ?? 0;
  }
  /**
   * Returns true/false depending on if you are at a level high enough to access this monster.
   * @param monster The monster in question
   */
  accessible() {
    return this.access && myLevel() > this.level;
  }
}
const MapTargetItem = ({ target }) => {
  if (!target.accessible()) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  if (target.monster === "Green Ops Soldier") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: `Green Ops Soldier ${target.turnsTilGROPs > 0 ? `(possible in ${plural(target.turnsTilGROPs, "war turn")})` : `@ ${target.zone}`}` }, target.monster);
  } else {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MainLink,
      {
        href: parentPlaceLink(Location.get(target.zone)),
        children: `${target.monster} @ ${target.zone}`
      }
    ) }, target.monster);
  }
};
const Cartography = () => {
  const _mapUses = 3 - get$1("_monstersMapped", 0);
  const lighthouseQuest = +(get$1("sidequestLighthouseCompleted") === "fratboy");
  const arenaQuest = +(get$1("sidequestArenaCompleted") === "fratboy");
  const junkyardQuest = +(get$1("sidequestJunkyardCompleted") === "fratboy");
  const orchardQuest = +(get$1("sidequestOrchardCompleted") === "fratboy");
  const nunsQuest = +(get$1("sidequestNunsCompleted") === "fratboy");
  const hippiesPerFight = Math.pow(
    2,
    nunsQuest + orchardQuest + junkyardQuest + arenaQuest + lighthouseQuest
  );
  const hippiesKilled = get$1("hippiesDefeated");
  const turnsToGROPs = Math.ceil(
    Math.max(401 - hippiesKilled, 0) / hippiesPerFight
  );
  const gropReqs = !(get$1("warProgress") === "finished");
  const healerReqs = !have$b($item`amulet of extreme plot significance`);
  const hitsReq = !(get$1("questL10Garbage") in ["step10", "finished"]);
  const zeppProgress = get$1("questL11Ron");
  const allMapTargets = [
    new MapTarget(
      "Green Ops Soldier",
      "The Battlefield",
      12,
      gropReqs,
      turnsToGROPs
    ),
    new MapTarget("Quiet Healer", "Penultimate Airship", 10, healerReqs),
    new MapTarget("Lobsterfrogman", "Sonofa Beach", 12, !junkyardQuest),
    new MapTarget("Astronomer", "The Hole in the Sky", 10, hitsReq),
    new MapTarget(
      "Red Butler",
      "The Red Zeppelin",
      11,
      zeppProgress in ["step2", "step3"]
    ),
    new MapTarget(
      "Lynyrd Skinner",
      "Mob of Zeppelin Protestors",
      11,
      zeppProgress in ["started", "step1"]
    ),
    new MapTarget("Forest Spirit", "Outskirts of Camp Logging Camp", 4)
  ];
  const recommendations = allMapTargets.filter((target) => target.accessible()).slice(0, 3);
  if (!haveUnrestricted($skill`Comprehensive Cartography`) || _mapUses === 3) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Cartography Compendium",
      imageUrl: "/images/itemimages/cccbook.gif",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          _mapUses,
          " maps remaining. Some map suggestions:"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: recommendations.slice(0, 3).map((recc) => /* @__PURE__ */ jsxRuntimeExports.jsx(MapTargetItem, { target: recc }, recc.monster)) })
      ]
    }
  );
};
const CommerceGhost = () => {
  const commerceGhostCombats = get$1("commerceGhostCombats");
  const commerceGhostItem = get$1("commerceGhostItem");
  const currentLevel = myLevel();
  const commerceGhostEquipped = myFamiliar() === $familiar`Ghost of Crimbo Commerce`;
  if (!haveUnrestricted($familiar`Ghost of Crimbo Commerce`) || currentLevel >= 12) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Ghost of Crimbo Commerce",
      imageUrl: "/images/itemimages/cghost_commerce.gif",
      children: [
        commerceGhostItem !== null ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Line,
          {
            href: `/mall.php?justitems=0&pudnuggler=%22${commerceGhostItem}%22`,
            children: [
              "Buy a ",
              commerceGhostItem.identifierString,
              " from the mall, then use the commerce ghost in a combat for ",
              20 * currentLevel,
              " -",
              " ",
              25 * currentLevel,
              " of each substat."
            ]
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "The commerce ghost will request a new item from the mall in",
          " ",
          10 - commerceGhostCombats,
          " combats."
        ] }),
        !commerceGhostEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/familiar.php", children: "Take the commerce ghost with you into combat to generate bonus stats." })
      ]
    }
  );
};
const SpitTargetItem = ({ userLevel, target }) => {
  if (!target.accessible(userLevel)) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ListItem,
    {
      children: `${target.monster} via ${target.zone}`
    },
    target.monster
  );
};
class SpitTarget {
  constructor(item2, monster, zone, level, access, spitQuality) {
    __publicField(this, "item");
    __publicField(this, "monster");
    __publicField(this, "zone");
    __publicField(this, "level");
    __publicField(this, "access");
    __publicField(this, "spitQuality");
    this.item = item2;
    this.monster = monster;
    this.zone = zone;
    this.level = level;
    this.access = access ?? true;
    this.spitQuality = spitQuality ?? 4;
  }
  // Instead of crazy canAdv type stuff, this just shows spits if you are at a level higher than the level the spit would become accessible and combines that with an access parameter that has been passed in.
  accessible(userLevel) {
    return this.access && userLevel > this.level;
  }
  // Small note regarding this class; yes, it's sparse, I know. I mostly like it
  //   as an example of how to do formatting within your recommendations, and think
  //   when we get to the point we can do tooltips within YORICK this construction
  //   will make it -much- easier to develop tooltips.
}
const Melodramedary = () => {
  const usingCamel = myFamiliar() === $familiar`Melodramedary`;
  const haveDrinkingHelmet = have$b($item`dromedary drinking helmet`);
  const equippedDrinkingHelmet = haveEquipped($item`dromedary drinking helmet`);
  const spitProgress = get$1("camelSpit") ?? 0;
  const userLevel = myLevel();
  const ascensionNumber = myAscensions() ?? 1;
  const hitsMonster = ascensionNumber % 2 === 0 ? "Camel's Toe" : "Skinflute";
  const nostalgiaUses = get$1("_feelNostalgicUsed");
  const bowlingRequirements = !(get$1("hiddenBowlingAlleyProgress") > 4);
  const gsbRequirements = !(get$1("warProgress") === "finished");
  const starKeyRequirements = get$1("questL10Garbage") in ["step10", "finished"];
  const gunpowderRequirements = get$1("sidequestLighthouseCompleted") === "none" && gsbRequirements;
  const evilEyeRequirements = !(get$1("cyrptNookEvilness") < 35);
  const mojoFilterRequirements = get$1("desertExploration") > 0;
  const allSpitTargets = [
    new SpitTarget(
      "Bowling Balls",
      "Pygmy Bowlers",
      "The Hidden Bowling Alley",
      11,
      bowlingRequirements
    ),
    new SpitTarget(
      "Green Smoke Bombs",
      "Green Ops Soldier",
      "The Battlefield",
      12,
      gsbRequirements
    ),
    new SpitTarget(
      "8 stars + 8 lines",
      hitsMonster,
      "The Hole in the Sky",
      10,
      starKeyRequirements
    ),
    new SpitTarget(
      "Barrels of Gunpowder",
      "Lobsterfrogman",
      "Sonofa Beach",
      12,
      gunpowderRequirements,
      2
    ),
    new SpitTarget(
      "Evil Eyes",
      "All non-partying Skeletons",
      "The Defiled Nook",
      7,
      evilEyeRequirements,
      2
    ),
    new SpitTarget(
      "Mojo Filters",
      "A Swarm of Scarab Beatles",
      "The Oasis",
      11,
      mojoFilterRequirements
    )
  ];
  const recommendations = allSpitTargets.filter((target) => target.accessible(userLevel)).slice(0, 3);
  const melodramedary = $familiar`Melodramedary`;
  if (!haveUnrestricted(melodramedary)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      linkedContent: melodramedary,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { direction: "row", width: "30px", mt: 1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TileImage,
          {
            imageUrl: "/images/otherimages/camelfam_left.gif",
            imageAlt: "Camel Left",
            height: "20px"
          }
        ),
        [
          ...new Array(
            Math.max(1, Math.floor(Math.sqrt(melodramedary.experience) / 5))
          ).keys()
        ].map((i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TileImage,
          {
            imageUrl: "/images/otherimages/camelfam_middle.gif",
            imageAlt: "Camel Middle",
            height: "20px",
            opacity: i > 1 ? 0.15 : 1
          },
          i
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TileImage,
          {
            imageUrl: "/images/otherimages/camelfam_right.gif",
            imageAlt: "Camel Right",
            height: "20px",
            opacity: 0.15
          }
        )
      ] }),
      children: [
        spitProgress < 100 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Current spit progress: ",
          spitProgress,
          "%."
        ] }),
        spitProgress < 100 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          Math.floor((100 - spitProgress) / (haveDrinkingHelmet ? 4.5 : 3)),
          " ",
          "combats until your next spit."
        ] }),
        spitProgress < 100 && usingCamel && haveDrinkingHelmet && !equippedDrinkingHelmet && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You have a drinking helmet, but it isn't equipped. Equip it, buddy!" }),
        spitProgress === 100 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { p: "1", m: "1", mb: "0", colorScheme: "purple", fontWeight: "bold", children: "Ready to Spit!" }) }),
        spitProgress === 100 && recommendations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: recommendations.slice(0, 2).map((recc) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          SpitTargetItem,
          {
            userLevel,
            target: recc
          },
          recc.monster
        )) }),
        spitProgress === 100 && nostalgiaUses < 3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(3 - nostalgiaUses, "use"),
          ' of "Feel Nostalgic" left. Consider using it!'
        ] })
      ]
    }
  );
};
const PowerfulGlove = () => {
  const batteryUsed = get$1("_powerfulGloveBatteryPowerUsed");
  if (!haveUnrestricted($item`Powerful Glove`) || batteryUsed === 100) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: "Powerful Glove",
      imageUrl: "/images/itemimages/pglove.gif",
      linkedContent: $item`Powerful Glove`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        100 - batteryUsed,
        "% charge",
        " ",
        batteryUsed <= 90 && /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray.solid", children: `(can replace ${plural(
          Math.floor((100 - batteryUsed) / 10),
          "monster"
        )})` }),
        "."
      ] })
    }
  );
};
const BackupCamera = () => {
  const _backUpUses = get$1("_backUpUses");
  const reverserStatus = get$1("backupCameraReverserEnabled");
  const cameraMode = get$1("backupCameraMode");
  const userLevel = myLevel();
  const modeToEnchantment = /* @__PURE__ */ new Map([
    ["meat", "+50% Meat"],
    ["ml", `+${Math.min(userLevel * 3, 50)} ML`],
    ["init", "+100% Initiative"]
  ]);
  if (!haveUnrestricted($item`backup camera`)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: $item`backup camera`, children: [
    _backUpUses < 11 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      plural(11 - _backUpUses, "backup"),
      " remaining today."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Currently set to ",
      modeToEnchantment.get(cameraMode),
      "."
    ] }),
    userLevel < 13 && cameraMode !== "ml" && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "backupcamera ml", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray.solid", children: "You aren't Level 13 yet; switch to ML?" }) }),
    !reverserStatus && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { command: "backupcamera reverser on", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "WARNING!" }),
      " ",
      "Reverser is off. Turn it on, or combats are backwards!"
    ] })
  ] });
};
const ColdMedicineCabinet = () => {
  const cmcInfo = getCMCInfo();
  if (!cmcInfo.available) return null;
  const needPoolCue = !haveUnrestricted($skill`Comprehensive Cartography`) && questStep("questM20Necklace") < 2;
  const pushTurns = [
    {
      name: "Billiards Room NC",
      location: $location`The Haunted Billiards Room`,
      available: canAdventure($location`The Haunted Billiards Room`),
      remaining: +needPoolCue && +!have$b($item`[7302]Spookyraven library key`)
    },
    {
      name: "Cobb's Knob unlock NC",
      location: $location`The Outskirts of Cobb's Knob`,
      available: questStep("questL05Goblin") === Step.STARTED,
      remaining: +(questStep("questL05Goblin") < 1)
    },
    {
      name: "Yeti fight",
      location: $location`Mist-Shrouded Peak`,
      available: pastNinjaSnowmen(),
      remaining: Math.max(0, 4 - yetiCount())
    },
    {
      name: "Hidden Temple unlock NC",
      location: $location`The Spooky Forest`,
      available: canAdventure($location`The Spooky Forest`),
      remaining: hiddenTempleInfo().ncsNeeded
    },
    {
      name: "Hidden City nostril NC",
      location: $location`The Hidden Temple`,
      available: canAdventure($location`The Hidden Temple`),
      remaining: +!have$b($item`the Nostril of the Serpent`)
    },
    {
      name: "Hidden City unlock turn",
      location: $location`The Hidden Temple`,
      available: canAdventure($location`The Hidden Temple`) && have$b($item`the Nostril of the Serpent`),
      remaining: questStep("questL11Worship") <= 2 ? 3 : 0
    },
    {
      name: "Hidden City zone unlock",
      location: $location`The Hidden Hospital`,
      available: questStep("questL11Worship") === 3 && haveMachete(),
      remaining: sum(
        [
          "questL11Curses",
          "questL11Business",
          "questL11Doctor",
          "questL11Spare"
        ],
        (pref) => +(questStep(pref) === Step.UNSTARTED)
      )
    },
    {
      name: "Zeppelin Mob clover NC",
      location: $location`A Mob of Zeppelin Protesters`,
      available: questStep("questL11Ron") >= Step.STARTED,
      remaining: Math.ceil(
        get$1("zeppelinProtestors") / (have$b($item`candy cane sword cane`) ? 40 : 20)
      )
    },
    {
      name: "War unlock NC",
      location: $location`Wartime Hippy Camp`,
      available: questStep("questL12War") === Step.STARTED && get$1("lastIslandUnlock") >= myAscensions(),
      remaining: +(questStep("questL12War") <= Step.STARTED)
    },
    {
      name: "Daily Dungeon chest",
      location: $location`The Daily Dungeon`,
      available: get$1("_lastDailyDungeonRoom") >= 14,
      remaining: +!get$1("dailyDungeonDone")
    },
    {
      name: "NC force",
      remaining: sum(FORCE_SOURCES, ({ remaining }) => remaining())
    }
  ];
  const pushTurnsRemaining = pushTurns.map(({ name, location, available: available2, remaining }) => {
    return {
      name,
      available: available2 === void 0 || available2,
      remaining,
      rendered: location ? /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: parentPlaceLink(location), children: plural(remaining, name) }) : plural(remaining, name)
    };
  }).filter(({ remaining }) => remaining > 0);
  const pushTurnsAvailable = pushTurnsRemaining.filter(
    ({ available: available2 }) => available2
  );
  const countPushTurnsAvailable = sum(
    pushTurnsAvailable,
    ({ remaining }) => remaining
  );
  const pushTurnsLater = pushTurnsRemaining.filter(
    ({ available: available2 }) => !available2
  );
  const countPushTurnsLater = sum(pushTurnsLater, ({ remaining }) => remaining);
  const cabinet = $item`cold medicine cabinet`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: cabinet, href: "/campground.php?action=workshed", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      5 - cmcInfo.consults,
      " consults available."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Next consult",
      " ",
      cmcInfo.turnsToConsult <= 0 ? "available now" : `in ${plural(cmcInfo.turnsToConsult, "turn")}`,
      "."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Current environments: ",
      cmcInfo.environments.join(""),
      "."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Next drop: ",
      cmcInfo.result,
      "."
    ] }),
    countPushTurnsAvailable > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        plural(countPushTurnsAvailable, "push turn"),
        " available."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: pushTurnsAvailable.map(({ name, rendered }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
        rendered,
        "."
      ] }, name)) })
    ] }),
    countPushTurnsLater > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      AdviceTooltipText,
      {
        advice: /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: pushTurnsLater.map(({ name, rendered }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
          rendered,
          "."
        ] }, name)) }),
        children: [
          plural(countPushTurnsLater, "push turn"),
          " later."
        ]
      }
    ) })
  ] });
};
const DaylightShavingsHelmet = () => {
  const yourBuffCycle = buffCycle();
  const buffsTilMeat = buffsUntil($effect`Friendly Chops`) ?? 0;
  const buffsTilItem = buffsUntil($effect`Spectacle Moustache`) ?? 0;
  const nextBuff$1 = nextBuff() ?? $effect`none`;
  if (!haveUnrestricted($item`Daylight Shavings Helmet`)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: $item`Daylight Shavings Helmet`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Your next buff is ",
      nextBuff$1.name,
      " (",
      yourBuffCycle.indexOf(nextBuff$1),
      "/12)"
    ] }),
    buffsTilMeat === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { color: "red.solid", children: "WARNING!" }),
      " Meat buff's up next! Only equip the helmet when you need it."
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "You are ",
      plural(buffsTilMeat, "buff"),
      " away from +100% meat drop (",
      plural(buffsTilMeat * 11, "turn"),
      ")."
    ] }),
    buffsTilItem === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "WARNING!" }),
      " ",
      "Item buff's up next! Only equip the helmet when you need it."
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "You are ",
      plural(buffsTilItem, "buff"),
      " away from +50% item drop (",
      plural(buffsTilItem * 11, "turn"),
      ")."
    ] })
  ] });
};
const EmotionChip = () => {
  const playerIsChipped = haveUnrestricted($skill`Emotionally Chipped`);
  const nostalgiaMonster = getProperty("lastCopyableMonster");
  const emoChipSkills = {
    "Lonely (NC)": 3 - get$1("_feelLonelyUsed"),
    "Peaceful (res)": 3 - get$1("_feelPeacefulUsed"),
    "Envy (all drops)": 3 - get$1("_feelEnvyUsed"),
    "Nostalgic (copy drops)": 3 - get$1("_feelNostalgicUsed"),
    "Pride (stats)": 3 - get$1("_feelPrideUsed")
  };
  const listItems = Object.entries(emoChipSkills).map(
    ([skillDescription, casts]) => {
      const text = `${plural(casts, "Feel")} ${skillDescription}${skillDescription === "Nostalgic (copy drops)" ? ` [${nostalgiaMonster}]` : ""}`;
      const skillName = `Feel ${skillDescription.split(" ")[0]}`;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        ListItem,
        {
          pl: 1,
          color: casts === 0 ? "fg.subtle" : void 0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ChevronsList,
              {
                usesLeft: casts,
                totalUses: 3,
                marginInlineEnd: 1
              }
            ),
            casts === 0 ? text : /* @__PURE__ */ jsxRuntimeExports.jsx(
              MainLink,
              {
                href: ["Feel Peaceful", "Feel Lonely"].includes(skillName) ? skillLink(skillName) : void 0,
                children: text
              }
            )
          ]
        },
        skillDescription
      );
    }
  );
  if (!playerIsChipped) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tile, { header: "Emotion Chip", imageUrl: "/images/itemimages/emochip1.gif", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { variant: "plain", children: listItems }) });
};
const IndustrialFireExtinguisher = () => {
  const fireExtinguisher = $item`industrial fire extinguisher`;
  const foam = get$1("_fireExtinguisherCharge");
  const knobUnfinished = questStep("questL05Goblin") < Step.FINISHED;
  const knobUnused = !get$1("fireExtinguisherHaremUsed");
  const hasPants = have$b($item`Knob Goblin harem pants`);
  const hasVeil = have$b($item`Knob Goblin harem veil`);
  const canVisitTheThrone = hasPants && hasVeil;
  const showKnob = questStep("questL05Goblin") > Step.UNSTARTED && !canVisitTheThrone && knobUnused && knobUnfinished;
  const bridgeUnfinished = questStep("questL09Topping") < 1;
  const blechUnused = !get$1("fireExtinguisherChasmUsed");
  const showBlech = questStep("questL09Topping") > Step.UNSTARTED && bridgeUnfinished && blechUnused;
  const batwallsUnfinished = questStep("questL04Bat") < 3;
  const batUnused = !get$1("fireExtinguisherBatHoleUsed");
  const showBat = questStep("questL04Bat") > Step.UNSTARTED && batwallsUnfinished && batUnused;
  const bonerUnready = [
    get$1("cyrptAlcoveEvilness"),
    get$1("cyrptCrannyEvilness"),
    get$1("cyrptNicheEvilness"),
    get$1("cyrptNookEvilness")
  ].some((evilness) => evilness > 25);
  const cyrptUnused = !get$1("fireExtinguisherCyrptUsed");
  const showCyrpt = questStep("questL07Cyrptic") > Step.UNSTARTED && bonerUnready && cyrptUnused;
  const desertIncomplete = get$1("desertExploration") < 100;
  const desertUnused = !get$1("fireExtinguisherDesertUsed");
  const showDesert = questStep("questL11Desert") > Step.UNSTARTED && desertIncomplete && desertUnused;
  if (!haveUnrestricted(fireExtinguisher) || foam <= 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: fireExtinguisher, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: `${foam} foam (${Math.floor(foam / 10)} polar
        vortices).` }),
    foam >= 20 && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
      showBat && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Constricted Blast" }),
        ": Unlock a Bat Hole chamber."
      ] }),
      showKnob && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Foam the Place" }),
        ": Obtain the Knob Harem Outfit."
      ] }),
      showCyrpt && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Replace the Chill" }),
        ": Reduce evil by 10 in a zone."
      ] }),
      showBlech && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Cool it Down" }),
        ": 73% Blech House progress."
      ] }),
      showDesert && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Take a Drink" }),
        ": 15 turns of Ultrahydrated."
      ] })
    ] })
  ] });
};
const UndergroundFireworksShop = () => {
  const _fireworksShopHatBought = get$1("_fireworksShopHatBought", false);
  const _fireworksShopEquipmentBought = get$1(
    "_fireworksShopEquipmentBought",
    false
  );
  const everythingLooksYellow = have$b($effect`Everything Looks Yellow`);
  const everythingLooksBlue = have$b($effect`Everything Looks Blue`);
  const everythingLooksRed = have$b($effect`Everything Looks Red`);
  const prices = {
    rockets: npcPrice($item`red rocket`),
    hats: npcPrice($item`fedora-mounted fountain`),
    equipment: npcPrice($item`Catherine Wheel`)
  };
  if (!get$1("_fireworksShop", false) || !isUnrestricted($item`clan underground fireworks shop`) || _fireworksShopHatBought && _fireworksShopEquipmentBought && everythingLooksYellow && everythingLooksBlue && everythingLooksRed) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Underground Fireworks Shop",
      imageUrl: "/images/itemimages/fwrocket2.gif",
      href: "/clan_viplounge.php?action=fwshop&whichfloor=2",
      linkEntireTile: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Buy a rocket for ",
          prices.rockets,
          " meat:",
          " ",
          commaOr(
            truthy([
              !everythingLooksYellow && "yellow (YR)",
              !everythingLooksBlue && "blue (restore MP)",
              !everythingLooksRed && "red (stats from food)"
            ])
          ),
          "."
        ] }),
        !_fireworksShopHatBought && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Buy a +combat, -combat, or +ML hat for ",
          prices.hats,
          " meat."
        ] }),
        !_fireworksShopEquipmentBought && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Buy a +item or +init equipment for ",
          prices.equipment,
          " meat."
        ] })
      ]
    }
  );
};
const H4 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h4", size: ["xs", "sm"], ...props });
const Autumnaton = () => {
  const autumnatonItem = $item`autumn-aton`;
  const haveAutumnatonItem = have$b(autumnatonItem);
  const hasAutumnaton = get$1("hasAutumnaton");
  const currentPath = myPath();
  const turncountWhereAutobotReturns = get$1("autumnatonQuestTurn");
  const autumnatonUpgrades = get$1("autumnatonUpgrades");
  const autumnatonQuestLocation = get$1("autumnatonQuestLocation");
  const autobotsReturnTime = turnsForQuest();
  useNag(
    () => ({
      id: "autumnaton-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/autumnaton.gif",
      node: haveAutumnatonItem && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Use your autumn-aton",
          imageUrl: "/images/itemimages/autumnaton.gif",
          href: inventoryUseLink(autumnatonItem),
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Next use will take",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { color: "red.solid", children: autobotsReturnTime }),
            " adventures."
          ] })
        }
      )
    }),
    [autobotsReturnTime, haveAutumnatonItem, autumnatonItem]
  );
  if (!hasAutumnaton || !isUnrestricted(autumnatonItem) || currentPath === $path`Legacy of Loathing` || currentPath.id === 37 || inBadMoon()) {
    return null;
  }
  const upgradesToGet = [];
  if (!autumnatonUpgrades.includes("cowcatcher")) {
    upgradesToGet.push(
      "Visit mid underground for +1 autumn item (Cyrpt zone, Daily Dungeon?)"
    );
  }
  if (!autumnatonUpgrades.includes("leftarm1")) {
    upgradesToGet.push("Visit low indoor for +1 item (Haunted Pantry?)");
  }
  if (!autumnatonUpgrades.includes("rightarm1")) {
    upgradesToGet.push(
      "Visit mid outdoor for +1 item (Vanya's Castle, Friars, Shadow Rift?)"
    );
  }
  if (!autumnatonUpgrades.includes("leftleg1")) {
    upgradesToGet.push("Visit low underground for -11 cooldown (Ratbats?)");
  }
  if (!autumnatonUpgrades.includes("rightleg1")) {
    upgradesToGet.push("Visit mid indoor for -11 cooldown (Haunted Library?)");
  }
  const potentialTargets = [];
  if (get$1("_inRunBool") && currentPath.id !== 25) {
    if (canAdventure($location`Sonofa Beach`) && get$1("sidequestLighthouseCompleted") === "none" && availableAmount($item`barrel of gunpowder`) < 5) {
      potentialTargets.push(["barrel of gunpowder", "Sonofa Beach"]);
    }
    if (!canAdventure($location`Twin Peak`) && get$1("chasmBridgeProgress") < 30) {
      potentialTargets.push(["bridge parts", "The Smut Orc Logging Camp"]);
    }
    if (get$1("hiddenBowlingAlleyProgress") + availableAmount($item`bowling ball`) < 6) {
      potentialTargets.push(["bowling balls", "The Hidden Bowling Alley"]);
    }
    if (get$1("twinPeakProgress") < 14 && availableAmount($item`jar of oil`) < 1 && availableAmount($item`bubblin' crude`) < 12) {
      potentialTargets.push(["bubblin' crude", "Oil Peak"]);
    }
    if (get$1("desertExploration") < 100 && availableAmount($item`killing jar`) < 1 && (get$1("gnasirProgress") & 4) === 0) {
      potentialTargets.push(["killing jar", "The Haunted Library"]);
    }
    if (canAdventure($location`The Oasis`) && get$1("desertExploration") < 100) {
      potentialTargets.push(["drum machine", "An Oasis"]);
    }
    if (questStep("questL11Ron") < 5) {
      potentialTargets.push(["glark cables", "The Red Zeppelin"]);
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Autumn-aton",
      imageUrl: "/images/itemimages/autumnaton.gif",
      href: inventoryUseLink(autumnatonItem),
      linkEntireTile: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Grabs items from a zone you've previously visited." }),
        have$b(autumnatonItem) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Next use will take",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", fontWeight: "bold", color: "red.solid", children: autobotsReturnTime }),
          " ",
          "adventures."
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Will return in",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { color: "red.solid", children: turncountWhereAutobotReturns + 1 - totalTurnsPlayed() }),
            " ",
            "adventures."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
            "Currently exploring: ",
            autumnatonQuestLocation == null ? void 0 : autumnatonQuestLocation.identifierString,
            "."
          ] }) })
        ] }),
        upgradesToGet.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: upgradesToGet.map((text) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: text }, text)) }),
        potentialTargets.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdviceTooltipText,
          {
            advice: /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { align: "start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(H4, { children: "Potential Targets" }),
              potentialTargets.map(([item2, location], index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ItemButtons, { linkedContent: $item`${item2}` }),
                " (",
                location,
                ")"
              ] }, `autumnaton-target-${index}`))
            ] }),
            children: "Potential Autumnaton Targets"
          }
        )
      ]
    }
  );
};
function getLocketEnchantment(phylum) {
  switch (phylum) {
    case "beast":
      return "+10% Crit Chance and +20 Muscle";
    case "bug":
      return "+25% Weapon Damage and +25% max MP";
    case "constellation":
      return "+10% Spell Crit and +20 Mysticality";
    case "construct":
      return "+3 Moxie exp and +25 Spell Damage";
    case "demon":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red", children: "+25 Hot" }),
        " and +50% Gear drops"
      ] });
    case "dude":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue", children: "+25 Cold" }),
        " and +50% Moxie"
      ] });
    case "elemental":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red", children: "+3 Hot res" }),
        " and ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.fg", children: "+25 Stench Spell" })
      ] });
    case "elf":
      return "+5 exp and +75% Candy drops";
    case "fish":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "+50% Meat Drops and ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray.solid", children: "+25 Spooky Spell" })
      ] });
    case "goblin":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.fg", children: "+25 Stench" }),
        " and +50% Mysticality"
      ] });
    case "hippy":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.fg", children: "+3 Stench res" }),
        " and +10 DR"
      ] });
    case "hobo":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "+3 Mysticality exp and ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red", children: "+25 Hot Spell" })
      ] });
    case "horror":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray.solid", children: "+3 Spooky res" }),
        " and +50 HP"
      ] });
    case "humanoid":
      return "+25% Spell Damage and +20 Moxie";
    case "mer-kin":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "+25% Item Drops and ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple.solid", children: "+25 Sleaze Spell" })
      ] });
    case "orc":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple.solid", children: "+3 Sleaze res" }),
        " and +25 MP"
      ] });
    case "penguin":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "+3 Muscle exp and ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue", children: "+25 Cold Spell" })
      ] });
    case "pirate":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "+50% Booze Drops and ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple.solid", children: "+25 Sleaze" })
      ] });
    case "plant":
      return "+50% Initiative and +50% max HP";
    case "slime":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue", children: "+3 Cold res" }),
        " and +50 DA"
      ] });
    case "undead":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray.solid", children: "+25 Spooky" }),
        " and +50% Muscle"
      ] });
    case "weird":
      return "+50% Food Drops and +25 Weapon Damage";
    default:
      return "";
  }
}
function getOptions() {
  if (!get$1("_inRun") || get$1("pathId") === "Community Service") {
    return [];
  }
  return [
    "Black crayon scalers, any phylum",
    "Frat warrior outfit, if no numberology",
    "Mountain man",
    "Ninja snowman assassin",
    "Swarm of ghuol whelps",
    "Sausage goblin",
    "Baa'baa'bu'ran",
    "Forest spirit (for a machete, with some free crafts)",
    "Astronomer OR camel's toe OR skinflute",
    "Lobsterfrogman",
    "Beanbat",
    "Dairy goat",
    "Blur",
    "Lynyrd skinner"
  ];
}
const CombatLoversLocket = () => {
  var _a2;
  const combatLoversLocket = $item`combat lover's locket`;
  if (!haveUnrestricted(combatLoversLocket)) {
    return null;
  }
  const locketPhylum = ((_a2 = get$1("locketPhylum")) == null ? void 0 : _a2.identifierString) ?? "none";
  const locketEnchantment = getLocketEnchantment(locketPhylum);
  const reminiscesLeft$1 = reminiscesLeft();
  const options = getOptions();
  return reminiscesLeft$1 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: plural(reminiscesLeft$1, "reminisce"),
      linkedContent: combatLoversLocket,
      href: "/inventory.php?reminisce=1",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Current enchantment: " }),
          locketPhylum,
          "."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "blue.solid", children: locketEnchantment }),
        options.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: option }, option)) })
      ]
    }
  );
};
const Cookbookbat = () => {
  const cookbookbat = $familiar`Cookbookbat`;
  const whey = $item`St. Sneaky Pete's Whey`;
  const veg = $item`Vegetable of Jarlsberg`;
  const yeast = $item`Yeast of Boris`;
  const wheyAmount = availableAmount(whey);
  const vegAmount = availableAmount(veg);
  const yeastAmount = availableAmount(yeast);
  const borisBreadCraftable = Math.floor(yeastAmount / 2);
  const roastedVegCraftable = Math.floor(vegAmount / 2);
  const focacciaCraftable = roastedVegCraftable > 0 && borisBreadCraftable > 0 ? Math.min(borisBreadCraftable, roastedVegCraftable) : 0;
  const allPizzasEaten = +get$1("deepDishOfLegendEaten") + +get$1("calzoneOfLegendEaten") + +get$1("pizzaOfLegendEaten") === 3;
  const freeCooksRemaining = clamp(5 - get$1("_cookbookbatCrafting"), 0, 5);
  const questMonster = get$1("_cookbookbatQuestMonster");
  const questLocation = get$1("_cookbookbatQuestLastLocation");
  const questIngredient = get$1("_cookbookbatQuestIngredient");
  const path = myPath();
  const daycount = myDaycount();
  const year = parseInt(todayToString().substring(0, 4));
  useNag(
    () => ({
      id: "cookbookbat-quest-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/bbat_fam.gif",
      // Only nag on quests in hardcore AG/2024 std - and only for 1-day attempts.
      node: questMonster !== null && !allPizzasEaten && year === 2024 && (path === $path`Avant Guard` || path === $path`Standard`) && daycount === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Cookbookbat Quest",
          linkedContent: cookbookbat,
          href: questLocation !== null ? parentPlaceLink(questLocation) : void 0,
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Fight ",
            questMonster.article || "a",
            " ",
            questMonster.identifierString,
            " (",
            questLocation == null ? void 0 : questLocation.identifierString,
            ") for ",
            questIngredient && plural(3, questIngredient),
            ". Reroll in",
            " ",
            plural(get$1("_cookbookbatCombatsUntilNewQuest"), "combat"),
            "."
          ] })
        }
      )
    }),
    [
      allPizzasEaten,
      cookbookbat,
      daycount,
      path,
      questIngredient,
      questLocation,
      questMonster,
      year
    ]
  );
  if (!haveUnrestricted(cookbookbat)) return null;
  if (myFullness() >= fullnessLimit()) return null;
  const ingredientsCharge = get$1("cookbookbatIngredientsCharge");
  const fightsUntilQuest = get$1("_cookbookbatCombatsUntilNewQuest");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Pizza party with the Cookbookbat!",
      linkedContent: cookbookbat,
      href: "/craft.php?mode=cook",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(11 - ingredientsCharge, "fight"),
          " until next ingredients drop."
        ] }),
        questMonster !== null && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Or fight a ",
          questMonster.identifierString,
          " in",
          " ",
          questLocation == null ? void 0 : questLocation.identifierString,
          " for",
          " ",
          questIngredient && plural(3, questIngredient),
          "."
        ] }),
        fightsUntilQuest > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(fightsUntilQuest, "fight"),
          " until next",
          questMonster && " (rerolled)",
          " quest."
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "New ingredient quest next turn." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkBlock, { href: "/craft.php?mode=cook", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "You currently have ",
            wheyAmount,
            " whey, ",
            vegAmount,
            " veg, and",
            " ",
            yeastAmount,
            " yeast. Make:"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
                borisBreadCraftable,
                "x Boris's Bread:"
              ] }),
              " +100% meat."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
                roastedVegCraftable,
                "x Roasted Vegetable of Jarlsberg:"
              ] }),
              " ",
              "+100% item."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
                focacciaCraftable,
                "x Roasted Vegetable Focaccia:"
              ] }),
              " ",
              "+10 fam XP."
            ] })
          ] })
        ] }),
        freeCooksRemaining > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(freeCooksRemaining, "free cook"),
          ": Unstable fulminate, potions, and more."
        ] })
      ]
    }
  );
};
const CosmicBowlingBall = () => {
  const returnCombats = get$1("cosmicBowlingBallReturnCombats");
  const youHaveTheBall = haveUnrestricted($item`cosmic bowling ball`);
  const currentZone = get$1("nextAdventure");
  useNag(
    () => ({
      id: "cosmic-bowling-ball-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/cosmicball2.gif",
      node: (youHaveTheBall || returnCombats === 1) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Cosmic Bowling Ball",
          id: "cosmic-bowling-ball-nag",
          imageUrl: "/images/itemimages/cosmicball2.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            youHaveTheBall ? "You have it!" : "Bowling ball back next combat!",
            " ",
            "Throw a curveball for a free run/banish."
          ] })
        }
      )
    }),
    [returnCombats, youHaveTheBall]
  );
  if (!youHaveTheBall && returnCombats < 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Cosmic Bowling Ball",
      imageUrl: "/images/itemimages/cosmicball2.gif",
      children: [
        currentZone === $location`The Hidden Bowling Alley` && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "teal.solid", fontWeight: "bold", children: "You're in the bowling alley; remember to bowl for pygmies!" }),
          " "
        ] }),
        youHaveTheBall && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", fontWeight: "bold", children: "You've got your bowling ball; throw it!" }),
          " "
        ] }),
        youHaveTheBall && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Curveball:" }),
            " Banish the monster, for free!"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Sideways:" }),
            " Gain ~ 1.5x stats within",
            " ",
            currentZone == null ? void 0 : currentZone.identifierString,
            "."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Straight Up:" }),
            " Gain +25% items / +50% meat."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "fg.subtle", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Backwards:" }),
            " Pickpocket from the rest of your current zone."
          ] })
        ] }),
        returnCombats > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Your Bowling Ball will return in",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: "Free runs count for this!", children: plural(returnCombats, "turn") }),
          "."
        ] }),
        returnCombats === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Your Bowling Ball will return at the start of the next combat!" })
      ]
    }
  );
};
const CursedMagnifyingGlass = () => {
  const cursedMagnifyingGlass = $item`cursed magnifying glass`;
  const haveCmg = haveUnrestricted(cursedMagnifyingGlass);
  const haveCmgEquipped = haveEquipped(cursedMagnifyingGlass);
  const voidFreeFights = get$1("_voidFreeFights");
  const cursedMagnifyingGlassCount = get$1("cursedMagnifyingGlassCount");
  const turnsToVoid = 13 - cursedMagnifyingGlassCount;
  useNag(
    () => ({
      id: "cursed-magnifying-glass-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/cursedmag.gif",
      node: haveCmg && voidFreeFights < 5 && turnsToVoid === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          linkedContent: cursedMagnifyingGlass,
          id: "cursed-magnifying-glass-nag",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: haveCmgEquipped ? "bold" : void 0, children: "Void monster fight now!" }),
            !haveCmgEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Equip cursed magnifying glass." })
          ]
        }
      )
    }),
    [
      cursedMagnifyingGlass,
      haveCmg,
      haveCmgEquipped,
      turnsToVoid,
      voidFreeFights
    ]
  );
  return null;
};
const LinkOrEquip = ({ href, children, ...props }) => !haveEquipped($item`designer sweatpants`) ? /* @__PURE__ */ jsxRuntimeExports.jsx(AsyncLink, { display: "inline", command: "equip designer sweatpants", ...props, children }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { display: "inline", href, ...props, children });
const DesignerSweatpants = () => {
  const designerSweatpants = $item`designer sweatpants`;
  const sweatOMeter = get$1("sweat");
  const boozeSweatsLeft = Math.max(3 - get$1("_sweatOutSomeBoozeUsed"), 0);
  if (!haveUnrestricted(designerSweatpants)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: `${sweatOMeter}% sweaty sweatpants`,
      id: "designer-sweatpants-tile",
      linkedContent: designerSweatpants,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkOrEquip, { href: skillLink($skill`Sweat Sip`), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Sweat Sip (5% sweat):" }),
          " Regain 50 MP"
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkOrEquip, { href: skillLink($skill`Drench Yourself in Sweat`), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Drench Yourself in Sweat (15% sweat):" }),
          " +100% Initiative"
        ] }) }),
        boozeSweatsLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(LinkOrEquip, { href: skillLink($skill`Sweat Out Some Booze`), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Sweat Out Some Booze (25% sweat):" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            LinkOrEquip,
            {
              href: skillLink($skill`Sweat Out Some Booze`),
              color: "orange.solid",
              children: [
                " ",
                "-1Drunkenness. ",
                plural(boozeSweatsLeft, "use"),
                " left for today.",
                myInebriety() === 0 && " Drink some booze first."
              ]
            }
          )
        ] })
      ] })
    }
  );
};
const GreyGoose = () => {
  const greyGoose = $familiar`Grey Goose`;
  const gooseDrones = get$1("gooseDronesRemaining");
  const gooseWeight = Math.min(Math.floor(Math.sqrt(greyGoose.experience)), 20);
  const gooseExperience = greyGoose.experience;
  const famExperienceGain = numericModifier("familiar experience") + 1;
  const famExpNeededForNextPound = (gooseWeight + 1) ** 2 - gooseExperience;
  const famExpNeededForTwoPounds = (gooseWeight + 2) ** 2 - gooseExperience;
  const horribleFamExpCalculation = Math.ceil(
    (36 - gooseExperience) / famExperienceGain
  );
  const horribleFamExpCalculationForGreyYou = Math.ceil(
    (196 - gooseExperience) / famExperienceGain
  );
  const horribleFamExpCalculationForStandard = Math.ceil(
    (400 - gooseExperience) / famExperienceGain
  );
  useNag(
    () => ({
      id: "grey-goose-nag",
      priority: NagPriority.ERROR,
      imageUrl: "/images/itemimages/greygoose.gif",
      node: gooseDrones > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { header: "GOOSO IS LIT", imageUrl: "/images/itemimages/greygoose.gif", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "brown", fontWeight: "bold", children: gooseDrones }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", color: "gray.solid", children: [
            " ",
            "GOOSO drones deployed."
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Automatically duplicates non-conditional drops." })
      ] })
    }),
    [gooseDrones]
  );
  useNag(
    () => ({
      id: "grey-goose-grey-you-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/greygoose.gif",
      node: myClass() === $class`Grey Goo` && gooseWeight > 5 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: "Re-Process Matter",
          imageUrl: "/images/itemimages/greygoose.gif",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "gray.solid", children: [
              "GOOSO is ",
              gooseWeight,
              " pounds (",
              gooseExperience,
              " exp)"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Re-Process a bunch of matter to gain a bunch of adventures in Grey You." })
          ]
        }
      )
    }),
    [gooseWeight, gooseExperience]
  );
  if (!haveUnrestricted(greyGoose)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: greyGoose, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: gooseExperience }),
      " experience, currently gain",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: famExperienceGain }),
      " per fight."
    ] }),
    gooseWeight < 6 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: Math.ceil(famExpNeededForNextPound / famExperienceGain) }),
      " ",
      "combats until next pound, or",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: Math.ceil(horribleFamExpCalculation) }),
      " combats for 6 weight."
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: famExpNeededForNextPound }),
        " xp needed for next pound, or ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: famExpNeededForTwoPounds }),
        " for the one after that."
      ] }),
      famExperienceGain < famExpNeededForNextPound && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Insufficient famxp for next fight." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        "Can emit ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: gooseWeight - 5 }),
        " drones to duplicate items."
      ] }),
      get$1("_meatifyMatterUsed") === false && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        "Can meatify matter for ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: (gooseWeight - 5) ** 4 }),
        " ",
        "meat."
      ] }),
      myClass() === $class`Grey Goo` && gooseWeight > 5 && myLevel() < 11 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Can generate ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: (gooseWeight - 5) ** 2 }),
          " mainstat."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
            "GREY YOU:",
            " ",
            Math.ceil(famExpNeededForNextPound / famExperienceGain)
          ] }),
          " ",
          "combats until next pound, or",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: Math.ceil(horribleFamExpCalculationForGreyYou) }),
          " ",
          "combats for 14 weight."
        ] })
      ] }) : gooseWeight > 5 && myLevel() < 11 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Can generate",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: Math.round(
            (gooseWeight - 5) ** 3 * (1 + numericModifier(
              `${myPrimestat()} Experience Percent`
            ) / 100)
          ) }),
          " ",
          "substats. (",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: (gooseWeight - 5) ** 3 }),
          " base)."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
            "STAT GOOSO:",
            " ",
            Math.ceil(famExpNeededForNextPound / famExperienceGain)
          ] }),
          " ",
          "combats until next pound, or",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: Math.ceil(horribleFamExpCalculationForStandard) }),
          " ",
          "combats for 20 weight."
        ] })
      ] }),
      !get$1("_questPartyFair") && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: famExperienceGain >= 39 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.solid", children: "Can GOOSO 3 drops per fight!" }) : famExperienceGain >= 24 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue.solid", children: "Can GOOSO 2 drops per fight!" }) : famExperienceGain >= 11 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple.solid", children: "Can GOOSO 1 drop per fight!" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "Cannot GOOSO any drops per fight!" }) })
    ] })
  ] });
};
const cleaverChoiceAdventures = [
  {
    choice: 1467,
    name: "Aunts not Ants",
    option1: "150 moxie substats",
    option2: "250 muscle substats",
    option3: "30 turns of Ashamed (+10 substats/fight, -20% Mus/Mys/Mox)"
  },
  {
    choice: 1468,
    name: "Bath Time",
    option1: "150 muscle substats, gob of wet hair",
    option2: "30 turns of Wholesomely Resolved (15 DR, +2 spooky/stench/sleaze res)",
    option3: "30 turns of Kinda Damp (+3 hot res, +50% init)"
  },
  {
    choice: 1469,
    name: "Beware of Aligator",
    option1: "30 turns of Yapping Pal (+20 ML)",
    option2: "Dad's Brandy (size 1 awesome booze)",
    option3: "1500 meat"
  },
  {
    choice: 1470,
    name: "Delicious Sprouts",
    option1: "250 mysticality substats",
    option2: "guilty sprout (size 1 food, red rocket for big stats)",
    option3: "250 muscle substats"
  },
  {
    choice: 1471,
    name: "Hypnotic Master",
    option1: "mother's necklace (+3 adv per day, never fumble, 5 free rests)",
    option2: "250 muscle substats",
    option3: "30 turns of of 2-5 random effects"
  },
  {
    choice: 1472,
    name: "Lost and Found",
    option1: "savings bond (potion, 30 turns of +50% meat)",
    option2: "3 turns of beaten up, 100 muscle substats, 250 meat",
    option3: "250 mysticality substats"
  },
  {
    choice: 1473,
    name: "Poetic Justice",
    option1: "250 moxie substats",
    option2: "125 mysticality substats",
    option3: "5 turns of beaten up, 5 adventures"
  },
  {
    choice: 1474,
    name: "Summer Days",
    option1: "trampled ticket stub (potion, 30 turns of 5% -com)",
    option2: "fire-roasted lake trout (size 1 good food, 50 turns of +3 cold res, +15 hot damage)",
    option3: "250 moxie substats"
  },
  {
    choice: 1475,
    name: "Teacher's Pet",
    option1: "30 turns of Teacher's Pet (+2 sleaze res, 50 DA, 5 DR)",
    option2: "teacher's pen (acc, +3 substats/fight, +2 fam exp)",
    option3: "125 muscle substats"
  }
];
const JuneCleaver = () => {
  const cleaver = $item`June cleaver`;
  const fightsLeft = get$1(`_juneCleaverFightsLeft`);
  const cleaverQueue = get$1(`juneCleaverQueue`).split(`,`).map((value) => parseInt(value));
  const skipsRemaining = 5 - get$1(`_juneCleaverSkips`);
  const availableChoices = cleaverChoiceAdventures.filter((entry) => !cleaverQueue.includes(entry.choice)).map(({ option1, option2, option3, name, choice }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdviceTooltipText,
      {
        advice: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", children: "Choices:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: option1 }, `${choice}_1`),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: option2 }, `${choice}_2`),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: option3 }, `${choice}_3`)
          ] })
        ] }),
        children: name
      }
    ) }, choice);
  });
  if (!haveUnrestricted(cleaver)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: cleaver, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      fightsLeft,
      " ",
      fightsLeft === 1 ? "combat" : "combats",
      " until the next June cleaver NC."
    ] }),
    skipsRemaining > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "You can skip ",
      skipsRemaining,
      " more cleaver",
      " ",
      skipsRemaining > 1 ? "NCs" : "NC",
      " today."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Possible upcoming NCs:" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: availableChoices })
  ] });
};
const JurassicParka = () => {
  const jurassicParka = $item`Jurassic Parka`;
  const haveParka = haveUnrestricted(jurassicParka);
  const parkaMode = get$1("parkaMode");
  const spikolodonSpikesLeft = clamp(5 - get$1("_spikolodonSpikeUses"), 0, 5);
  const parkaEquipped = haveEquipped(jurassicParka);
  const canEquipParka = canEquip(jurassicParka);
  const haveELY = have$b($effect`Everything Looks Yellow`);
  const haveFondeluge = have$b($skill`Fondeluge`);
  const inBadPath = $paths`Community Service, Avant Guard`.includes(myPath());
  useNag(
    () => ({
      id: "jurassic-parka-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/jparka3.gif",
      node: haveParka && canEquipParka && !inBadPath && !haveELY && !haveFondeluge && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: "Spit Jurassic Acid",
          linkedContent: jurassicParka,
          id: "jurassic-parka-nag",
          extraLinks: parkaMode === "dilophosaur" ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(AsyncButton, { command: "parka dilophosaur", children: "diloph" }),
          children: [
            !parkaEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Equip your Jurassic Parka!" }),
            parkaEquipped && (parkaMode === "dilophosaur" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "fg.success", children: "Free YR. Parka equipped." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", command: "parka dilophosaur", children: "Change your parka to dilophosaur mode!" }))
          ]
        }
      )
    }),
    [
      haveParka,
      canEquipParka,
      inBadPath,
      haveELY,
      haveFondeluge,
      jurassicParka,
      parkaMode,
      parkaEquipped
    ]
  );
  if (!haveParka || !canEquipParka) {
    return null;
  }
  const parkaEnchantment = (() => {
    switch (parkaMode) {
      case "kachungasaur":
        return "+100% HP, +50% meat, +2 Cold res.";
      case "dilophosaur":
        return "+20 Sleaze and Sleaze Spell, +2 Stench res, YR free kill.";
      case "spikolodon":
        return "+ML, +2 Sleaze res, NC forcing ability.";
      case "ghostasaurus":
        return "+10 DR, +50 MP, +2 Spooky res.";
      case "pterodactyl":
        return "-5% Combat, +50% Initiative, +2 Hot res.";
      default:
        return "";
    }
  })();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: `Jurassic Parka${parkaMode ? ` (${parkaMode})` : ""}`,
      id: "jurassic-parka-tile",
      linkedContent: jurassicParka,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "blue.solid", children: parkaEnchantment }),
        spikolodonSpikesLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { command: "parka spikolodon", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: spikolodonSpikesLeft }),
          " spikolodon spikes available."
        ] })
      ]
    }
  );
};
const MayDayPackage = () => {
  const mayDayPackage = $item`MayDay supply package`;
  if (!haveUnrestricted(mayDayPackage)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tile, { linkedContent: mayDayPackage, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use for 30 adventures of +100% initiative as well as useful seeded drops." }) });
};
const stationDescriptions = {
  unknown: {
    name: "Unknown",
    description: "We don't recognize that train station!"
  },
  empty: {
    name: "Empty station",
    description: "Train set isn't fully configured!"
  },
  meat_mine: {
    name: "Meat Mine",
    description: "Bonus meat"
  },
  tower_fizzy: {
    name: "Fizzy Tower",
    description: "MP regen"
  },
  viewing_platform: {
    name: "Viewing Platform",
    description: "Gain extra stats"
  },
  tower_frozen: {
    name: "Frozen Tower",
    description: "Hot res, Cold dmg"
  },
  spooky_graveyard: {
    name: "Spooky Graveyard",
    description: "Stench res, Spooky dmg"
  },
  logging_mill: {
    name: "Logging Mill",
    description: "Bridge parts or stats"
  },
  candy_factory: {
    name: "Candy Factory",
    description: "Pick up random candy"
  },
  coal_hopper: {
    name: "Coal Hopper",
    description: "Double power of next station"
  },
  tower_sewage: {
    name: "Sewage Tower",
    description: "Cold res, Stench dmg"
  },
  oil_refinery: {
    name: "Oil Refinery",
    description: "Spooky res, Sleaze dmg"
  },
  oil_bridge: {
    name: "Oil Bridge",
    description: "Sleaze res, Hot dmg"
  },
  water_bridge: {
    name: "Bridge Over Troubled Water",
    description: "Increase ML"
  },
  groin_silo: {
    name: "Groin Silo",
    description: "Gain moxie"
  },
  grain_silo: {
    name: "Grain Silo",
    description: "Get base booze"
  },
  brain_silo: {
    name: "Brain Silo",
    description: "Gain mysticality"
  },
  brawn_silo: {
    name: "Brawn Silo",
    description: "Gain muscle"
  },
  prawn_silo: {
    name: "Prawn Silo",
    description: "Acquire more food"
  },
  trackside_diner: {
    name: "Trackside Diner",
    description: "Serves the last food you found"
  },
  ore_hopper: {
    name: "Ore Hopper",
    description: "Get some ore"
  }
};
const ModelTrainSet = () => {
  const modelTrainSet = $item`model train set`;
  const imageUrl = "/images/itemimages/train.gif";
  const trainSetReconfigurableIn = () => {
    const trainPosition2 = get$1("trainsetPosition");
    const whenTrainsetWasConfigured = get$1("lastTrainsetConfiguration");
    if (whenTrainsetWasConfigured === trainPosition2 || trainPosition2 - whenTrainsetWasConfigured >= 40) {
      return 0;
    } else {
      return 40 - (trainPosition2 - whenTrainsetWasConfigured);
    }
  };
  const stationConfigured = (station) => {
    return get$1("trainsetConfiguration").includes(station);
  };
  const oreConfiguredWhenNotNeeded = () => {
    const oreConfigured = stationConfigured("ore_hopper");
    const oreNeeded = get$1("trapperOre");
    const haveAllOreNeeded = get$1("questL08Trapper") === "finished" || oreNeeded !== null && availableAmount(oreNeeded) >= 3 || availableAmount($item`asbestos ore`) >= 3 && availableAmount($item`chrome ore`) >= 3 && availableAmount($item`linoleum ore`) >= 3;
    return get$1("kingLiberated") === false && oreConfigured && haveAllOreNeeded;
  };
  const loggingMillConfiguredWhenNotNeeded = () => {
    const loggingMillConfigured = stationConfigured("logging_mill");
    const fastenersNeeded = get$1("chasmBridgeProgress") < 30 ? 30 - get$1("chasmBridgeProgress") : 0;
    const lumberNeeded = get$1("chasmBridgeProgress") < 30 ? 30 - get$1("chasmBridgeProgress") : 0;
    const haveAllPartsNeeded = get$1("chasmBridgeProgress") >= 30 || fastenersNeeded === 0 && lumberNeeded === 0;
    return get$1("kingLiberated") === false && loggingMillConfigured && haveAllPartsNeeded;
  };
  const statsConfiguredWhenNotNeeded = () => {
    const statsConfigured = stationConfigured("viewing_platform") || stationConfigured("brawn_silo") && myPrimestat() === $stat`Muscle` || stationConfigured("brain_silo") && myPrimestat() === $stat`Mysticality` || stationConfigured("groin_silo") && myPrimestat() === $stat`Moxie`;
    const haveAllStatsNeeded = myLevel() >= 13;
    return get$1("kingLiberated") === false && statsConfigured && haveAllStatsNeeded;
  };
  const shouldNag = trainSetReconfigurableIn() === 0 && (oreConfiguredWhenNotNeeded() || loggingMillConfiguredWhenNotNeeded() || statsConfiguredWhenNotNeeded() || stationConfigured("empty"));
  useNag(
    () => ({
      id: "model-train-set-nag",
      priority: NagPriority.LOW,
      imageUrl,
      node: shouldNag && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Reconfigure Model Train Set",
          imageUrl,
          href: "/campground.php?action=workshed",
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Your train set needs reconfiguring!" })
        }
      )
    }),
    [shouldNag]
  );
  if (!haveUnrestricted(modelTrainSet) || !isNormalCampgroundPath()) {
    return null;
  }
  const trainPosition = get$1("trainsetPosition");
  const stations = get$1("trainsetConfiguration").split(",");
  if (stations.length < 8) {
    if (have$b($item`model train set`)) {
      return get$1("_workshedItemUsed") ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Tile, { header: "Model Train Set", imageUrl, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/inventory.php?ftext=model+train+set", children: "Install your trainset." }) });
    } else {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Tile, { header: "Model Train Set", imageUrl, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: "/campground.php?action=workshed", children: "We can't tell how your trainset is configured. Click this tile to fix." }) });
    }
  }
  const reconfigurableIn = trainSetReconfigurableIn();
  const nextStation = stationDescriptions[stations[trainPosition % 8]];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { header: "Model Train Set", imageUrl, children: [
    oreConfiguredWhenNotNeeded() && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Have ore configured when it's not needed!" }),
    loggingMillConfiguredWhenNotNeeded() && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Have lumber mill configured when it's not needed!" }),
    statsConfiguredWhenNotNeeded() && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Have stats configured when they're not needed!" }),
    stationConfigured("empty") && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Have an empty station configured!" }),
    reconfigurableIn === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "blue.solid", href: "/campground.php?action=workshed", children: "Train set reconfigurable!" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Train set reconfigurable in",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: plural(reconfigurableIn, "combat") }),
      "."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Next station: ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: nextStation.name }),
      " -",
      " ",
      nextStation.description
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdviceTooltipText,
      {
        advice: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { textAlign: "center", pb: 1, children: "Train station cycle" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: Array.from({ length: 8 }, (_, i) => {
            const station = stationDescriptions[stations[(trainPosition + i) % 8]];
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: station.name }),
              ": ",
              station.description
            ] }, i);
          }) })
        ] }),
        children: "Full train cycle"
      }
    )
  ] });
};
const TinyStillsuit = () => {
  const tinyStillsuit = $item`tiny stillsuit`;
  const haveStillsuit = haveUnrestricted(tinyStillsuit);
  const haveStillsuitEquipped = haveEquipped(tinyStillsuit);
  const haveStillsuitInInventory = itemAmount(tinyStillsuit) > 0;
  const familiarSweat = get$1("familiarSweat");
  const sweatAdvs = Math.round(Math.pow(familiarSweat, 0.4));
  const getSweatCalcSweat = (sweat) => {
    if (sweat >= 358) return 449;
    if (sweat >= 279) return 358;
    if (sweat >= 211) return 279;
    if (sweat >= 155) return 211;
    if (sweat >= 108) return 155;
    if (sweat >= 71) return 108;
    if (sweat >= 43) return 71;
    if (sweat >= 23) return 43;
    if (sweat >= 10) return 23;
    return 10;
  };
  const sweatCalcSweat = getSweatCalcSweat(familiarSweat);
  const canGuzzleSweat = myInebriety() < inebrietyLimit();
  useNag(
    () => ({
      id: "tiny-stillsuit-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/stillsuit.gif",
      node: haveStillsuit && canGuzzleSweat && sweatAdvs >= 9 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: `${sweatAdvs} adv stillsuit sweat booze`,
          id: "tiny-stillsuit-nag",
          href: `/inventory.php?action=distill&pwd=${getHashIfAvailable()}`,
          imageUrl: "/images/itemimages/stillsuit.gif",
          children: [
            familiarSweat > 449 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { color: "red.solid", children: sweatAdvs }),
                " advs when guzzling now (costs 1 liver)."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You should probably guzzle your sweat now." })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
                familiarSweat,
                "/",
                sweatCalcSweat
              ] }),
              " ",
              "drams of stillsuit sweat for next adventure (",
              Math.ceil((sweatCalcSweat - familiarSweat) / 3),
              " combats on current familiar)."
            ] }),
            haveStillsuitEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "purple.solid", children: "Currently collecting sweat from current familiar!" }),
            !haveStillsuitEquipped && haveStillsuitInInventory && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Not collecting sweat from any familiar right now." }),
            !haveStillsuitEquipped && !haveStillsuitInInventory && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "fuchsia.solid", children: "Currently collecting sweat on a different familiar!" })
          ]
        }
      )
    }),
    [
      canGuzzleSweat,
      familiarSweat,
      haveStillsuit,
      haveStillsuitEquipped,
      haveStillsuitInInventory,
      sweatAdvs,
      sweatCalcSweat
    ]
  );
  const advDramsTable = {
    3: 10,
    4: 23,
    5: 43,
    6: 71,
    7: 108,
    8: 155,
    9: 211,
    10: 279,
    11: 358,
    12: 449,
    13: 553,
    14: 670,
    15: 801,
    16: 946,
    17: 1106,
    18: 1282
  };
  if (!haveStillsuit || !canGuzzleSweat) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: `${familiarSweat}/${sweatCalcSweat} drams of stillsuit sweat`,
      linkedContent: tinyStillsuit,
      href: `/inventory.php?action=distill&pwd=${getHashIfAvailable()}`,
      children: [
        familiarSweat > 358 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "11" }),
            " advs when guzzling now (costs 1 liver)."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You should probably guzzle your sweat now." })
        ] }) : familiarSweat > 10 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: sweatAdvs }),
            " advs when guzzling now (costs 1 liver)."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: sweatCalcSweat - familiarSweat }),
            " more sweat until +1 more adventure. (",
            Math.ceil((sweatCalcSweat - familiarSweat) / 3),
            " combats on current familiar)"
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Not enough sweat to guzzle." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: sweatCalcSweat - familiarSweat }),
            " more sweat until +1 more adventure. (",
            Math.ceil((sweatCalcSweat - familiarSweat) / 3),
            " combats on current familiar)"
          ] })
        ] }),
        haveStillsuitEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "purple.solid", children: "Currently collecting sweat from current familiar!" }),
        haveStillsuitInInventory && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Not collecting sweat from any familiar right now." }),
        !haveStillsuitEquipped && !haveStillsuitInInventory && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "fuchsia.solid", children: "Currently collecting sweat on a different familiar!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AdviceTooltipText,
            {
              advice: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
                Object.entries(advDramsTable).map(
                  ([advs, drams]) => drams > familiarSweat && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
                    advs,
                    " advs: ",
                    drams,
                    " drams (",
                    drams - familiarSweat,
                    " more sweat)"
                  ] }, advs)
                ),
                familiarSweat > 553 && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
                  " ",
                  "13 advs: ... y'know, you should probably just drink it, buddy."
                ] })
              ] }),
              children: "Sweat/Advs"
            }
          ),
          " ",
          "",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AdviceTooltipText,
            {
              advice: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Cubeling / Stomping Boots: +item" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Slimeing: +item, +food, +sleaze" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Levitating Potato / Candy Carnie / Flan: +item, +food" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Star Starfish / Emilio / Globmule / Waifuton: +item, +sleaze" })
              ] }),
              children: "Suggested Familiars"
            }
          )
        ] })
      ]
    }
  );
};
const UnbreakableUmbrella = () => {
  if (!haveUnrestricted($item`unbreakable umbrella`)) {
    return null;
  }
  const umbrellaMode = get$1("umbrellaState");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: $item`unbreakable umbrella`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Current Mode: ",
      umbrellaMode,
      "."
    ] }),
    myLevel() < 13 && umbrellaMode !== "broken" && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "umbrella broken", children: "Splaying it will increase ML by 25%." }),
    umbrellaMode !== "bucket style" && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "umbrella bucket", children: "Inverting it will increase item% by 25." }),
    umbrellaMode !== "cocoon" && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "umbrella cocoon", children: "Closing yourself inside will increase -combat% by 10." })
  ] });
};
const LEAFY_SUMMONS = [
  {
    leafCost: 37,
    summonedItem: "Autumnic Bomb",
    description: "potion; prismatic stinging (25 turns)",
    needed: () => !haveUnrestricted($familiar`Shorter-Order Cook`) && !haveUnrestricted($familiar`Imitation Crab`)
  },
  {
    leafCost: 50,
    summonedItem: "Distilled Resin",
    description: "potion; generate +1 leaf/fight (100 turns)"
  },
  {
    leafCost: 66,
    summonedItem: "Autumnal Aegis",
    description: "shield; +250 DA, +2 all res",
    needed: () => !have$b($skill`Tao of the Terrapin`) && !have$b($item`autumnal aegis`) && inRun()
  },
  {
    leafCost: 69,
    summonedItem: "Lit Leaf Lasso",
    description: "combat item; lasso leaf freebies for extra end-of-combat triggers",
    prefName: "_leafLassosCrafted"
  },
  {
    leafCost: 74,
    summonedItem: "Forest Canopy Bed",
    description: "bed; +5 free rests, stats via rests",
    needed: () => !getCampground()["forest canopy bed"]
  },
  {
    leafCost: 99,
    summonedItem: "Autumnic Balm",
    description: "potion; +2 all res (100 turns)"
  },
  {
    leafCost: 222,
    summonedItem: "Day Shortener",
    description: "spend 5 turns for a +turn item",
    prefName: "_leafDayShortenerCrafted",
    needed: () => !inRun()
  },
  {
    leafCost: 1111,
    summonedItem: "Coping Juice",
    description: "copium for the masses",
    needed: () => !inRun()
  },
  {
    leafCost: 6666,
    summonedItem: "Smoldering Leafcutter Ant Egg",
    description: "mosquito & leaves familiar",
    prefName: "_leafAntEggCrafted",
    needed: () => !inRun()
  },
  {
    leafCost: 11111,
    summonedItem: "Super-Heated Leaf",
    description: "burn leaves into your skiiiin",
    prefName: "_leafTattooCrafted",
    needed: () => !inRun()
  }
];
const LEAFY_FIGHTS = [
  {
    leafCost: 11,
    summonedMonster: "Flaming Leaflet",
    scaling: "11/11/11",
    leavesDropped: 4
  },
  {
    leafCost: 111,
    summonedMonster: "Flaming Monstera",
    scaling: "scaling",
    leavesDropped: 7,
    extraDrops: "leafy browns"
  },
  {
    leafCost: 666,
    summonedMonster: "Leaviathan",
    scaling: "scaling boss (hard!)",
    leavesDropped: 125,
    extraDrops: "flaming leaf crown",
    needed: () => !inRun() && !have$b($item`flaming leaf crown`)
  }
];
const AGuideToBurningLeaves = () => {
  const guideToLeaves = $item`A Guide to Burning Leaves`;
  const haveLeaves = haveUnrestricted(guideToLeaves);
  const haveCampground = isNormalCampgroundPath();
  const inflammableLeaf = $item`inflammable leaf`;
  const leafCount = availableAmount(inflammableLeaf);
  const fightsRemaining = Math.max(0, 5 - get$1("_leafMonstersFought"));
  const leafletsUserCanSummon = Math.floor(leafCount / 11);
  const haveResin = have$b($item`distilled resin`);
  const haveResined = have$b($effect`Resined`);
  useNag(
    () => ({
      id: "burning-leaves-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/al_resin.gif",
      node: haveLeaves && haveCampground && !haveResined && (haveResin || leafCount >= 50) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Get Resined",
          imageUrl: "/images/itemimages/al_resin.gif",
          href: haveResin ? inventoryLink($item`distilled resin`) : "/campground.php?preaction=leaves",
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Use distilled resin",
            !haveResin && " (50 leaves)",
            " to collect more leaves."
          ] })
        }
      )
    }),
    [haveCampground, haveLeaves, haveResin, haveResined, leafCount]
  );
  if (!haveLeaves || !haveCampground) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Burning Leaves",
      imageUrl: "/images/itemimages/al_book.gif",
      href: "/campground.php?preaction=leaves",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkBlock, { href: "/campground.php?preaction=leaves", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", children: "Item Summons:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: LEAFY_SUMMONS.map((summon) => {
            if (summon.needed && !summon.needed()) return null;
            const hasEnoughLeaves = leafCount >= summon.leafCost;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(
              ListItem,
              {
                color: hasEnoughLeaves ? "black" : "gray.solid",
                children: [
                  summon.leafCost,
                  " leaves: ",
                  summon.summonedItem,
                  " -",
                  " ",
                  summon.description,
                  summon.melting && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", fontSize: "xs", color: "gray.solid", children: [
                    " ",
                    "(melting)"
                  ] })
                ]
              },
              summon.summonedItem
            );
          }) })
        ] }),
        fightsRemaining > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkBlock, { href: "/campground.php?preaction=leaves", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", children: "Fight Summons:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: LEAFY_FIGHTS.map((fight) => {
              if (fight.needed && !fight.needed()) return null;
              const hasEnoughLeaves = leafCount >= fight.leafCost;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                ListItem,
                {
                  color: hasEnoughLeaves ? "black" : "gray.solid",
                  children: [
                    fight.leafCost,
                    " leaves: ",
                    fight.summonedMonster,
                    " -",
                    " ",
                    fight.scaling,
                    "; ~",
                    fight.leavesDropped,
                    " leaves dropped",
                    fight.extraDrops && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", fontSize: "xs", color: "gray.solid", children: [
                      " ",
                      "(also, drops ",
                      fight.extraDrops,
                      ")"
                    ] })
                  ]
                },
                fight.summonedMonster
              );
            }) })
          ] }),
          leafCount >= 111 * fightsRemaining ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            AdviceTooltipText,
            {
              advice: `You can summon ${fightsRemaining} monstera for scaling fights.`,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: `You have enough leaves for ${fightsRemaining} monstera.` })
            }
          ) : leafCount >= 11 * fightsRemaining ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            AdviceTooltipText,
            {
              advice: `You can summon ${fightsRemaining} leaflets for familiar turns.`,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: `You have enough leaves for ${fightsRemaining} leaflets.` })
            }
          ) : leafCount >= 11 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: "Save leaves for more fights!", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: `You can currently summon ${plural(leafletsUserCanSummon, "leaflet")}.` }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: "Save leaves for fights!", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You cannot currently summon a free fight." }) })
        ] })
      ]
    }
  );
};
const ALL_SKILLS = /* @__PURE__ */ new Map([
  [1, ["Mountain Climbing Day!", "a +adv buff"]],
  [2, ["Find an Eleven-Leaf Clover Day", "lucky!"]],
  [3, ["Watermelon Day!", "a watermelon"]],
  [4, ["Water Balloon Day!", "three water balloons"]],
  [5, ["Oyster Day!", "some oyster eggs"]],
  [6, ["Fresh Breath Day!", "a +com buff"]],
  [7, ["Lighthouse Day!", "an item/meat buff"]],
  [8, ["Cat Day!", "a catfight, meow"]],
  [9, ["Hand Holding Day!", "a foe's hand held"]],
  [10, ["World Lion Day!", "roars like a lion"]],
  [11, ["Presidential Joke Day!", "myst stats"]],
  [12, ["Elephant Day!", "mus stats"]],
  [13, ["Left/Off Hander's Day!", "double offhands"]],
  [14, ["Financial Awareness Day!", "bad meatgain"]],
  [15, ["Relaxation Day!", "a full heal"]],
  [16, ["Roller Coaster Day!", "-full & +food%"]],
  [17, ["Thriftshop Day!", "a 1000 meat coupon"]],
  [18, ["Serendipity Day!", "a bunch of items"]],
  [19, ["Honey Bee Awareness Day!", "stalked by bees"]],
  [20, ["Mosquito Day!", "HP regen"]],
  [21, ["Spumoni Day!", "stats of all kinds"]],
  [22, ["Tooth Fairy Day!", "a free tooth monster"]],
  [23, ["Ride the Wind Day!", "mox stats"]],
  [24, ["Waffle Day!", "three waffles"]],
  [25, ["Banana Split Day!", "a banana split"]],
  [26, ["Toilet Paper Day!", "some toilet paper"]],
  [27, ["Just Because Day!", "three random effects"]],
  [28, ["Race Your Mouse Day!", "a melting fam equip"]],
  [29, ["More Herbs, Less Salt Day!", "a food stat enhancer"]],
  [30, ["Beach Day!", "a +7 adv accessory"]],
  [31, ["Cabernet Sauvignon Day!", "two bottles of +booze% wine"]]
]);
const AugustScepter = () => {
  const augustScepter = $item`august scepter`;
  const skillsAvailable = 5 - get$1("_augSkillsCast");
  if (!have$b(augustScepter) || skillsAvailable < 1) return null;
  const buffString = /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", color: "gray.solid", children: [
    " ",
    "(buff)"
  ] });
  const mainstatAugustSkill = byStat({
    Muscle: 12,
    Mysticality: 11,
    Moxie: 23
  });
  const usefulAugustSkills = [];
  if (myLevel() < 13 && get$1("questL13Final") !== "finished") {
    const statsGained = Math.floor(
      50 * myLevel() * (1 + numericModifier(`${myPrimestat()} Experience Percent`) / 100)
    );
    usefulAugustSkills.push([mainstatAugustSkill, `+${statsGained} mainstat`]);
  }
  if (myPath() !== $path`Slow and Steady`) {
    if (availableAmount($item`goat cheese`) <= 2 && !haveUnrestricted($item`Mayam Calendar`) && questStep("questL08Trapper") < 2) {
      usefulAugustSkills.push([
        1,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          "+2-5 turns",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", fontSize: "xs", color: "gray.solid", children: "(spend turns @ the Goatlet)" })
        ] })
      ]);
    }
    usefulAugustSkills.push([
      30,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
        "+7 advs rollover accessory",
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", fontSize: "xs", color: "gray.solid", children: "(melting)" })
      ] })
    ]);
  }
  const manorCheck = questStep("questL11Manor") < 3 && get$1("manorDrawerCount") >= 21;
  const blastingAddendum = manorCheck && !have$b($item`blasting soda`) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", color: "gray.solid", children: [
    " ",
    "(blasting soda!)"
  ] }) : null;
  usefulAugustSkills.push([
    16,
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      "-1 fullness, +100% food drop",
      blastingAddendum
    ] })
  ]);
  if (manorCheck && !have$b($item`bottle of Chateau de Vinegar`)) {
    usefulAugustSkills.push([
      31,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "+100% booze drop wine",
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray.solid", children: "(chateau de vinegar!)" })
      ] })
    ]);
  }
  usefulAugustSkills.push([7, /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
    "+50% item, +100% meat",
    buffString
  ] })]);
  usefulAugustSkills.push([
    2,
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      "get",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.solid", children: "Lucky!" })
    ] })
  ]);
  usefulAugustSkills.push([24, "3 waffles, for monster replacement"]);
  usefulAugustSkills.push([22, "free fight for teeeeeeeeeeeth"]);
  if (questStep("questL08Trapper") < 2) {
    usefulAugustSkills.push([6, /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
      "+10% combat",
      buffString
    ] })]);
  }
  usefulAugustSkills.push([9, "hold hands for a minor sniff"]);
  usefulAugustSkills.push([
    10,
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
      "non-free reusable banishes",
      buffString
    ] })
  ]);
  const haveSleazeOffhand = have$b($item`deck of lewd playing cards`) || have$b($item`disturbing fanfic`);
  const protestorsRemaining = clamp(80 - get$1("zeppelinProtestors"), 0, 80);
  if (haveSleazeOffhand && protestorsRemaining > 10 || haveUnrestricted($item`unbreakable umbrella`)) {
    usefulAugustSkills.push([
      13,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
        "double offhand enchantments",
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple.solid", children: "(sleaze for protestors)" })
      ] })
    ]);
  }
  if (!have$b($item`toy Cupid bow`) && myFamiliar() !== $familiar`none`) {
    usefulAugustSkills.push([
      28,
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
        "+10 weight/+1 xp familiar equip",
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", fontSize: "xs", color: "gray.solid", children: "(melting)" })
      ] })
    ]);
  }
  const table = usefulAugustSkills.filter(([day]) => !get$1(`_aug${day}Cast`)).sort(([a], [b2]) => a - b2).map(([day, reason]) => {
    var _a2;
    const skillName = `Aug. ${ordinal(day)}: ${(_a2 = ALL_SKILLS.get(day)) == null ? void 0 : _a2[0]}`;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { px: 1, py: 0.5, children: day }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { px: 1, py: 0.5, children: skillName ? /* @__PURE__ */ jsxRuntimeExports.jsx(MainLink, { href: skillLink(skillName), children: reason }) : reason })
    ] }, day);
  });
  const tooltip = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { fontWeight: "bold", textAlign: "center", children: "Well, you asked for it!" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, { size: "sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: [...ALL_SKILLS.entries()].sort(([a], [b2]) => a - b2).map(([skillNumber, [, skillDesc]]) => {
      const lineColor = get$1(`_aug${skillNumber}Cast`) ? "gray.solid" : "black";
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            textAlign: "center",
            fontSize: ["2xs", "xs"],
            px: 1,
            py: 0,
            color: lineColor,
            children: skillNumber
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableCell,
          {
            fontSize: ["2xs", "xs"],
            px: 1,
            py: 0,
            color: lineColor,
            children: skillDesc
          }
        )
      ] }, skillNumber);
    }) }) })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: `Cast ${plural(skillsAvailable, "August Scepter skill")}`,
      id: "august-scepter-resource",
      imageUrl: "/images/itemimages/scepter.gif",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Celebrate August tidings; cast skills corresponding to the given day to get valuable benefits." }),
        table.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, { size: "sm", unstyled: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: table }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: tooltip, children: "No, YORICK, show me ALL the skills." })
      ]
    }
  );
};
const BookOfFacts = () => {
  const justTheFactsSkill = $skill`Just the Facts`;
  const habitatMonster = get$1("_monsterHabitatsMonster");
  const habitatMonsterName = habitatMonster == null ? void 0 : habitatMonster.name;
  const habitatMonsterPhylum = habitatMonster == null ? void 0 : habitatMonster.phylum;
  const fightsLeft = Math.max(
    0,
    Math.min(get$1("_monsterHabitatsFightsLeft"), 5)
  );
  const patrioticEagle = $familiar`Patriotic Eagle`;
  const eagleUsable = haveUnrestricted(patrioticEagle);
  const eaglePhylumBanished = get$1("banishedPhyla") !== "" ? Phylum.get(get$1("banishedPhyla").split(":")[0]) : null;
  const olfactionString = haveUnrestricted($skill`Transcendent Olfaction`) && get$1("_olfactionsUsed") < 3 && get$1("olfactedMonster") !== habitatMonster ? ", or olfact the monster" : "";
  const habitatMonsterBanished = habitatMonster && isBanished(habitatMonster);
  useNag(
    () => ({
      id: "book-of-facts-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/factbook.gif",
      node: habitatMonster && habitatMonsterName !== "none" && fightsLeft > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: `Fight ${plural(fightsLeft, `habitat ${habitatMonsterName}`)}`,
          id: "habitat-nag",
          imageUrl: "/images/itemimages/factbook.gif",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Appears as a wandering monster in any zone. Try a place with few competing monsters",
              olfactionString,
              ".",
              eagleUsable && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipIcon, { advice: "Remember, you can phylum-banish with your Patriotic Eagle to make it easier!" })
              ] })
            ] }),
            eaglePhylumBanished === habitatMonsterPhylum && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "red.solid", children: [
              "WARNING: ",
              habitatMonsterName,
              "'s phylum is banished!"
            ] }),
            habitatMonsterBanished && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "red.solid", children: [
              "WARNING: ",
              habitatMonsterName,
              " is banished!"
            ] })
          ]
        }
      ) : null
    }),
    [
      habitatMonster,
      habitatMonsterName,
      fightsLeft,
      olfactionString,
      eagleUsable,
      eaglePhylumBanished,
      habitatMonsterPhylum,
      habitatMonsterBanished
    ]
  );
  const circadianAdv = get$1("_circadianRhythmsAdventures");
  const circadianPhylum = get$1("_circadianRhythmsPhylum");
  const recallingCircadianRhythms = $effect`Recalling Circadian Rhythms`;
  useNag(
    () => ({
      id: "book-of-facts-circadian-rhythms-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/clock.gif",
      node: haveEffect(recallingCircadianRhythms) > 0 && circadianAdv < 10 && circadianPhylum ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Circadian Rhythms turngen",
          imageUrl: "/images/itemimages/clock.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Fight ",
            11 - circadianAdv,
            " more ",
            circadianPhylum.identifierString,
            "s to get RO advs."
          ] })
        }
      ) : null
    }),
    [circadianAdv, circadianPhylum, recallingCircadianRhythms]
  );
  const snowmanCrate = $item`X-32-F snowman crate`;
  const glitchItem = $item`[glitch season reward name]`;
  const witchessSet = $item`Witchess Set`;
  const neverendingPartyInvitation = $item`Neverending Party invitation envelope`;
  const closedCircuitPayPhone = $item`closed-circuit pay phone`;
  const constructDescriptor = `${haveUnrestricted(snowmanCrate) ? " + snojo" : ""}${have$b(glitchItem) ? " + glitch" : ""}`;
  const dudeDescriptor = `${haveUnrestricted(witchessSet) ? " + witchess" : ""}${haveUnrestricted(neverendingPartyInvitation) ? " + NEP" : ""}`;
  const horrorDescriptor = have$b(closedCircuitPayPhone) ? " + shadow rifts" : "";
  const circadianRhythmsRecalled = get$1("_circadianRhythmsRecalled");
  const habitatRecallsLeft = clamp(3 - get$1("_monsterHabitatsRecalled"), 0, 3);
  const bookOfFactsWishes = clamp(3 - get$1("_bookOfFactsWishes"), 0, 3);
  const springShoes = $item`spring shoes`;
  const romanCandelabra = $item`Roman Candelabra`;
  const bookOfFactsTatters = clamp(11 - get$1("_bookOfFactsTatters"), 0, 11);
  if (!haveUnrestricted(justTheFactsSkill)) {
    return null;
  }
  if (circadianRhythmsRecalled && habitatRecallsLeft === 0 && bookOfFactsWishes === 0 && (haveUnrestricted(springShoes) || !have$b(romanCandelabra) || bookOfFactsTatters === 0)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { header: "Book of Facts", imageUrl: "/images/itemimages/factbook.gif", children: [
    !circadianRhythmsRecalled && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Can recall Circadian Rhythms to get +11 RO adv." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        "Good targets: construct (nightstands",
        constructDescriptor,
        "), dudes (pygmies",
        dudeDescriptor,
        "), horrors (copied tentacles",
        horrorDescriptor,
        ")"
      ] })
    ] }),
    habitatRecallsLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        plural(habitatRecallsLeft, "Habitat recall"),
        " available."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Good targets include monsters you want 6 of:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Dirty old lihc, fantasy bandit, eldritch tentacle, black crayon orc if the stars align." })
    ] }),
    bookOfFactsWishes > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      plural(bookOfFactsWishes, "BOFA wish", "BOFA wishes"),
      " available."
    ] }),
    !haveUnrestricted(springShoes) && !have$b(romanCandelabra) && bookOfFactsTatters > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      plural(bookOfFactsTatters, "BOFA tatter"),
      " available."
    ] })
  ] });
};
const CandyCaneSwordCane = () => {
  const candyCaneSwordCane = $item`candy cane sword cane`;
  const haveCcsc = have$b(candyCaneSwordCane);
  const ccscEquipped = haveEquipped(candyCaneSwordCane);
  const inRun2 = get$1("kingLiberated") === false;
  const pathCheck = ![
    "Community Service",
    "Grey Goo",
    "Avatar of Boris"
  ].includes(myPath().name);
  const candyCaneSwordOptions = [
    {
      available: !get$1("_candyCaneSwordLyle"),
      node: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MainLink,
        {
          href: ccscEquipped ? "/place.php?whichplace=monorail&action=monorail_lyle" : void 0,
          children: "Bonus: Lyle's Monorail Buff (+40% init)."
        }
      ) }, "lyle"),
      location: null
    },
    {
      available: !get$1("candyCaneSwordBlackForest") && questStep("questL11Black") < 2,
      node: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Bonus: The Black Forest (+8 exploration)." }, "black"),
      location: $location`The Black Forest`
    },
    {
      available: !get$1("candyCaneSwordDailyDungeon") && !get$1("dailyDungeonDone"),
      node: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Bonus: Daily Dungeon (+1 fat loot token)." }, "daily"),
      location: $location`The Daily Dungeon`
    },
    {
      available: !get$1("candyCaneSwordApartmentBuilding") && get$1("hiddenApartmentProgress") < 8,
      node: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Bonus: Hidden Apartment (+1 Curse)." }, "apartment"),
      location: $location`The Hidden Apartment Building`
    },
    {
      available: !get$1("candyCaneSwordBowlingAlley") && get$1("hiddenBowlingAlleyProgress") < 7,
      node: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Bonus: Hidden Bowling Alley (+1 free bowl)." }, "bowl"),
      location: $location`The Hidden Bowling Alley`
    },
    {
      available: !get$1("candyCaneSwordShore") && get$1("lastIslandUnlock") < myAscensions(),
      node: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Alternate: Shore (2 scrips for the price of 1)." }, "shore"),
      location: $location`The Shore, Inc. Travel Agency`
    },
    {
      available: !$locations`Wartime Hippy Camp, Wartime Frat House`.some(
        (l2) => canAdventure(l2)
      ) && questStep("questL12War") < 1,
      node: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Alternate: Hippy Camp (Redirect to the War Start NC)." }, "hippy"),
      location: $location`Wartime Hippy Camp`
    },
    {
      available: get$1("zeppelinProtestors") < 80,
      node: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
        "Alternate: Zeppelin Protesters",
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple.solid", children: "(double Sleaze damage!)" }),
        "."
      ] }, "zeppelin"),
      location: $location`A Mob of Zeppelin Protesters`
    }
  ];
  const availableOptions = candyCaneSwordOptions.filter(
    ({ available: available2 }) => available2
  );
  const current = myLocation();
  const displayNag = availableOptions.some(
    ({ location }) => current === location
  );
  useNag(
    () => ({
      id: "candy-cane-sword-cane-nag",
      priority: NagPriority.ERROR,
      imageUrl: "/images/itemimages/ccsword.gif",
      node: haveCcsc && inRun2 && pathCheck && displayNag && /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { header: "Wear Your Candy", linkedContent: candyCaneSwordCane, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "You're" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.solid", children: "in a" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "candy" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.solid", children: "cane" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "sword" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.solid", children: "cane" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "noncom" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green.solid", children: "zone!" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: ccscEquipped ? "Keep your Candy Cane Sword Cane equipped!" : "Equip your Candy Cane Sword Cane!" })
      ] })
    }),
    [haveCcsc, inRun2, pathCheck, displayNag, candyCaneSwordCane, ccscEquipped]
  );
  if (!inRun2 || !pathCheck || availableOptions.length === 0) {
    return null;
  }
  return haveCcsc && inRun2 && pathCheck && /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Candy Cane Sword Cane NCs",
      linkedContent: candyCaneSwordCane,
      children: [
        !ccscEquipped ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Ensure your CCSC is equipped for useful NCs:" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "CCSC equipped! Useful NCs:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: availableOptions.map(({ node: node2 }) => node2) })
      ]
    }
  );
};
const CinchoDeMayo = () => {
  const cinchoDeMayo = $item`Cincho de Mayo`;
  if (!haveUnrestricted(cinchoDeMayo)) return null;
  const freeRests = get$1("timesRested");
  const freeRestsRemaining = totalFreeRests() - freeRests;
  const totalCinch = totalAvailableCinch();
  const possibleFiestaExits = Math.floor(totalCinch / 60);
  const additionalCinchSources = {};
  if (haveUnrestricted($item`June cleaver`) && !have$b($item`mother's necklace`)) {
    additionalCinchSources["mother's necklace"] = 25;
  }
  if (haveUnrestricted($item`Mayam Calendar`)) {
    const chairAvailable = remainingUses() > 0 && available("chair");
    const resetAvailable = get$1("lastTempleAdventures") < myAscensions();
    if (chairAvailable && resetAvailable) {
      additionalCinchSources["Mayam chair plus reset chair"] = 50;
    } else if (chairAvailable) {
      additionalCinchSources["Mayam chair"] = 25;
    } else if (resetAvailable) {
      additionalCinchSources["Mayam chair after reset"] = 25;
    }
  }
  if (have$3() && !haveInCampground($item`forest canopy bed`)) {
    additionalCinchSources[getDwelling() === $item`big rock` ? "forest canopy bed (need dwelling)" : "forest canopy bed"] = 25;
  }
  const additionalCinch = sumNumbers(Object.values(additionalCinchSources));
  const additionalFiestaExits = Math.floor((totalCinch + additionalCinch) / 60) - possibleFiestaExits;
  if (totalCinch === 0) return null;
  const url = totalCinch < 60 ? have$a() ? "/chateau.php" : "/campground.php" : "/skillz.php";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Cincho de Mayo",
      imageUrl: "/images/itemimages/cincho.gif",
      href: url,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Use your Cincho de Mayo to cast skills in exchange for cinch; when you're out of cinch, take a ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "free rest!?" })
        ] }),
        totalCinch > 60 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { color: "purple.solid", children: "Fiesta Exit (60%):" }),
          " Force a NC on your next adventure. You have ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: possibleFiestaExits }),
          " ",
          "more possible, with ",
          totalCinch % 60,
          "% cinch left over."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
          totalCinch > 25 && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Party Soundtrack (25%):" }),
            " 30 advs of +5 fam weight."
          ] }),
          totalCinch > 5 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Confetti Extravaganza (5%):" }),
              " 2x stats, in-combat"
            ] }),
            haveUnrestricted($skill`Sweet Synthesis`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Projectile Piata (5%):" }),
              " complex candy, in-combat"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "You have ",
          totalCinch,
          "% more cinch available, accounting for your",
          " ",
          plural(freeRestsRemaining, "remaining free rest"),
          "."
        ] }),
        Object.entries(additionalCinchSources).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Possible ",
          additionalCinch,
          "% more cinch from",
          " ",
          commaAnd(Object.keys(additionalCinchSources)),
          ",",
          additionalFiestaExits > 0 && ` giving ${plural(additionalFiestaExits, "more Party Exit")} and`,
          " ",
          "leaving ",
          (totalCinch + additionalCinch) % 60,
          "% left over."
        ] })
      ]
    }
  );
};
const ClosedCircuitPayPhone = () => {
  const closedCircuitPayPhone = $item`closed-circuit pay phone`;
  const havePayPhone = haveUnrestricted(closedCircuitPayPhone);
  const shadowLodestone = $item`Rufus's shadow lodestone`;
  const shadowAffinity = $effect`Shadow Affinity`;
  const rufusQuestState = get$1("questRufus");
  const questObjectiveFulfilled = rufusQuestState === "step1";
  const shadowLodestones = availableAmount(shadowLodestone);
  const riftAdvsUntilNC = get$1("encountersUntilSRChoice");
  const calledRufusToday = get$1("_shadowAffinityToday");
  const shadowAffinityTurns = haveEffect(shadowAffinity);
  const shadowBrickLocations = [
    {
      zoneName: "Cemetary",
      extraItems: "(also has bread, stick)",
      canAccess: canAdventure($location`Shadow Rift (The Misspelled Cemetary)`)
    },
    {
      zoneName: "Hidden City",
      extraItems: "(also has sinew, nectar)",
      canAccess: canAdventure($location`Shadow Rift (The Hidden City)`)
    },
    {
      zoneName: "Pyramid",
      extraItems: "(also has sausage, sinew)",
      canAccess: canAdventure(
        $location`Shadow Rift (The Ancient Buried Pyramid)`
      )
    }
  ];
  const getShadowBrickLocationTooltip = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: shadowBrickLocations.map((location, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Text,
      {
        color: location.canAccess ? "fg.muted" : "fg.subtle",
        fontWeight: "bold",
        children: [
          location.zoneName,
          " ",
          location.extraItems
        ]
      },
      index
    )) });
  };
  useNag(
    () => ({
      id: "closed-circuit-pay-phone-lodestone-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/rufusphone.gif",
      node: havePayPhone && questObjectiveFulfilled && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Rufus quest done",
          imageUrl: "/images/itemimages/rufusphone.gif",
          href: inventoryLink(closedCircuitPayPhone),
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Call Rufus and get a lodestone." })
        }
      )
    }),
    [havePayPhone, questObjectiveFulfilled, closedCircuitPayPhone]
  );
  useNag(
    () => ({
      id: "closed-circuit-pay-phone-shadow-rift-nc-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/shadowbucket.gif",
      node: havePayPhone && rufusQuestState === "started" && riftAdvsUntilNC === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Shadow Rift NC up next",
          imageUrl: "/images/itemimages/shadowbucket.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Fight a boss or get an artifact." })
        }
      )
    }),
    [havePayPhone, rufusQuestState, riftAdvsUntilNC]
  );
  useNag(
    () => ({
      id: "closed-circuit-pay-phone-shadow-affinity-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/shadowaffin.gif",
      node: shadowAffinityTurns > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: plural(shadowAffinityTurns, "Shadow Affinity turn"),
          id: "shadow-affinity-nag",
          imageUrl: "/images/itemimages/shadowaffin.gif",
          href: "/place.php?whichplace=cemetery",
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Adventure in a Shadow Rift." })
        }
      )
    }),
    [shadowAffinityTurns]
  );
  const haveLodestone = have$b($item`Rufus's shadow lodestone`);
  const haveShadowWaters = have$b($effect`Shadow Waters`);
  const atNuns = myLocation() === $location`The Themthar Hills`;
  useNag(
    () => ({
      id: "nuns-shadow-waters-nag",
      priority: NagPriority.ERROR,
      imageUrl: "/images/itemimages/shadowvenom.gif",
      node: atNuns && haveLodestone && !haveShadowWaters && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Get Shadow Waters",
          imageUrl: "/images/itemimages/shadowvenom.gif",
          href: "/plains.php",
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Use your lodestone to get Shadow Waters for +meat." })
        }
      )
    }),
    [atNuns, haveLodestone, haveShadowWaters]
  );
  if (!havePayPhone) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: closedCircuitPayPhone, children: [
      shadowLodestones > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", color: "purple.solid", children: [
        "Have ",
        plural(shadowLodestones, "shadow lodestone"),
        "."
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        riftAdvsUntilNC,
        " encounters until NC/boss."
      ] }),
      !calledRufusToday && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "blue.solid", children: "Haven't called Rufus yet today." }),
      calledRufusToday && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Optionally call Rufus again for another (turn-taking) quest." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: getShadowBrickLocationTooltip(), children: "Shadow Brick locations" })
    ] }),
    shadowAffinityTurns > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: `${shadowAffinityTurns} Shadow Rift free fights`,
        id: "shadow-rift-active-free-fights",
        imageUrl: "/images/adventureimages/voidguy.gif",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "purple.solid", children: "Shadow Rift fights are free!" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            riftAdvsUntilNC,
            " encounters until NC/boss."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "(don't use other free kills in there)" })
        ]
      }
    ),
    shadowLodestones > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tile,
      {
        header: `${shadowLodestones} Rufus's shadow lodestones`,
        id: "shadow-lodestone-tile",
        imageUrl: "/images/itemimages/shadowlode.gif",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "30 advs of +100% init, +100% item, +200% meat, -10% combat." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Triggers on next visit to any Shadow Rift." })
        ]
      }
    )
  ] });
};
function inRunItemWishes() {
  return [
    {
      target: $item`sonar-in-a-biscuit`,
      shouldDisplay: questStep("questL04Bat") !== 999 && !canAdventure($location`The Boss Bat's Lair`),
      currentlyAccessible: canAdventure($location`Guano Junction`)
    },
    {
      target: $item`enchanted bean`,
      shouldDisplay: !get$1("giantGrown") && !have$b($item`enchanted bean`),
      currentlyAccessible: canAdventure($location`The Beanbat Chamber`)
    },
    {
      target: $effect`Knob Goblin Perfume`,
      shouldDisplay: !questFinished("questL05Goblin") && !have$b($item`Knob Goblin perfume`),
      currentlyAccessible: true
    },
    {
      target: $item`Knob Goblin harem veil`,
      shouldDisplay: !questFinished("questL05Goblin") && !have$b($item`Knob Goblin harem veil`),
      currentlyAccessible: canAdventure($location`Cobb's Knob Harem`)
    },
    {
      target: $item`Knob Goblin harem pants`,
      shouldDisplay: !questFinished("questL05Goblin") && !have$b($item`Knob Goblin harem pants`),
      currentlyAccessible: canAdventure($location`Cobb's Knob Harem`)
    },
    {
      target: $item`stone wool`,
      shouldDisplay: !canAdventure($location`The Hidden Park`) && availableAmount($item`stone wool`) < 2,
      currentlyAccessible: canAdventure($location`The Hidden Temple`)
    },
    {
      target: $item`amulet of extreme plot significance`,
      shouldDisplay: !canAdventure(
        $location`The Castle in the Clouds in the Sky (Ground Floor)`
      ) && !have$b($item`amulet of extreme plot significance`),
      currentlyAccessible: canAdventure(
        $location`The Penultimate Fantasy Airship`
      )
    },
    {
      target: $item`Mohawk wig`,
      shouldDisplay: !questFinished("questL10Garbage") && !have$b($item`Mohawk wig`),
      currentlyAccessible: canAdventure(
        $location`The Penultimate Fantasy Airship`
      )
    },
    {
      target: $item`book of matches`,
      shouldDisplay: myAscensions() !== get$1("hiddenTavernUnlock") && !have$b($item`book of matches`),
      currentlyAccessible: canAdventure($location`The Hidden Park`)
    },
    {
      target: $item`rusty hedge trimmers`,
      shouldDisplay: get$1("twinPeakProgress") < 13,
      currentlyAccessible: canAdventure($location`Twin Peak`)
    },
    {
      target: $item`killing jar`,
      shouldDisplay: questStep("questL11Desert") < 2 && get$1("desertExploration") < 100 && !have$b($item`killing jar`),
      currentlyAccessible: canAdventure($location`The Haunted Library`)
    },
    {
      target: $effect`Dirty Pear`,
      additionalDescription: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple.solid", children: "double sleaze damage" }),
      shouldDisplay: get$1("zeppelinProtestors") < 80,
      currentlyAccessible: true
    },
    {
      target: $effect`Painted-On Bikini`,
      additionalDescription: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple.solid", children: "+100 sleaze damage" }),
      shouldDisplay: get$1("zeppelinProtestors") < 80,
      currentlyAccessible: true
    },
    {
      target: $item`glark cable`,
      shouldDisplay: questStep("questL11Ron") < 5,
      currentlyAccessible: canAdventure($location`The Red Zeppelin`)
    },
    {
      target: $item`short writ of habeas corpus`,
      shouldDisplay: !questFinished("questL11Spare"),
      currentlyAccessible: canAdventure($location`The Hidden Park`)
    },
    {
      target: $item`lion oil`,
      shouldDisplay: !have$b($item`Mega Gem`) && !have$b($item`lion oil`),
      currentlyAccessible: canAdventure($location`Whitey's Grove`)
    },
    {
      target: $item`bird rib`,
      shouldDisplay: !have$b($item`Mega Gem`) && !have$b($item`bird rib`),
      currentlyAccessible: canAdventure($location`Whitey's Grove`)
    },
    {
      target: $item`drum machine`,
      shouldDisplay: get$1("desertExploration") < 100 && !have$b($item`drum machine`),
      currentlyAccessible: canAdventure($location`The Oasis`)
    },
    {
      target: $item`shadow brick`,
      shouldDisplay: get$1("_shadowBricksUsed") + availableAmount($item`shadow brick`) < 13,
      currentlyAccessible: true
    },
    {
      target: $item`star chart`,
      shouldDisplay: !get$1("nsTowerDoorKeysUsed").includes("Richard's star key") && !have$b($item`Richard's star key`) && !have$b($item`star chart`),
      currentlyAccessible: canAdventure($location`The Hole in the Sky`)
    },
    {
      target: $item`lowercase N`,
      additionalDescription: "summon the nagamar",
      shouldDisplay: questStep("questL13Final") < 14 && !have$b($item`lowercase N`) && have$b($item`ruby W`) && have$b($item`metallic A`) && have$b($item`heavy D`),
      currentlyAccessible: canAdventure($location`The Valley of Rof L'm Fao`)
    }
  ];
}
function aftercoreWishes() {
  return [
    {
      target: $item`bag of foreign bribes`,
      shouldDisplay: canAdventure($location`The Ice Hotel`),
      currentlyAccessible: true
    }
  ];
}
function monkeySkills() {
  return [
    {
      fingerCount: 5,
      theSkill: $skill`Monkey Slap`,
      description: "killbanish"
    },
    { fingerCount: 4, theSkill: $skill`Monkey Tickle`, description: "delevel" },
    {
      fingerCount: 3,
      theSkill: $skill`Evil Monkey Eye`,
      description: "spooky delevel"
    },
    {
      fingerCount: 2,
      theSkill: $skill`Monkey Peace Sign`,
      description: "heal"
    },
    {
      fingerCount: 1,
      theSkill: $skill`Monkey Point`,
      description: "Olfaction-lite"
    }
  ];
}
function showWish({
  target,
  currentlyAccessible,
  additionalDescription
}) {
  const color = currentlyAccessible ? "black" : "gray.solid";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { color, children: [
    target.name,
    additionalDescription && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      ": ",
      additionalDescription
    ] })
  ] }, target.identifierString);
}
function showWishes(wishes2) {
  const currentWishes = wishes2.filter((wish) => wish.shouldDisplay && wish.currentlyAccessible).map(showWish);
  const futureWishes = wishes2.filter((wish) => wish.shouldDisplay && !wish.currentlyAccessible).map(showWish);
  return [...currentWishes, ...futureWishes];
}
const CursedMonkeysPaw = () => {
  const cursedMonkeysPaw = $item`cursed monkey's paw`;
  const monkeyWishesLeft = wishes();
  if (!haveUnrestricted(cursedMonkeysPaw) || monkeyWishesLeft === 0) {
    return null;
  }
  const options = inRun() ? showWishes([...inRunItemWishes(), ...inRunEffectWishes()]) : showWishes(aftercoreWishes());
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: plural(
        monkeyWishesLeft,
        "monkey's paw wish",
        "monkey's paw wishes"
      ),
      imageUrl: monkeyWishesLeft > 0 ? `/images/itemimages/monkeypaw${5 - monkeyWishesLeft}.gif` : void 0,
      linkedContent: cursedMonkeysPaw,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: mainActionLink("cmonk"), children: "Return to monke. Wish for items or effects." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: separate(
          [
            options.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: options }), children: "Possible Wishes" }),
            monkeyWishesLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              AdviceTooltipText,
              {
                advice: /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: monkeySkills().map((skill2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
                    plural(skill2.fingerCount, "finger", "fingers"),
                    ":"
                  ] }),
                  " ",
                  skill2.description
                ] }, skill2.fingerCount)) }),
                children: "Monkey Skills"
              }
            )
          ],
          "  ",
          [0, 1]
        ) }),
        monkeyWishesLeft === 5 && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Line,
          {
            href: !haveEquipped(cursedMonkeysPaw) ? inventoryLink(cursedMonkeysPaw) : void 0,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Monkey Slap:" }),
              " Turn-taking repeat-use banish. Lasts until you use it again!",
              !haveEquipped(cursedMonkeysPaw) && " Equip your cursed monkey paw first."
            ]
          }
        ) })
      ]
    }
  );
};
const JillOfAllTrades = () => {
  const jillOfAllTrades = $familiar`Jill-of-All-Trades`;
  const mapsDropped = get$1("_mapToACandyRichBlockDrops");
  const estimatedMapProbability = 35 * 0.05 ** clamp(mapsDropped, 0, 3);
  const turnsToMap = 1 / (estimatedMapProbability / 100);
  const habitatRecallsLeft = clamp(3 - get$1("_monsterHabitatsRecalled"), 0, 3);
  const haveBookOfFacts = haveUnrestricted($skill`Just the Facts`);
  const ledCandleDropped = get$1("ledCandleDropped");
  const haveLEDCandle = have$b($item`LED candle`);
  if (!haveUnrestricted(jillOfAllTrades)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: jillOfAllTrades, children: [
    mapsDropped === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "You haven't gotten a map to halloween town yet! Try using your Jill for a map at ~",
      round(estimatedMapProbability),
      "% chance, or approximately ",
      turnsToMap.toFixed(1),
      " turns."
    ] }),
    mapsDropped < 2 && mapsDropped > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "You have a map; the next map is at a ~",
      round(estimatedMapProbability),
      "% chance, or approximately ",
      turnsToMap.toFixed(1),
      " turns."
    ] }),
    habitatRecallsLeft > 0 && (have$b($skill`Just the Facts`) || haveBookOfFacts) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Halloween monsters make excellent targets for",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Recall Habitat" }),
      " from BoFA."
    ] }),
    !ledCandleDropped && !haveLEDCandle && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Fight a dude for an LED candle, to tune your Jill!" })
  ] });
};
const MrStore2002Catalog = () => {
  const have2002 = haveUnrestricted($item`2002 Mr. Store Catalog`);
  const spookyVHSTape = $item`Spooky VHS Tape`;
  const loathingIdolMicrophone = $item`Loathing Idol Microphone`;
  const flashLiquidizerUltraDousingAccessory = $item`Flash Liquidizer Ultra Dousing Accessory`;
  const proSkateboard = $item`pro skateboard`;
  const nextVHSTurn = get$1("spookyVHSTapeMonsterTurn") + 8;
  const nextVHSTimer = nextVHSTurn - totalTurnsPlayed();
  const imageName = get$1("spookyVHSTapeMonster");
  const mr2002Credits = get$1("availableMrStore2002Credits") + 3 * +!get$1("_2002MrStoreCreditsCollected");
  const availableVHSes = availableAmount(spookyVHSTape);
  const mcTwistUsed = get$1("_epicMcTwistUsed");
  const fludaDousesLeft = Math.max(3 - get$1("_douseFoeUses"), 0);
  const holidayTracker = getTodaysHolidayWanderers();
  const warnings = [];
  if (holidayTracker.length > 0) {
    warnings.push(
      "Be careful -- Borrachos & Feast of Boris wanderers can show up instead of your VHS wanderer."
    );
  }
  if (get$1("breathitinCharges") > 0) {
    warnings.push(
      "Breathitin is active; avoid putting your VHS wanderer outdoors, the wanderer is already free!"
    );
  }
  const vhsOptions = [
    "War monsters; especially GROPs",
    "Giant swarm of ghuol whelps",
    "Ninja snowman assassin",
    "Quiet Healer",
    "Burly Sidekick"
  ];
  const mcTwistOptions = [
    "a dairy goat",
    "a hedge trimmer monster",
    "an evil eye monster",
    "a Green Ops Soldier",
    "a tomb rat king"
  ];
  const fludaOptions = ["goat cheese", "filthworm sweat glands"];
  const vhsMonsterTurn = remoteCall(
    "getCounter",
    ["Spooky VHS Tape Monster"],
    -1
  );
  useNag(
    () => ({
      id: "2002-spooky-vhs-nag",
      priority: vhsMonsterTurn === 0 ? NagPriority.ERROR : NagPriority.LOW,
      imageUrl: "/images/itemimages/2002vhs.gif",
      node: vhsMonsterTurn >= 0 && vhsMonsterTurn <= 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: vhsMonsterTurn === 0 ? "Spooky VHS wanderer now!" : `Spooky VHS: ${plural(vhsMonsterTurn, "turn")}`,
          id: "2002-spooky-vhs-nag",
          imageUrl: "/images/itemimages/2002vhs.gif",
          children: [
            vhsMonsterTurn === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Adventure in a delay zone after 1 turn." }),
            vhsMonsterTurn === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Adventure in a delay zone now!" })
          ]
        }
      )
    }),
    [vhsMonsterTurn]
  );
  if (!have2002 || mr2002Credits <= 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "2002 Mr. Store",
      imageUrl: "/images/itemimages/2002catalog.gif",
      href: `/inv_use.php?pwd=${myHash()}&which=3&whichitem=${haveUnrestricted($item`Replica 2002 Mr. Store Catalog`) ? "11280" : "11257"}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          mr2002Credits,
          " 2002 Mr. Store credits."
        ] }),
        mr2002Credits > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
          !have$b(flashLiquidizerUltraDousingAccessory) && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Flash Liquidizer Ultra Dousing Accessory: +3 BLARTpockets" }),
          !have$b(proSkateboard) && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Pro skateboard: +1 duplicate" }),
          !have$b($item`Letter from Carrie Bradshaw`) && !have$b($item`red-soled high heels`) && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Letter from Carrie Bradshaw: +50% booze drop accessory" }),
          availableAmount(loathingIdolMicrophone) < 69420 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Loathing Idol Microphone: +100% init, +50% items, +5% combat; 4 uses" }),
          availableAmount(spookyVHSTape) < 69420 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "Spooky VHS Tape: wandering freekill YR of the monster you used it on; try GROPs!" })
        ] }) }),
        availableVHSes > 0 && haveUnrestricted(spookyVHSTape) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Have ",
            availableVHSes,
            " VHS tapes. Use to free-copy into delay & guarantee drops from:"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: vhsOptions.map((option, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: option }, index)) })
        ] }),
        have$b(loathingIdolMicrophone) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Have ",
          availableAmount(loathingIdolMicrophone),
          " Loathing Idol microphone uses. (50% item, 5% com, or 100% init.)"
        ] }),
        have$b(proSkateboard) && !mcTwistUsed && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Can Epic McTwist to double drops! Consider using on:",
          " ",
          mcTwistOptions.join(", "),
          "."
        ] }),
        have$b(flashLiquidizerUltraDousingAccessory) && fludaDousesLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Can waterpocket ",
          fludaDousesLeft,
          " more foes with FLUDA. Try stealing some ",
          fludaOptions.join(" or "),
          "."
        ] }),
        imageName && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: nextVHSTurn <= totalTurnsPlayed() ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", color: "red.solid", fontWeight: "bold", children: [
          "Spooky VHS: ",
          imageName.name,
          " now"
        ] }) : nextVHSTurn - 1 === totalTurnsPlayed() ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", color: "blue.solid", children: [
          "Spooky VHS: ",
          imageName.name,
          " in 1 more adv"
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdviceTooltipText,
          {
            advice: `${nextVHSTimer} adventures until your free fight YR VHS fight.`,
            children: `Spooky VHS: ${imageName}`
          }
        ) }),
        warnings.map((warning2, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "red.solid", children: [
          " ",
          warning2
        ] }, index))
      ]
    }
  );
};
const PLEDGE_ZONES = [
  {
    effect: "+30% item",
    locations: {
      "The Haunted Library": "Haunted Library",
      "The Haunted Laundry Room": "Haunted Laundry Room",
      "Whitey's Grove": "Whitey's Grove"
    }
  },
  {
    effect: "+50% meat",
    locations: {
      "Lair of the Ninja Snowmen": "Ninja Snowmen Lair",
      "The Hidden Hospital": "Hidden Hospital",
      "The Haunted Bathroom": "Haunted Bathroom",
      "The Oasis": "the Oasis"
    }
  },
  {
    effect: "+100% init",
    locations: {
      "The Haunted Kitchen": "Haunted Kitchen",
      "Oil Peak": "Oil Peak",
      "An Unusually Quiet Barroom Brawl": "Oliver's Tavern"
    }
  }
];
const PLEDGE_ZONES_ALL = {};
for (const { effect: effect2, locations } of PLEDGE_ZONES) {
  for (const [longName, shortName] of Object.entries(locations)) {
    PLEDGE_ZONES_ALL[longName] = [effect2, shortName];
  }
}
const generatePledgeZones = (locations, effect2) => {
  const available2 = locations.filter(
    ([loc]) => canAdventure($location`${loc}`)
  );
  return available2.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
      effect2,
      ":"
    ] }),
    " ",
    available2.map(([name]) => name).join(", ")
  ] }, effect2);
};
const generatePhylumOptions = (phylum, options) => {
  const available2 = options.filter(
    ([, loc, useful]) => canAdventure($location`${loc}`) && useful
  );
  return available2.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
      phylum,
      ":"
    ] }),
    " ",
    available2.map(([name]) => name).join(", ")
  ] }, phylum);
};
const PatrioticEagle = () => {
  const patrioticEagle = $familiar`Patriotic Eagle`;
  const haveEagle = haveUnrestricted(patrioticEagle);
  const withEagle = myFamiliar() === patrioticEagle;
  const rwbMonster = get$1("rwbMonster");
  const fightsLeft = Math.max(0, Math.min(get$1("rwbMonsterCount"), 2));
  const screechRecharge = get$1("screechCombats");
  const eaglePhylumBanished = Phylum.get(get$1("banishedPhyla").split(":")[0]);
  const citizenOfAZone = $effect`Citizen of a Zone`;
  const haveCitizen = have$b(citizenOfAZone);
  const canUseCitizen = !haveCitizen && canEquip(patrioticEagle) && myPath() !== $path`Avant Guard`;
  const location = myLocation();
  const pledgeZone = PLEDGE_ZONES_ALL[location.identifierString] ?? [];
  const [pledgeZoneEffect, pledgeZoneName] = pledgeZone;
  useNag(
    () => ({
      id: "patriotic-eagle-pledge-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/flag1.gif",
      node: haveEagle && canUseCitizen && pledgeZoneEffect && pledgeZoneName && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tile,
        {
          header: "Pledge to a zone?",
          imageUrl: "/images/itemimages/flag1.gif",
          linkedContent: patrioticEagle,
          children: [
            !withEagle && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "familiar Patriotic Eagle", children: "Take your Patriotic Eagle with you." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
              "Pledge allegiance to ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: pledgeZoneName }),
              " for",
              " ",
              pledgeZoneEffect,
              "."
            ] })
          ]
        }
      )
    }),
    [
      canUseCitizen,
      haveEagle,
      patrioticEagle,
      pledgeZoneEffect,
      pledgeZoneName,
      withEagle
    ]
  );
  if (!haveEagle) return null;
  const possibleAppearanceLocations = rwbMonster ? getMonsterLocations(rwbMonster).filter(
    (location2) => canAdventure(location2)
  ) : [];
  const pledgeZones = PLEDGE_ZONES.map(
    ({ effect: effect2, locations }) => generatePledgeZones(Object.entries(locations), effect2)
  );
  const phylumOptions = [
    generatePhylumOptions("Dude", [
      [
        "Black Forest (2/5)",
        "The Black Forest",
        questStep("questL11Black") < 2
      ],
      ["Twin Peak (5/8)", "Twin Peak", get$1("twinPeakProgress") < 15],
      ["Whitey's Grove (1/4)", "Whitey's Grove", true]
    ]),
    generatePhylumOptions("Beast", [
      [
        "Hidden Park (1/4)",
        "The Hidden Park",
        !have$b($item`antique machete`) && !have$b($item`muculent machete`)
      ],
      [
        "Palindome (3/7)",
        "Inside the Palindome",
        get$1("palindomeDudesDefeated") < 5
      ],
      [
        "Airship (2/7)",
        "The Penultimate Fantasy Airship",
        questStep("questL10Garbage") < 7
      ]
    ]),
    generatePhylumOptions("Construct", [
      ["Whitey's Grove (1/4)", "Whitey's Grove", true],
      [
        "Airship (1/7)",
        "The Penultimate Fantasy Airship",
        questStep("questL10Garbage") < 7
      ]
    ]),
    generatePhylumOptions("Undead", [
      [
        "Haunted Library (1/3)",
        "The Haunted Library",
        get$1("writingDesksDefeated") < 5
      ],
      ["Red Zeppelin (1/5)", "The Red Zeppelin", questStep("questL11Ron") < 4],
      [
        "Haunted Wine Cellar (1/3)",
        "The Haunted Wine Cellar",
        questStep("questL11Manor") < 3
      ],
      [
        "Haunted Boiler (1/3)",
        "The Haunted Boiler Room",
        questStep("questL11Manor") < 3
      ],
      [
        "Pyramid Middle (1/3)",
        "The Middle Chamber",
        !questFinished("questL11Pyramid")
      ]
    ])
  ];
  const showRwb = rwbMonster && rwbMonster !== $monster`none` && fightsLeft > 0;
  const showPhylum = phylumOptions.some((node2) => node2);
  const showPledge = !have$b(citizenOfAZone) && pledgeZones.some((node2) => node2);
  if (!showRwb && !showPhylum && !showPledge) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: patrioticEagle, children: [
    showRwb && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { fontWeight: "bold", children: [
        "Fight ",
        plural(fightsLeft, `more ${rwbMonster.identifierString}`)
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
        "Copied by your eagle's blast. Will appear when you adventure in",
        " ",
        possibleAppearanceLocations.join(", "),
        "."
      ] }),
      (rwbMonster == null ? void 0 : rwbMonster.phylum) === eaglePhylumBanished && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "red.solid", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "WARNING!" }),
        " This monster will not appear, it's banished by your eagle screech!"
      ] })
    ] }),
    showPhylum && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", children: screechRecharge > 0 ? `${screechRecharge} combats (or freeruns) until your Patriotic Eagle can screech again.` : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "Patriotic Eagle can screech and banish an entire phylum!",
        " ",
        screechRecharge === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "SCREEEE" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray.solid", children: "EEEEE" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue.solid", children: "EEEEE!" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: phylumOptions })
    ] }),
    showPledge && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { fontWeight: "bold", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "Pledge" }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray.solid", children: "allegiance" }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue.solid", children: "to a zone!" })
      ] }),
      pledgeZones
    ] })
  ] });
};
const gravelMessage = (gravels) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: gravels }),
    "x groveling gravel (free kill*)"
  ] });
};
const whetStoneMessage = (whetStones) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MainLink, { href: inventoryLink($item`whet stone`), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: whetStones }),
    "x whet stone (+1 adv on food)."
  ] });
};
const milestoneMessage = (milestones) => {
  const desertProgress = get$1("desertExploration");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MainLink, { href: inventoryLink($item`milestone`), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: milestones }),
    "x milestone (+5% desert progress),",
    " ",
    100 - desertProgress,
    "% remaining."
  ] });
};
const RockGarden = () => {
  const desertProgress = get$1("desertExploration");
  const gardenGravels = getCampground()["groveling gravel"];
  const gardenWhetStones = getCampground()["whet stone"];
  const gardenMilestones = desertProgress < 100 ? getCampground()["milestone"] : 0;
  const availableGravels = availableAmount($item`groveling gravel`);
  const availableWhetStones = availableAmount($item`whet stone`);
  const availableMilestones = desertProgress < 100 ? availableAmount($item`milestone`) : 0;
  const isCommunityService = get$1("challengePath") === "Community Service";
  const canAccess = canAccessGarden();
  if (isCommunityService || !canAccess || !inRun() || !getCampground()["packet of rock seeds"] || availableGravels + availableMilestones + availableWhetStones + gardenGravels + gardenMilestones + gardenWhetStones === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Rock Garden Resources",
      href: "/campground.php",
      imageUrl: "/images/itemimages/rockgardenbook.gif",
      children: [
        !get$1("_molehillMountainUsed") && have$b($item`molehill mountain`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink($item`molehill mountain`), children: "Molehill moleman: Free scaling fight." }),
        (availableGravels > 0 || availableWhetStones > 0 || availableMilestones > 0 && desertProgress < 100) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Inventory:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
            availableGravels > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: gravelMessage(availableGravels) }),
            availableWhetStones > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: whetStoneMessage(availableWhetStones) }),
            availableMilestones > 0 && desertProgress < 100 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: milestoneMessage(availableMilestones) })
          ] })
        ] }),
        (gardenGravels > 0 || gardenWhetStones > 0 || gardenMilestones > 0 && desertProgress < 100) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Harvest from your garden:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
            gardenGravels > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: gravelMessage(gardenGravels) }),
            gardenWhetStones > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: whetStoneMessage(gardenWhetStones) }),
            gardenMilestones > 0 && desertProgress < 100 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: milestoneMessage(gardenMilestones) })
          ] })
        ] })
      ]
    }
  );
};
const MISC_PHRASES = [
  "Don't play hooky!",
  "You already paid for it.",
  "This one time in college...",
  "Bright college days, oh, carefree days that fly.",
  "No child of mine is leaving here without a degree!",
  "Make like a tree and leaf (through your papers)."
];
const SITCertificate = () => {
  const sitCertificate = $item`S.I.T. Course Completion Certificate`;
  const haveSit = haveUnrestricted(sitCertificate);
  const currentlyInRun = inRun();
  const havePsychogeologist = have$b($skill`Psychogeologist`);
  const haveInsectologist = have$b($skill`Insectologist`);
  const haveCryptobotanist = have$b($skill`Cryptobotanist`);
  const hasAnySkill = havePsychogeologist || haveInsectologist || haveCryptobotanist;
  const randomPhrase = reactExports.useMemo(
    () => MISC_PHRASES[Math.floor(Math.random() * MISC_PHRASES.length)],
    []
  );
  useNag(
    () => ({
      id: "sit-course-certificate-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/sitcert.gif",
      node: haveSit && currentlyInRun && !hasAnySkill && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "S.I.T. Course Enrollment",
          imageUrl: "/images/itemimages/sitcert.gif",
          href: inventoryUseLink(sitCertificate),
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            randomPhrase,
            " Take your S.I.T. course!"
          ] })
        }
      )
    }),
    [currentlyInRun, hasAnySkill, haveSit, randomPhrase, sitCertificate]
  );
  return null;
};
const NONCOMBAT_ZONES = [
  $location`The Haunted Billiards Room`,
  $location`The Haunted Gallery`,
  $location`The Haunted Bathroom`,
  $location`The Spooky Forest`,
  $location`The Typical Tavern Cellar`,
  $location`The Dark Neck of the Woods`,
  $location`The Dark Heart of the Woods`,
  $location`The Dark Elbow of the Woods`,
  $location`The Defiled Cranny`,
  $location`The Defiled Alcove`,
  $location`Twin Peak`,
  $location`The Penultimate Fantasy Airship`,
  $location`The Castle in the Clouds in the Sky (Basement)`,
  $location`The Castle in the Clouds in the Sky (Top Floor)`,
  $location`The Hidden Park`,
  $location`Inside the Palindome`,
  $location`Hippy Camp`,
  $location`Frat House`
];
const AprilingBandHelmet = () => {
  const aprilingBandHelmet = $item`Apriling band helmet`;
  const haveHelmet = haveUnrestricted(aprilingBandHelmet);
  const havePatrolBeat = have$b($effect`Apriling Band Patrol Beat`);
  const haveBattleCadence = have$b($effect`Apriling Band Battle Cadence`);
  const conductorTimer = get$1("nextAprilBandTurn");
  const saxUsesLeft = Math.max(3 - get$1("_aprilBandSaxophoneUses"), 0);
  const quadTomUsesLeft = Math.max(3 - get$1("_aprilBandTomUses"), 0);
  const tubaUsesLeft = Math.max(3 - get$1("_aprilBandTubaUses"), 0);
  const piccoloUsesLeft = Math.max(3 - get$1("_aprilBandPiccoloUses"), 0);
  const instrumentsAvailable = Math.max(2 - get$1("_aprilBandInstruments"), 0);
  const location = myLocation();
  useNag(
    () => ({
      id: "apriling-band-helmet-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/aprilinghat.gif",
      node: haveHelmet && conductorTimer <= totalTurnsPlayed() && !havePatrolBeat && NONCOMBAT_ZONES.includes(location) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Conduct the Apriling Band",
          imageUrl: "/images/itemimages/aprilinghat.gif",
          href: inventoryActionLink("apriling"),
          linkEntireTile: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You can change your tune to -combat!" })
        }
      )
    }),
    [haveHelmet, conductorTimer, havePatrolBeat, location]
  );
  if (!haveUnrestricted(aprilingBandHelmet)) return null;
  const haveCelebrationBop = have$b($effect`Apriling Band Celebration Bop`);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: aprilingBandHelmet, children: [
    conductorTimer <= totalTurnsPlayed() ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryActionLink("apriling"), children: "You can change your tune!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { color: havePatrolBeat ? "blue" : void 0, children: "-10% Combat Frequency" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { color: haveBattleCadence ? "blue" : void 0, children: "+10% Combat Frequency" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { color: haveCelebrationBop ? "blue" : void 0, children: "+25% booze, +50% food, +100% candy" })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      plural(conductorTimer - totalTurnsPlayed(), "adventure"),
      " until you can change your tune."
    ] }),
    instrumentsAvailable > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { color: "green", href: inventoryActionLink("apriling"), children: [
      "Can pick ",
      plural(instrumentsAvailable, "more instrument"),
      "!"
    ] }),
    saxUsesLeft > 0 && have$b($item`Apriling band saxophone`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`Apriling band saxophone`), children: [
      "Can play the Sax ",
      plural(saxUsesLeft, "more time"),
      ".",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "green", children: "LUCKY!" })
    ] }),
    quadTomUsesLeft > 0 && have$b($item`Apriling band quad tom`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`Apriling band quad tom`), children: [
      "Can play the Quad Toms ",
      plural(quadTomUsesLeft, "more time"),
      ".",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "orange", children: "Sandworm!" })
    ] }),
    tubaUsesLeft > 0 && have$b($item`Apriling band tuba`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`Apriling band tuba`), children: [
      "Can play the Tuba ",
      plural(tubaUsesLeft, "more time"),
      ".",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "gray", children: "SNEAK!" })
    ] }),
    piccoloUsesLeft > 0 && have$b($item`Apriling band piccolo`) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { href: inventoryLink($item`Apriling band piccolo`), children: [
      "Can play the Piccolo ",
      plural(piccoloUsesLeft, "more time"),
      ".",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "purple", children: "+40 fxp" })
    ] })
  ] });
};
const BatWings = () => {
  const batWings = $item`bat wings`;
  const batWingsEquipped = haveEquipped(batWings);
  const batWingSwoopsLeft = Math.max(0, 11 - get$1("_batWingsSwoopUsed"));
  const batWingRestsLeft = Math.max(0, 11 - get$1("_batWingsRestUsed"));
  const batWingFreeFightsLeft = Math.max(0, 5 - get$1("_batWingsFreeFights"));
  const bridge = get$1("chasmBridgeProgress");
  const batHoleZones = [
    {
      location: $location`The Bat Hole Entrance`,
      used: get$1("batWingsBatHoleEntrance"),
      reward: $item`bat wing`
    },
    {
      location: $location`Guano Junction`,
      used: get$1("batWingsGuanoJunction"),
      reward: $item`sonar-in-a-biscuit`
    },
    {
      location: $location`The Batrat and Ratbat Burrow`,
      used: get$1("batWingsBatratBurrow"),
      reward: $item`sonar-in-a-biscuit`
    },
    {
      location: $location`The Beanbat Chamber`,
      used: get$1("batWingsBeanbatChamber"),
      reward: $item`enchanted bean`
    }
  ];
  const availableZones = batHoleZones.filter(({ used }) => !used);
  if (!haveUnrestricted(batWings)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: batWings, children: [
    batWingsEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "purple.solid", children: "Nanananananananana Bat-like man!" }),
    !batWingsEquipped && !canAdventure(
      $location`The Castle in the Clouds in the Sky (Basement)`
    ) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "blue.solid", children: "Equip your bat wings. This saves turns in the Airship!" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Swoop evilpockets: ",
      batWingSwoopsLeft,
      " left."
    ] }),
    batWingRestsLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Rest +1000 HP/MP: ",
      batWingRestsLeft,
      " left."
    ] }),
    batWingFreeFightsLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Free flaps: ",
      batWingFreeFightsLeft,
      " left."
    ] }),
    bridge >= 25 && !canAdventure($location`Oil Peak`) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "You can skip the rest of the bridge!" }),
    canAdventure($location`The Bat Hole Entrance`) && availableZones.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { command: !batWingsEquipped ? "equip bat wings" : void 0, children: [
        "Visit the Bat Hole zones",
        " ",
        !batWingsEquipped && "with bat wings equipped ",
        "to get:"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: availableZones.map(({ location, reward }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
        location.identifierString,
        ": ",
        reward.name
      ] }, location.id)) })
    ] })
  ] });
};
const ChestMimic = () => {
  const chestMimic = $familiar`Chest Mimic`;
  const mimicEgg = $item`mimic egg`;
  if (!haveUnrestricted(chestMimic)) return null;
  const famExperienceGain = numericModifier("familiar experience") + 1;
  const chestExperience = chestMimic.experience;
  const famExpNeededForNextEgg = 50 - chestExperience % 50;
  const fightsForNextEgg = famExperienceGain > 0 ? plural(Math.ceil(famExpNeededForNextEgg / famExperienceGain), "fight") : "cannot get";
  const mimicEggsLeft = clamp(11 - get$1("_mimicEggsObtained"), 0, 11);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: chestMimic, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Currently have ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: chestExperience }),
      " experience, currently gain ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: famExperienceGain }),
      " fam exp per fight."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Need ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: famExpNeededForNextEgg }),
      " more famxp for next egg (",
      fightsForNextEgg,
      ")."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Can lay ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: mimicEggsLeft }),
      " more eggs today."
    ] }),
    have$b(mimicEgg) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Fight some copies. ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(ItemButtons, { linkedContent: mimicEgg })
    ] })
  ] });
};
const EverfullDartHolster = () => {
  const everfullDartHolster = $item`Everfull Dart Holster`;
  const haveHolster = haveUnrestricted(everfullDartHolster);
  const everythingLooksRed = $effect`Everything Looks Red`;
  const haveELR = have$b(everythingLooksRed);
  const perks = get$1("everfullDartPerks");
  const dartCooldown = 50 - (perks.includes("You are less impressed by bullseyes") ? 10 : 0) - (perks.includes("Bullseyes do not impress you much") ? 10 : 0);
  const dartSkill = get$1("dartsThrown");
  const dartsNeededForNextPerk = Math.floor(Math.sqrt(dartSkill) + 1) ** 2 - dartSkill;
  const holsterEquipped = haveEquipped(everfullDartHolster);
  const inAvantGuard = myPath() === $path`Avant Guard`;
  useNag(
    () => ({
      id: "everfull-dart-holster-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/dartholster.gif",
      node: !haveELR && haveHolster && !inAvantGuard && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Throw a bullseye",
          id: "bullseye-nag",
          linkedContent: everfullDartHolster,
          children: holsterEquipped ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Shoot a bullseye! (",
            dartCooldown,
            " turns ELR)"
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", children: "Equip the dart holster first." })
        }
      )
    }),
    [
      haveELR,
      haveHolster,
      inAvantGuard,
      everfullDartHolster,
      holsterEquipped,
      dartCooldown
    ]
  );
  if (!haveHolster || dartSkill >= 401) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: everfullDartHolster, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Current dart skill: ",
      dartSkill,
      "."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue.solid", children: dartsNeededForNextPerk }),
      " ",
      "darts needed for next Perk."
    ] }),
    !holsterEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "Equip the dart holster first." }) }),
    holsterEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue.solid", children: "Dart holster equipped." }) })
  ] });
};
const MayamCalendar = () => {
  const mayamCalendar = $item`Mayam Calendar`;
  const mayamSymbols = [
    {
      ring: 1,
      friendlyName: "Yam",
      mafiaName: "yam1",
      description: "craftable ingredient"
    },
    {
      ring: 1,
      friendlyName: "Sword",
      mafiaName: "sword",
      description: `+${Math.min(150, 10 * myLevel())} mus stats`
    },
    {
      ring: 1,
      friendlyName: "Vessel",
      mafiaName: "vessel",
      description: "+1000 MP"
    },
    { ring: 1, friendlyName: "Fur", mafiaName: "fur", description: "+100 Fxp" },
    {
      ring: 1,
      friendlyName: "Chair",
      mafiaName: "chair",
      description: "+5 free rests"
    },
    {
      ring: 1,
      friendlyName: "Eye",
      mafiaName: "eye",
      description: "+30% item for 100 advs"
    },
    {
      ring: 2,
      friendlyName: "Yam",
      mafiaName: "yam2",
      description: "craftable ingredient"
    },
    {
      ring: 2,
      friendlyName: "Lightning",
      mafiaName: "lightning",
      description: `+${Math.min(150, 10 * myLevel())} mys stats`
    },
    {
      ring: 2,
      friendlyName: "Bottle",
      mafiaName: "bottle",
      description: "+1000 HP"
    },
    {
      ring: 2,
      friendlyName: "Wood",
      mafiaName: "wood",
      description: "+4 bridge parts"
    },
    {
      ring: 2,
      friendlyName: "Meat",
      mafiaName: "meat",
      description: `+${Math.min(150, 10 * myLevel())} meat`
    },
    {
      ring: 3,
      friendlyName: "Yam",
      mafiaName: "yam3",
      description: "craftable ingredient"
    },
    {
      ring: 3,
      friendlyName: "Eyepatch",
      mafiaName: "eyepatch",
      description: `+${Math.min(150, 10 * myLevel())} mox stats`
    },
    {
      ring: 3,
      friendlyName: "Wall",
      mafiaName: "wall",
      description: "+2 res for 100 advs"
    },
    {
      ring: 3,
      friendlyName: "Cheese",
      mafiaName: "cheese",
      description: "+1 goat cheese"
    },
    {
      ring: 4,
      friendlyName: "Yam",
      mafiaName: "yam4",
      description: "yep."
    },
    {
      ring: 4,
      friendlyName: "Clock",
      mafiaName: "clock",
      description: "+5 advs"
    },
    {
      ring: 4,
      friendlyName: "Explosion",
      mafiaName: "explosion",
      description: "+5 fites"
    }
  ];
  const templeResetAscension = get$1("lastTempleAdventures");
  const templeResetAvailable = templeResetAscension < myAscensions();
  const mayamSymbolsUsed = get$1("_mayamSymbolsUsed").split(",");
  const remaining = 3 - ["yam4", "clock", "explosion"].filter(
    (symbol) => mayamSymbolsUsed.includes(symbol)
  ).length;
  if (!haveUnrestricted(mayamCalendar) || remaining === 0 && !templeResetAvailable) {
    return null;
  }
  const unusedSymbols = mayamSymbols.filter(
    (symbol) => !mayamSymbolsUsed.includes(symbol.mafiaName)
  );
  const ringDescriptions = [1, 2, 3, 4].map((ring) => {
    const ringSymbols = unusedSymbols.filter((symbol) => symbol.ring === ring);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: `${ring}${["st", "nd", "rd", "th"][ring - 1]} ring:` }),
      " ",
      ringSymbols.map((symbol) => symbol.friendlyName).join(", ")
    ] }, ring);
  });
  const resonances = [
    {
      name: "15-turn banisher",
      combo: ["Vessel", "Yam", "Cheese", "Explosion"]
    },
    { name: "Yam and swiss", combo: ["Yam", "Meat", "Cheese", "Yam"] },
    { name: "+55% meat accessory", combo: ["Yam", "Meat", "Eyepatch", "Yam"] },
    { name: "+100% Food drops", combo: ["Yam", "Yam", "Cheese", "Clock"] }
  ];
  const availableResonances = resonances.filter(
    (resonance) => [1, 2, 3, 4].map((ring) => {
      const ringSymbols = unusedSymbols.filter((symbol) => symbol.ring === ring).map((symbol) => symbol.friendlyName);
      return ringSymbols.includes(resonance.combo[ring - 1]);
    }).filter((result) => result).length === 4
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Mayam Calendar",
      imageUrl: "/images/itemimages/yamcal.gif",
      linkedContent: mayamCalendar,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { as: "ol", children: ringDescriptions }),
        availableResonances.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", children: "Cool Mayam combos!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: availableResonances.map((resonance, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Strong, { children: [
            resonance.name,
            ":"
          ] }),
          " ",
          resonance.combo.join(" + ")
        ] }, index)) }),
        templeResetAvailable && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Line,
          {
            fontWeight: "bold",
            href: remaining === 0 && canAdventure($location`The Hidden Temple`) ? !have$b($effect`Stone-Faced`) ? inventoryLink($item`stone wool`) : parentPlaceLink($location`The Hidden Temple`) : void 0,
            children: "Temple reset available!"
          }
        )
      ]
    }
  );
};
const MiniKiwi = () => {
  const miniKiwi = $familiar`Mini Kiwi`;
  if (!haveUnrestricted(miniKiwi) || myPath() !== $path`11 Things I Hate About U`) {
    return null;
  }
  const miniKiwiItem = $item`mini kiwi`;
  const aviatorGoggles = $item`aviator goggles`;
  const miniKiwiBikini = $item`mini kiwi bikini`;
  const miniKiwiCount = availableAmount(miniKiwiItem);
  const kiwiWeight = familiarWeight(miniKiwi) + weightAdjustment();
  const kiwiModifier = have$b(aviatorGoggles) ? 0.75 : 0.5;
  const kiwiChance = Math.min(kiwiWeight * kiwiModifier, 100);
  const kiwiSpiritsBought = get$1("_miniKiwiIntoxicatingSpiritsBought");
  const miniKiwiBikiniCount = availableAmount(miniKiwiBikini);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: plural(
        miniKiwiCount,
        "mini-kiwi available",
        "mini-kiwis available"
      ),
      imageUrl: "/images/itemimages/minikiwi.gif",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "At ",
          Math.floor(kiwiWeight),
          " weight, you have a",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(AdviceTooltipText, { advice: "Chance of getting a mini-kiwi each fight", children: `${kiwiChance.toFixed(1)}%` }),
          " ",
          "chance of a mini-kiwi each fight."
        ] }),
        !kiwiSpiritsBought && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Consider purchasing mini-kiwi intoxicating spirits, for 3 kiwis." }),
        miniKiwiBikiniCount < 1 && get$1("zeppelinProtestors") < 80 && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Consider purchasing mini-kiwi bikinis, for the Zeppelin sleaze test." })
      ]
    }
  );
};
const PeaceTurkey = () => {
  const turkey = $familiar`Peace Turkey`;
  const combatRate = -Math.min(10, Math.floor(totalFamiliarWeight(turkey) / 5));
  const banishes = availableAmount($item`handful of split pea soup`);
  const potentialBanishes = Math.floor(
    availableAmount($item`whirled peas`) / 2
  );
  const drops = [
    $item`whirled peas`,
    "olive (or jumbo)",
    "HP/MP",
    $effect`Helping Fingers`,
    $item`whirled peas`,
    $item`piece of cake`,
    "random AC booze",
    $item`peace shooter`
  ];
  const nextDrop = drops[get$1("peaceTurkeyIndex")];
  const nextDropName = typeof nextDrop === "string" ? nextDrop : nextDrop.identifierString;
  const dropsUntilWhirledPeas = 4 - get$1("peaceTurkeyIndex") % 4;
  const dropChance = 24 + Math.sqrt(totalFamiliarWeight(turkey));
  if (!haveUnrestricted(turkey)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { linkedContent: turkey, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Provides ",
      combatRate,
      "% combat and a free run banish every 8 drops."
    ] }),
    banishes === 0 && potentialBanishes > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { command: `create ${potentialBanishes} handful of split pea soup`, children: [
      "Make ",
      potentialBanishes,
      " banishes from whirled peas."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      "Next drop: ",
      nextDropName,
      " (",
      dropChance.toFixed(0),
      "%, ~",
      (100 / dropChance).toFixed(1),
      " turns).",
      nextDrop !== $item`whirled peas` && ` ${plural(dropsUntilWhirledPeas, "drop")} until next whirled peas.`
    ] })
  ] });
};
const PhotoBooth = () => {
  const clanName = getClanName();
  const clanHasPhotoBooth = clanName === "Bonus Adventures from Hell";
  const photosRemaining = 3 - get$1("_photoBoothEffects");
  const propsRemaining = 3 - get$1("_photoBoothEquipment");
  const sheriffPieces = $items`Sheriff pistol, Sheriff badge, Sheriff moustache`;
  const sheriffPiecesMissing = sheriffPieces.filter((item2) => !have$b(item2));
  const sheriffOutfitAvailable = 0 < sheriffPiecesMissing.length && sheriffPiecesMissing.length <= propsRemaining && myPath() !== $path`Way of the Surprising Fist` && myPath() !== $path`G-Lover` && myPath() !== $path`Bees Hate You` && myPath() !== $path`Avant Guard`;
  if (!haveUnrestricted($item`Clan VIP Lounge key`) || !isUnrestricted($item`photo booth sized crate`)) {
    return null;
  }
  if (photosRemaining === 0 && propsRemaining === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Clan Photo Booth",
      href: "/clan_viplounge.php?action=photobooth",
      linkEntireTile: clanHasPhotoBooth,
      imageUrl: "/images/adventureimages/photobooth.gif",
      children: [
        !clanHasPhotoBooth && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { command: "/whitelist Bonus Adventures from Hell", children: "Switch to clan BAFH for photo booth." }),
        photosRemaining > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(photosRemaining, "clan photo"),
          " remaining: 50-turn -combat, +combat buff."
        ] }),
        sheriffOutfitAvailable ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Get sheriff outift for 3 free kills. Need",
          " ",
          commaAnd(
            sheriffPiecesMissing.map((item2) => item2.name.split(" ")[1])
          ),
          "."
        ] }) : propsRemaining > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Get ",
          propsRemaining,
          " additional prop equipment."
        ] })
      ]
    }
  );
};
const RomanCandelabra = () => {
  const romanCandelabra = $item`Roman Candelabra`;
  const springShoes = $item`spring shoes`;
  const everythingLooksGreen = $effect`Everything Looks Green`;
  const everythingLooksPurple = $effect`Everything Looks Purple`;
  const haveCandelabra = haveUnrestricted(romanCandelabra);
  const haveSpringShoes = haveUnrestricted(springShoes);
  const candelabraEquipped = haveEquipped(romanCandelabra);
  const haveELG = have$b(everythingLooksGreen);
  const haveELP = have$b(everythingLooksPurple);
  useNag(
    () => ({
      id: "roman-candelabra-green-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/romcandel.gif",
      node: haveCandelabra && !haveELG && !haveSpringShoes && /* @__PURE__ */ jsxRuntimeExports.jsxs(Tile, { header: "Run away with Candelabra", linkedContent: romanCandelabra, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "green.solid", children: "Green candle runaway!" }),
        !candelabraEquipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", command: "equip Roman Candelabra", children: "Equip the Roman Candelabra first." })
      ] })
    }),
    [
      haveCandelabra,
      romanCandelabra,
      haveELG,
      haveSpringShoes,
      candelabraEquipped
    ]
  );
  useNag(
    () => ({
      id: "roman-candelabra-purple-nag",
      priority: NagPriority.MID,
      imageUrl: "/images/itemimages/romcandel.gif",
      node: haveCandelabra && !haveELP && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Candelabra monster chain",
          linkedContent: romanCandelabra,
          id: "roman-candelabra-purple-nag",
          children: candelabraEquipped ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "purple.solid", children: "Equipped, blow your purple candle!" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { color: "red.solid", command: "equip Roman Candelabra", children: "Equip the candelabra and purple ray." })
        }
      )
    }),
    [haveCandelabra, romanCandelabra, candelabraEquipped, haveELP]
  );
  return null;
};
const SeptEmberCenser = () => {
  const septEmberCenser = $item`Sept-Ember Censer`;
  if (!haveUnrestricted(septEmberCenser)) {
    return null;
  }
  const bembershoot = $item`bembershoot`;
  const mmmBrrMouthwash = $item`Mmm-brr! brand mouthwash`;
  const septEmbers = get$1("availableSeptEmbers") + 7 * +!get$1("_septEmberBalanceChecked");
  const coldResistance = numericModifier("cold resistance");
  const mainstatGain = Math.floor(
    7 * coldResistance ** 1.7 * (1 + numericModifier(`${myPrimestat()} Experience Percent`) / 100)
  );
  const bembershootCount = availableAmount(bembershoot);
  const mouthwashCount = availableAmount(mmmBrrMouthwash);
  const structuralEmber = $item`structural ember`;
  const structureUsed = get$1("_structuralEmberUsed");
  const miniEmberingHulk = $item`miniature Embering Hulk`;
  const hulkFought = get$1("_emberingHulkFought");
  if (septEmbers <= 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Sept-Ember Censer",
      href: "/shop.php?whichshop=september",
      imageUrl: "/images/itemimages/embercenser.gif",
      children: [
        septEmbers > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
            "Have",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", fontWeight: "bold", children: septEmbers }),
            " ",
            "Sept-Embers to make stuff with!"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
              "1 embers: +5 cold res accessory (you have ",
              bembershootCount,
              ")."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
              "2 embers: mouthwash for",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "blue.solid", children: mainstatGain }),
              " ",
              "mainstat (you have",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: mouthwashCount }),
              ")."
            ] }),
            !have$b(structuralEmber) && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "4 embers: +5/5 bridge parts (1/day)." }),
            !hulkFought && !have$b(miniEmberingHulk) && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: "6 embers: embering hulk (1/day)." })
          ] })
        ] }),
        !structureUsed && have$b(structuralEmber) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(structuralEmber), children: "Use your structural ember for bridge parts." }),
        !hulkFought && have$b(miniEmberingHulk) && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { href: inventoryLink(miniEmberingHulk), children: "Fight an Embering Hulk." })
      ]
    }
  );
};
const SpringShoes = () => {
  const springShoes = $item`spring shoes`;
  const everythingLooksGreen = $effect`Everything Looks Green`;
  const haveShoes = haveUnrestricted(springShoes);
  const haveELG = have$b(everythingLooksGreen);
  const pathCheck = myPath() !== $path`Community Service` && myPath() !== $path`WereProfessor`;
  const haveShoesEquipped = haveEquipped(springShoes);
  useNag(
    () => ({
      id: "spring-shoes-nag",
      priority: NagPriority.IMMEDIATE,
      imageUrl: "/images/itemimages/springshoes.gif",
      node: haveShoes && pathCheck && !haveELG && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Run with spring shoes",
          id: "spring-shoes-nag",
          linkedContent: springShoes,
          children: haveShoesEquipped ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { as: "span", color: "green.solid", children: [
            "Free run with the ",
            /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: "Spring Away" }),
            " skill!"
          ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "span", color: "red.solid", children: "Equip the spring shoes first." }) })
        }
      )
    }),
    [haveELG, haveShoes, haveShoesEquipped, pathCheck, springShoes]
  );
  return null;
};
const TakerSpace = () => {
  const takerSpace = $item`TakerSpace letter of Marque`;
  const takerSpaceInstalled = getWorkshed() === takerSpace;
  const supplies = {
    spice: get$1("takerSpaceSpice") + +!get$1("_takerSpaceSuppliesDelivered") * 3,
    rum: get$1("takerSpaceRum") + +!get$1("_takerSpaceSuppliesDelivered") * 3,
    anchor: get$1("takerSpaceAnchor") + +!get$1("_takerSpaceSuppliesDelivered") * 3,
    mast: get$1("takerSpaceMast") + +!get$1("_takerSpaceSuppliesDelivered") * 3,
    silk: get$1("takerSpaceSilk") + +!get$1("_takerSpaceSuppliesDelivered") * 1,
    gold: get$1("takerSpaceGold") + +!get$1("_takerSpaceSuppliesDelivered") * 1
  };
  if (!haveUnrestricted(takerSpace) || !takerSpaceInstalled && get$1("_workshedItemUsed") || !isNormalCampgroundPath()) {
    return null;
  }
  const makeableItems = truthy([
    get$1("lastIslandUnlock") < myAscensions() && {
      name: "pirate dinghy",
      ingredients: { anchor: 1, mast: 1, silk: 1 }
    },
    {
      name: "deft pirate hook",
      ingredients: { anchor: 1, mast: 1, gold: 1 }
    },
    {
      name: "anchor bomb",
      ingredients: { anchor: 3, rum: 1, mast: 1, gold: 1 }
    },
    { name: "groggles", ingredients: { rum: 6 } },
    { name: "silky pirate drawers", ingredients: { silk: 2 } },
    { name: "tankard of spiced rum", ingredients: { spice: 1, rum: 2 } },
    { name: "cursed Aztec tamale", ingredients: { spice: 2 } }
  ]).filter((item2) => {
    return Object.entries(item2.ingredients).every(
      ([key, value]) => supplies[key] >= value
    );
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "TakerSpace",
      linkedContent: takerSpace,
      href: takerSpaceInstalled ? "/campground.php?action=workshed" : inventoryLink(takerSpace),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Supplies:",
          " ",
          commaAnd(
            [
              supplies.spice && plural(supplies.spice, "stolen spice"),
              supplies.rum && `${supplies.rum} robbed rum`,
              supplies.anchor && plural(supplies.anchor, "absconded-with anchor"),
              supplies.mast && plural(supplies.mast, "misappropriated mainmast"),
              supplies.silk && plural(supplies.silk, "snatched silk"),
              supplies.gold && plural(supplies.gold, "gaffled gold")
            ],
            Object.keys(supplies)
          ),
          "."
        ] }),
        makeableItems.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Can make:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: makeableItems.map((item2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: item2.name }, item2.name)) })
        ] })
      ]
    }
  );
};
const TearawayPants = () => {
  const tearawayPants = $item`tearaway pants`;
  const havePantsEquipped = haveEquipped(tearawayPants);
  const isMoxieClass = $classes`Disco Bandit, Accordion Thief`.includes(
    myClass()
  );
  if (!haveUnrestricted(tearawayPants) || !isMoxieClass || myAscensions() <= get$1("lastGuildStoreOpen")) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tile,
    {
      header: "Tearaway Pants",
      linkedContent: tearawayPants,
      href: havePantsEquipped ? "guild.php" : inventoryLink(tearawayPants),
      children: havePantsEquipped ? /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit the Department of Shadowy Arts and Crafts to unlock the guild!" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Visit the Department of Shadowy Arts and Crafts with your pants equipped to unlock the guild!" })
    }
  );
};
const CyberRealm = () => {
  const haveCyberRealm = haveUnrestricted($item`server room key`);
  const overclockFights = get$1("_cyberFreeFights");
  const batWingsFights = get$1("_batWingsFreeFights");
  const batWingsEquipped = haveEquipped($item`bat wings`);
  const inCyberRealm = $locations`Cyberzone 1, Cyberzone 2, Cyberzone 3`.includes(myLocation());
  useNag(
    () => ({
      id: "cyberrealm-overclock-bat-wings-nag",
      priority: NagPriority.ERROR,
      imageUrl: "/images/itemimages/ss_overclocked.gif",
      node: haveCyberRealm && overclockFights < 10 && batWingsFights < 5 && batWingsEquipped && inCyberRealm && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Take off your bat wings",
          imageUrl: "/images/itemimages/ss_overclocked.gif",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { fontWeight: "bold", children: "WARNING: CyberRealm will eat your bat wings free fights." })
        }
      )
    }),
    [
      batWingsEquipped,
      batWingsFights,
      haveCyberRealm,
      inCyberRealm,
      overclockFights
    ]
  );
  return null;
};
function renderNeedBonus(need, bonus) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    capitalizeWords(need),
    ":",
    " ",
    !bonus ? "nothing." : bonus instanceof Item ? `${bonus.identifierString}.` : Array.isArray(bonus) ? `${commaOr(bonus)}.` : `${bonus.effect.identifierString} (${bonus.duration} turns).`
  ] });
}
const Leprecondo = () => {
  const leprecondo = $item`Leprecondo`;
  const haveLeprecondo = haveUnrestricted(leprecondo);
  const rearrangesLeft = rearrangesRemaining();
  const nextNeedCheck = clamp(
    5 - (totalTurnsPlayed() - get$1("leprecondoLastNeedChange")),
    0,
    5
  );
  const needOrder$1 = needOrder();
  const currentNeed$1 = currentNeed();
  const needIndex = needOrder$1.indexOf(currentNeed$1);
  const unusedNeeds = NEEDS.filter(
    (need) => !needOrder$1.includes(need)
  );
  const nextNeedPossibilities = needIndex >= 0 && (needIndex + 1) % 6 < needOrder$1.length ? [needOrder$1[(needIndex + 1) % 6]] : unusedNeeds;
  const furniture = installedFurniture();
  const furnitureEmpty = furniture.every((f2) => f2 === "empty");
  const bonuses = furnitureBonuses();
  const nextBenefits = nextNeedPossibilities.map(
    (need) => [
      need,
      bonuses[need]
    ]
  );
  useNag(
    () => ({
      id: "leprecondo-setup-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/leprecondo.gif",
      node: haveLeprecondo && rearrangesLeft > 0 && furnitureEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "Set up Leprecondo",
          imageUrl: "/images/itemimages/leprecondo.gif",
          href: inventoryUseLink(leprecondo),
          linkEntireTile: true,
          children: "Install furniture in your Leprecondo for bonuses."
        }
      )
    }),
    [furnitureEmpty, haveLeprecondo, leprecondo, rearrangesLeft]
  );
  if (!haveLeprecondo) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: "Leprecondo",
      imageUrl: "/images/itemimages/leprecondo.gif",
      href: inventoryUseLink(leprecondo),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Next need check in ",
          plural(nextNeedCheck, "turn"),
          ".",
          nextBenefits.length > 0 && (nextBenefits.length > 1 ? " Possibilities:" : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            " ",
            renderNeedBonus(nextBenefits[0][0], nextBenefits[0][1])
          ] }))
        ] }),
        nextBenefits.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: nextBenefits.map(([need, bonus]) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: renderNeedBonus(need, bonus) }, need)) }),
        rearrangesLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          plural(rearrangesLeft, "furniture rearrangement"),
          " remaining today."
        ] })
      ]
    }
  );
};
const McHugeLargeDuffelBag = () => {
  const duffelBag = $item`McHugeLarge duffel bag`;
  const haveDuffelBag = haveUnrestricted(duffelBag);
  const duffelBagOpen = have$b($item`McHugeLarge left ski`);
  useNag(
    () => ({
      id: "mchugelarge-duffel-bag-open-nag",
      priority: NagPriority.LOW,
      imageUrl: "/images/itemimages/skibag2.gif",
      node: haveDuffelBag && !duffelBagOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tile,
        {
          header: "McHugeLarge duffel bag",
          imageUrl: "/images/itemimages/skibag2.gif",
          href: inventoryLink(duffelBag),
          linkEntireTile: true,
          children: "Open your duffel bag for ski equipment!"
        }
      )
    }),
    [duffelBag, duffelBagOpen, haveDuffelBag]
  );
  return null;
};
const MOON_SIGN_ID_LOOKUP = {
  "": 0,
  None: 0,
  Mongoose: 1,
  Wallaby: 2,
  Vole: 3,
  Platypus: 4,
  Opossum: 5,
  Marmot: 6,
  Wombat: 7,
  Blender: 8,
  Packrat: 9,
  "Bad Moon": 10
};
const calculateNumberologyInputs = (desiredDigits) => {
  const outputs = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  if (!(mySign() in MOON_SIGN_ID_LOOKUP)) {
    return { outputs, deltas };
  }
  const moonSignId = MOON_SIGN_ID_LOOKUP[mySign()];
  const b2 = mySpleenUse() + myLevel();
  const c2 = (myAscensions() + moonSignId) * b2 + myAdventures();
  desiredDigits.forEach((digit) => {
    deltas.set(digit, 99);
  });
  for (let x2 = 0; x2 <= 99; x2++) {
    const v2 = x2 * b2 + c2;
    const lastTwoDigits = v2 % 100;
    if (desiredDigits.includes(lastTwoDigits)) {
      outputs.set(lastTwoDigits, x2);
      deltas.delete(lastTwoDigits);
    }
    desiredDigits.forEach((digit) => {
      if (!outputs.has(digit)) {
        let delta = digit - lastTwoDigits;
        if (delta <= 0) {
          deltas.set(digit, Math.min(deltas.get(digit) ?? 99, -delta));
        } else {
          delta = digit - (lastTwoDigits + 100);
          if (delta <= 0) {
            deltas.set(digit, Math.min(deltas.get(digit) ?? 99, -delta));
          }
        }
      }
    });
  }
  return { outputs, deltas };
};
const Numberology = () => {
  const calculateSkill = $skill`Calculate the Universe`;
  if (!haveUnrestricted(calculateSkill)) return null;
  const universeCalculated = get$1("_universeCalculated");
  const skillLevel = get$1("skillLevel144");
  const limit = inRun() ? Math.min(skillLevel, 3) : skillLevel;
  if (universeCalculated >= limit) return null;
  const usesRemaining = limit - universeCalculated;
  const path = myPath();
  const primestat = myPrimestat();
  const desiredDigits = [];
  if (path !== $path`Slow and Steady`) {
    desiredDigits.push({ digit: 69, reason: "+3 adventures" });
  }
  if (!haveOutfit("Frat Warrior Fatigues") && !questFinished("questL12War")) {
    desiredDigits.push({
      digit: 51,
      reason: "frat warrior outfit (fight 151st infantryman)"
    });
  }
  if (!have$b($item`Knob Goblin perfume`) && !have$b($effect`Knob Goblin Perfume`) && !questFinished("questL05Goblin")) {
    desiredDigits.push({ digit: 9, reason: "knob goblin perfume" });
  }
  if (inRun()) {
    desiredDigits.push({
      digit: 14,
      reason: "1400 meat (autosell 14 moxie weeds)"
    });
    if (myLevel() < 13) {
      const mainstatGained = 89 * (1 + numericModifier(`${primestat} Experience Percent`) / 100);
      desiredDigits.push({
        digit: 89,
        reason: `${Math.round(mainstatGained)} mainstats`
      });
    }
  }
  const { outputs, deltas } = calculateNumberologyInputs(
    desiredDigits.map((d2) => d2.digit)
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: plural(usesRemaining, "universe calculation"),
      id: "calculate-the-universe-resource",
      imageUrl: "/images/itemimages/abacus.gif",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Enter these values to cast Calculate the Universe:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListRoot, { children: desiredDigits.map(({ digit, reason }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: outputs.has(digit) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          "Enter ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: outputs.get(digit) }),
          " for ",
          digit,
          " =",
          " ",
          reason,
          "."
        ] }) : deltas.has(digit) ? `Wait ${plural(deltas.get(digit) ?? 0, "turn")} to calculate for ${reason}.` : `Cannot currently calculate for ${reason}.` }, digit)) })
      ]
    }
  );
};
const TRACK_SOURCES = [
  {
    name: "Transcendent Olfaction",
    remaining: () => +have$b($skill`Transcendent Olfaction`) && 3 - get$1("_olfactionsUsed"),
    render: ({ remaining }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
      plural(remaining, "Transcendent Olfaction"),
      "."
    ] })
  },
  {
    name: "McHugeLarge Slash",
    remaining: () => +have$b($item`McHugeLarge duffel bag`) && 3 - get$1("_mcHugeLargeSlashUses"),
    render({ remaining }) {
      const leftPole = $item`McHugeLarge left pole`;
      const havePole = haveUnrestricted(leftPole);
      const poleEquipped = haveEquipped(leftPole);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Line,
        {
          href: !poleEquipped ? inventoryLink(
            havePole ? leftPole : $item`McHugeLarge duffel bag`
          ) : void 0,
          color: !poleEquipped ? "gray.solid" : void 0,
          children: [
            plural(remaining, "McHugeLarge Slash", "McHugeLarge Slashes"),
            "."
          ]
        }
      );
    }
  }
];
const TranscendentOlfaction = () => {
  const { total, rendered } = renderSourceList(TRACK_SOURCES);
  if (total === 0) return null;
  const tracked = have$b($effect`On the Trail`) && get$1("olfactedMonster");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tile,
    {
      header: plural(total, "olfaction"),
      id: "olfaction-tile",
      imageUrl: "/images/itemimages/snout.gif",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Line, { children: "Make encountering a zone monster much more likely." }),
        tracked && /* @__PURE__ */ jsxRuntimeExports.jsxs(Line, { children: [
          "Currently olfacted ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Strong, { children: tracked.identifierString }),
          "."
        ] }),
        rendered
      ]
    }
  );
};
const ResourceSection = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  TileSection,
  {
    name: "Resources",
    tiles: [
      ActiveBanishes,
      FreeFights,
      FreeZones,
      FreeKills,
      FreeRuns,
      Wishes,
      Faxes,
      Copies,
      NoncombatForces,
      TranscendentOlfaction,
      Numberology,
      LuckyAdventures,
      Pulls,
      /* 2009 */
      FrumiousBandersnatch,
      /* 2015 */
      DeckOfEveryCard,
      PuckMan,
      /* 2016 */
      ClanFloundry,
      SourceTerminalTile,
      DetectiveSchool,
      ProtonicAcceleratorPack,
      Thanksgarden,
      /* 2017 */
      AsdonMartin,
      TunnelOfLove,
      /* 2018 */
      ClanFortune,
      VotingBooth,
      /* 2019 */
      KramcoSausageOMatic,
      /* 2020 */
      PowerfulGlove,
      Melodramedary,
      CargoCultistShorts,
      Cartography,
      CommerceGhost,
      /* 2021 */
      BackupCamera,
      EmotionChip,
      UndergroundFireworksShop,
      IndustrialFireExtinguisher,
      DaylightShavingsHelmet,
      ColdMedicineCabinet,
      /* 2022 */
      CursedMagnifyingGlass,
      CosmicBowlingBall,
      CombatLoversLocket,
      GreyGoose,
      UnbreakableUmbrella,
      MayDayPackage,
      JuneCleaver,
      DesignerSweatpants,
      TinyStillsuit,
      JurassicParka,
      Autumnaton,
      Cookbookbat,
      ModelTrainSet,
      /* 2023 */
      RockGarden,
      SITCertificate,
      ClosedCircuitPayPhone,
      CursedMonkeysPaw,
      CinchoDeMayo,
      MrStore2002Catalog,
      PatrioticEagle,
      AugustScepter,
      BookOfFacts,
      JillOfAllTrades,
      AGuideToBurningLeaves,
      CandyCaneSwordCane,
      /* 2024 */
      ChestMimic,
      SpringShoes,
      EverfullDartHolster,
      AprilingBandHelmet,
      MayamCalendar,
      MiniKiwi,
      RomanCandelabra,
      TearawayPants,
      SeptEmberCenser,
      BatWings,
      PhotoBooth,
      PeaceTurkey,
      TakerSpace,
      /* 2025 */
      CyberRealm,
      McHugeLargeDuffelBag,
      Leprecondo,
      /* Nags only */
      BeatenUp,
      AvantGuard,
      Muffin
    ]
  }
);
const Layout$1 = () => {
  const { triggerHardRefresh } = reactExports.useContext(RefreshContext);
  const tooltipRef = reactExports.useRef();
  const [buttonsVisible, setButtonsVisible] = reactExports.useState(false);
  const [chatFrameOpen, setChatFrameOpen] = reactExports.useState(isChatPaneVisible());
  const toggleChatFrame = reactExports.useCallback(() => {
    const isVisible2 = toggleChatPane();
    setChatFrameOpen(isVisible2);
  }, []);
  reactExports.useEffect(() => {
  }, [triggerHardRefresh]);
  reactExports.useEffect(() => {
    setGlobalErrorHandler((err) => {
      console.error(err);
      toaster.error({
        title: "Error updating.",
        description: err !== null && (typeof err === "object" || typeof err === "string") ? err.toString() : "Unknown error.",
        duration: 1e4
      });
    });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContext.Provider, { value: tooltipRef, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container,
    {
      maxW: "4xl",
      paddingX: 0,
      fontSize: ["xs", "sm"],
      h: "100vh",
      display: "flex",
      flexDirection: "column",
      onMouseEnter: () => setButtonsVisible(true),
      onMouseLeave: () => setButtonsVisible(false),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { position: "relative", minH: 0, flex: "1 1 auto", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Stack,
            {
              direction: "row",
              position: "absolute",
              top: 1,
              left: 1,
              zIndex: 200,
              ...!buttonsVisible && { display: "none" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIconButton, { onClick: close })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Stack,
            {
              direction: "row",
              gap: 1,
              position: "absolute",
              top: 1,
              right: 5,
              zIndex: 200,
              ...!buttonsVisible && { display: "none" },
              children: [
                inDevMode(),
                /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshButton, { onClick: triggerHardRefresh })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { overflow: "scroll", flexGrow: 1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(BrandHeading, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(NagSection, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(QuestSection, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ResourceSection, {})
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Flex,
            {
              position: "absolute",
              h: "100vh",
              right: 5,
              align: "center",
              pointerEvents: "none",
              lineHeight: 0,
              ...!buttonsVisible && { display: "none" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                ChatButton,
                {
                  direction: chatFrameOpen ? "right" : "left",
                  onClick: toggleChatFrame,
                  zIndex: 200,
                  pointerEvents: "auto"
                }
              )
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LocationBar, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ref: tooltipRef })
      ]
    }
  ) });
};
const buttonRecipe = defineRecipe({
  compoundVariants: [
    {
      colorPalette: "gray",
      variant: "solid",
      css: {
        bgColor: "gray.500",
        _hover: {
          bgColor: "gray.700"
        },
        _dark: {
          _hover: {
            bgColor: "gray.300"
          }
        }
      }
    }
  ]
});
const linkRecipe = defineRecipe({
  base: {
    display: "inline"
  }
});
const config = defineConfig({
  globalCss: {
    html: {
      lineHeight: "moderate",
      overflow: "hidden"
    }
  },
  theme: {
    breakpoints: {
      sm: "360px"
    },
    tokens: {
      lineHeights: {
        none: { value: 1 },
        shorter: { value: 1.05 },
        short: { value: 1.1 },
        moderate: { value: 1.15 },
        default: { value: 1.15 },
        tall: { value: 1.25 },
        taller: { value: 1.5 }
      }
    },
    recipes: {
      button: buttonRecipe,
      link: linkRecipe
    }
  }
});
const system = createSystem(defaultConfig, config);
const App$1 = () => /* @__PURE__ */ jsxRuntimeExports.jsx(ChakraProvider, { value: system, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallbackRender: ErrorPage, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(NagContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout$1, {}) }) }) }) });
const effects = [
  "Apriling Band Battle Cadence",
  "Apriling Band Celebration Bop",
  "Apriling Band Patrol Beat",
  "Beaten Up",
  "Bored Stiff",
  "Chalky Hand",
  "Citizen of a Zone",
  "Crappily Disguised as a Waiter",
  "Dirty Pear",
  "Dragged Through the Coals",
  "Everything Looks Blue",
  "Everything Looks Green",
  "Everything Looks Purple",
  "Everything Looks Red",
  "Everything Looks Yellow",
  "Fifty Ways to Bereave Your Lover",
  "Filthworm Drone Stench",
  "Filthworm Guard Stench",
  "Filthworm Larva Stench",
  "Friendly Chops",
  "Frosty",
  "Hear Me Roar",
  "Knob Goblin Perfume",
  "Lucky!",
  "Musky",
  "Once-Cursed",
  "Painted-On Bikini",
  "Recalling Circadian Rhythms",
  "Red Door Syndrome",
  "Sewer-Drenched",
  "Shadow Affinity",
  "Sinuses For Miles",
  "Spectacle Moustache",
  "Staying Frosty",
  "Thrice-Cursed",
  "Twice-Cursed",
  "Ultrahydrated"
];
const items = [
  '"2 Love Me, Vol. 2"',
  "11-leaf clover",
  "2002 Mr. Store Catalog",
  "A Guide to Burning Leaves",
  "A-Boo clue",
  "Apriling band helmet",
  "Apriling band piccolo",
  "Apriling band quad tom",
  "Apriling band saxophone",
  "Apriling band tuba",
  "Boris's bread",
  "Bowl of Scorpions",
  "CSA all-purpose soap",
  "Cargo Cultist Shorts",
  "Catherine Wheel",
  "Cincho de Mayo",
  "Clan VIP Lounge key",
  "Copperhead Charm",
  "Copperhead Charm (rampant)",
  "Daily Affirmation: Always be Collecting",
  "Daylight Shavings Helmet",
  "Duskwalker syringe",
  "Everfull Dart Holster",
  "Flash Liquidizer Ultra Dousing Accessory",
  "Fourth of May Cosplay Saber",
  "June cleaver",
  "Jurassic Parka",
  "Knob Goblin Encryption Key",
  "Knob Goblin harem pants",
  "Knob Goblin harem veil",
  "Knob Goblin perfume",
  "Kremlin's Greatest Briefcase",
  "LED candle",
  "Lady Spookyraven's dancing shoes",
  "Lady Spookyraven's finest gown",
  "Lady Spookyraven's powder puff",
  "Letter from Carrie Bradshaw",
  "Lil' Doctor bag",
  "Loathing Idol Microphone",
  "Lord Spookyraven's spectacles",
  "Louder Than Bomb",
  "MayDay supply package",
  "Mayam Calendar",
  "McClusky file (complete)",
  "McClusky file (page 1)",
  "McClusky file (page 2)",
  "McClusky file (page 3)",
  "McClusky file (page 4)",
  "McClusky file (page 5)",
  "Mega Gem",
  "Mick's IcyVapoHotness Inhaler",
  "Mohawk wig",
  "Neverending Party invitation envelope",
  "Powerful Glove",
  "Red Zeppelin ticket",
  "Replica 2002 Mr. Store Catalog",
  "Richard's star key",
  "Roman Candelabra",
  "Rufus's shadow lodestone",
  "S.I.T. Course Completion Certificate",
  "Shore Inc. Ship Trip Scrip",
  "Sneaky Pete's leather jacket (collar popped)",
  "Space Tours Tripple",
  "Spooky VHS Tape",
  "Spookyraven billiards room key",
  "St. Sneaky Pete's Whey",
  "Staff of Ed, almost",
  "Talisman o' Namsilat",
  "The Inquisitor's unidentifiable object",
  "UV-resistant compass",
  "Vegetable of Jarlsberg",
  "Wand of Nagamar",
  "Witchess Set",
  "X-32-F snowman crate",
  "Yeast of Boris",
  "[10882]carton of astral energy drinks",
  "[10883]astral energy drink",
  '[7262]"I Love Me, Vol. I"',
  "[7302]Spookyraven library key",
  "[7961]Staff of Ed",
  "[7962]Eye of Ed",
  "[7963]ancient amulet",
  "[7964]Staff of Fats",
  "[glitch season reward name]",
  "amulet of extreme plot significance",
  "ancient bomb",
  "ancient bronze token",
  "antique machete",
  "asbestos ore",
  "astral pet sweater",
  "august scepter",
  "autumn-aton",
  "aviator goggles",
  "backup camera",
  "bag of foreign bribes",
  "barrel of gunpowder",
  "battery (car)",
  "beehive",
  "beggin' cologne",
  "bird rib",
  "blackberry galoshes",
  "blasting soda",
  "bloodied surgical dungarees",
  "book of matches",
  "boring binder clip",
  "bottle of Chateau de Vinegar",
  "bottle of Greedy Dog",
  "bowling ball",
  "bubblin' crude",
  "can of black paint",
  "candy cane sword cane",
  "chaos butterfly",
  "chrome ore",
  "clan underground fireworks shop",
  "closed-circuit pay phone",
  "cold medicine cabinet",
  "combat lover's locket",
  "continuum transfunctioner",
  "cosmic bowling ball",
  "crackling stone sphere",
  "crappy waiter disguise",
  "crumbling wooden wheel",
  "cursed magnifying glass",
  "cursed monkey's paw",
  "deck of lewd playing cards",
  "desert sightseeing pamphlet",
  "designer sweatpants",
  "detartrated anhydrous sublicalc",
  "dictionary",
  "digital key",
  "dirt julep",
  "disposable instant camera",
  "drain dissolver",
  "dress pants",
  "dripping stone sphere",
  "dromedary drinking helmet",
  "drum machine",
  "enchanted bean",
  "evil eye",
  "facsimile dictionary",
  "familiar scrapbook",
  "fedora-mounted fountain",
  "filthworm drone scent gland",
  "filthworm hatchling scent gland",
  "filthworm royal guard scent gland",
  "flaming leaf crown",
  "flapper fly",
  "forest tears",
  "forged identification documents",
  "frost flower",
  "genie bottle",
  "ghost of a necklace",
  "glark cable",
  "goat cheese",
  "green smoke bomb",
  "groveling gravel",
  "half-size scalpel",
  "handful of hand chalk",
  "head mirror",
  "heart of the filthworm queen",
  "heavy D",
  "ice harvest",
  "ice house",
  "ice nine",
  "industrial fire extinguisher",
  "inflammable leaf",
  "jam band flyers",
  "jar of oil",
  "jumping horseradish",
  "killing jar",
  "latte lovers member's mug",
  "linoleum ore",
  "lion oil",
  "lodestone",
  "loosening powder",
  "lowercase N",
  "lynyrd musk",
  "lynyrd snare",
  "metallic A",
  "milestone",
  "mimic egg",
  "mini kiwi",
  "mini kiwi bikini",
  "miracle whip",
  "model train set",
  "molehill mountain",
  "molybdenum magnet",
  "moss-covered stone sphere",
  "mother's necklace",
  "muculent machete",
  "ninja carabiner",
  "ninja crampons",
  "ninja rope",
  "ornate dowsing rod",
  "personal massager",
  "photograph of a dog",
  "pocket wish",
  "pool cue",
  "powdered castoreum",
  "pro skateboard",
  "reassembled blackbird",
  "recipe: mortar-dissolving solution",
  "red rocket",
  "red-soled high heels",
  "replica Fourth of May Cosplay Saber",
  "rock band flyers",
  "ruby W",
  "rusty hedge trimmers",
  "scorched stone sphere",
  "sea truffle",
  "seal tooth",
  "seal-clubbing club",
  "shadow brick",
  "short writ of habeas corpus",
  "sonar-in-a-biscuit",
  "sorority brain",
  "spring shoes",
  "star chart",
  "steam-powered model rocketship",
  "stone rose",
  "stone triangle",
  "stone wool",
  "stunt nuts",
  "surgical apron",
  "surgical mask",
  "survival knife",
  "tangle of rat tails",
  "tearaway pants",
  "telegram from Lady Spookyraven",
  "tempura cauliflower",
  "tennis ball",
  "the Nostril of the Serpent",
  "tiny house",
  "tiny stillsuit",
  "titanium assault umbrella",
  "tomb ratchet",
  "triatomaceous dust",
  "triple-distilled turpentine",
  "unbreakable umbrella",
  "unstable fulminate",
  "wet stew",
  "whet stone",
  "wine bomb",
  "worm-riding hooks",
  "worm-riding manual page"
];
const locationsNoncombatQueue = [
  "The Dark Neck of the Woods",
  "The Dark Heart of the Woods",
  "The Dark Elbow of the Woods",
  "McMillicancuddy's Barn",
  "The Haunted Ballroom",
  "The Hidden Apartment Building"
];
const preferences = [
  "8BitBonusTurns",
  "8BitColor",
  "8BitScore",
  "autoCraft",
  "autumnatonQuestLocation",
  "autumnatonQuestTurn",
  "autumnatonUpgrades",
  "availableMrStore2002Credits",
  "availableSeptEmbers",
  "backupCameraMode",
  "backupCameraReverserEnabled",
  "banishedMonsters",
  "banishedPhyla",
  "batWingsBatHoleEntrance",
  "batWingsBatratBurrow",
  "batWingsBeanbatChamber",
  "batWingsGuanoJunction",
  "blackForestProgress",
  "bodyguardCharge",
  "bodyguardChatMonster",
  "bondDesert",
  "booPeakLit",
  "booPeakProgress",
  "breathitinCharges",
  "calzoneOfLegendEaten",
  "camelSpit",
  "candyCaneSwordApartmentBuilding",
  "candyCaneSwordBlackForest",
  "candyCaneSwordBowlingAlley",
  "candyCaneSwordDailyDungeon",
  "candyCaneSwordShore",
  "challengePath",
  "chaosButterflyThrown",
  "charpanemode",
  "chasmBridgeProgress",
  "chateauMonster",
  "commerceGhostCombats",
  "commerceGhostItem",
  "cookbookbatIngredientsCharge",
  "cosmicBowlingBallReturnCombats",
  "currentExtremity",
  "currentMojoFilters",
  "currentNunneryMeat",
  "cursedMagnifyingGlassCount",
  "cyrptAlcoveEvilness",
  "cyrptCrannyEvilness",
  "cyrptNicheEvilness",
  "cyrptNookEvilness",
  "cyrptTotalEvilness",
  "dailyDungeonDone",
  "dartsThrown",
  "deepDishOfLegendEaten",
  "desertExploration",
  "encountersUntilSRChoice",
  "everfullDartPerks",
  "familiarSweat",
  "fireExtinguisherBatHoleUsed",
  "fireExtinguisherChasmUsed",
  "fireExtinguisherCyrptUsed",
  "fireExtinguisherDesertUsed",
  "fireExtinguisherHaremUsed",
  "flyeredML",
  "frAlways",
  "fratboysDefeated",
  "ghostLocation",
  "giantGrown",
  "gnasirProgress",
  "gooseDronesRemaining",
  "hasAutumnaton",
  "hasMaydayContract",
  "hiddenApartmentProgress",
  "hiddenBowlingAlleyProgress",
  "hiddenHospitalProgress",
  "hiddenOfficeProgress",
  "hiddenTavernUnlock",
  "hippiesDefeated",
  "hippyStoneBroken",
  "horseryAvailable",
  "inBadMoon",
  "kingLiberated",
  "lastAdventure",
  "lastCombatEnvironments",
  "lastCopyableMonster",
  "lastEncounter",
  "lastGuildStoreOpen",
  "lastIslandUnlock",
  "lastNoncombat539",
  "lastNoncombat540",
  "lastNoncombat541",
  "lastQuartetAscension",
  "lastSecondFloorUnlock",
  "lastTempleAdventures",
  "lastTempleButtonsUnlock",
  "lastTempleUnlock",
  "lastTrainsetConfiguration",
  "leafletCompleted",
  "ledCandleDropped",
  "lighthouseFinished",
  "lighthouseQuestState",
  "locketPhylum",
  "lockPicked",
  "loveTunnelAvailable",
  "mainStat",
  "manorDrawerCount",
  "moonTuned",
  "mountainClimbed",
  "neverendingPartyAlways",
  "nextAdventure",
  "nextAprilBandTurn",
  "nextParanormalActivity",
  "noncombatForcerActive",
  "nsChallenge1",
  "nsChallenge2",
  "nsContestants1",
  "nsContestants2",
  "nsContestants3",
  "nsTowerDoorKeysUsed",
  "oilPeakLit",
  "oilPeakProgress",
  "olfactedMonster",
  "ownsSpeakeasy",
  "palindomeDudesDefeated",
  "parkaMode",
  "pathId",
  "peaceTurkeyIndex",
  "peteMotorbikeHeadlight",
  "pizzaOfLegendEaten",
  "poolSharkCount",
  "poolSkill",
  "pyramidBombUsed",
  "pyramidPosition",
  "questG02Whitecastle",
  "questL02Larva",
  "questL03Rat",
  "questL04Bat",
  "questL05Goblin",
  "questL06Friar",
  "questL07Cyrptic",
  "questL08Trapper",
  "questL09Topping",
  "questL10Garbage",
  "questL11Black",
  "questL11Curses",
  "questL11Desert",
  "questL11MacGuffin",
  "questL11Manor",
  "questL11Palindome",
  "questL11Pyramid",
  "questL11Ron",
  "questL11Shen",
  "questL11Spare",
  "questL11Worship",
  "questL12War",
  "questL13Final",
  "questM05Toot",
  "questM20Necklace",
  "questM21Dance",
  "questPAGhost",
  "questRufus",
  "relocatePygmyJanitor",
  "romanticTarget",
  "rwbMonster",
  "rwbMonsterCount",
  "scrapbookCharges",
  "screechCombats",
  "shenInitiationDay",
  "shenQuestItem",
  "shockingLickCharges",
  "sidequestArenaCompleted",
  "sidequestFarmCompleted",
  "sidequestJunkyardCompleted",
  "sidequestLighthouseCompleted",
  "sidequestNunsCompleted",
  "sidequestOrchardCompleted",
  "skillLevel144",
  "smutOrcNoncombatProgress",
  "sourceTerminalEnquiry",
  "speakeasyName",
  "spookyravenRecipeUsed",
  "spookyVHSTapeMonster",
  "spookyVHSTapeMonsterTurn",
  "sweat",
  "takerSpaceAnchor",
  "takerSpaceGold",
  "takerSpaceMast",
  "takerSpaceRum",
  "takerSpaceSilk",
  "takerSpaceSpice",
  "telescope3",
  "telescope4",
  "telescope5",
  "timesRested",
  "trainsetConfiguration",
  "trainsetPosition",
  "trapperOre",
  "twinPeakLit",
  "twinPeakProgress",
  "umbrellaState",
  "warProgress",
  "writingDesksDefeated",
  "zeppelinProtestors",
  "zootGraftedButtCheekLeftFamiliar",
  "zootGraftedButtCheekRightFamiliar",
  "zootGraftedFootLeftFamiliar",
  "zootGraftedFootRightFamiliar",
  "zootGraftedHeadFamiliar",
  "zootGraftedNippleLeftFamiliar",
  "zootGraftedNippleRightFamiliar",
  "zootGraftedShoulderLeftFamiliar",
  "zootGraftedShoulderRightFamiliar",
  "_2002MrStoreCreditsCollected",
  "_aprilBandInstruments",
  "_aprilBandPiccoloUses",
  "_aprilBandSaxophoneUses",
  "_aprilBandTomUses",
  "_aprilBandTubaUses",
  "_assertYourAuthorityCast",
  "_aug2Cast",
  "_augSkillsCast",
  "_backUpUses",
  "_banderRunaways",
  "_bastilleGames",
  "_batWingsFreeFights",
  "_batWingsRestUsed",
  "_batWingsSwoopUsed",
  "_bookOfFactsTatters",
  "_bookOfFactsWishes",
  "_candyCaneSwordLyle",
  "_cargoPocketEmptied",
  "_chateauMonsterFought",
  "_chestXRayUsed",
  "_circadianRhythmsAdventures",
  "_circadianRhythmsPhylum",
  "_circadianRhythmsRecalled",
  "_clanFortuneBuffUsed",
  "_clanFortuneConsultUses",
  "_claraBellUsed",
  "_cloversPurchased",
  "_coldMedicineConsults",
  "_cookbookbatCombatsUntilNewQuest",
  "_cookbookbatCrafting",
  "_cookbookbatQuestIngredient",
  "_cookbookbatQuestLastLocation",
  "_cookbookbatQuestMonster",
  "_cyberFreeFights",
  "_deckCardsDrawn",
  "_deckCardsSeen",
  "_douseFoeUses",
  "_eldritchHorrorEvoked",
  "_eldritchTentacleFought",
  "_emberingHulkFought",
  "_enamorangs",
  "_epicMcTwistUsed",
  "_feelEnvyUsed",
  "_feelHatredUsed",
  "_feelLonelyUsed",
  "_feelNostalgicUsed",
  "_feelPeacefulUsed",
  "_feelPrideUsed",
  "_fireExtinguisherCharge",
  "_fireworksShop",
  "_fireworksShopHatBought",
  "_freePillKeeperUsed",
  "_frToday",
  "_genieFightsUsed",
  "_genieWishesUsed",
  "_gingerbreadMobHitUsed",
  "_glarkCableUses",
  "_horsery",
  "_hotTubSoaks",
  "_inRun",
  "_inRunBool",
  "_kgbTranquilizerDartUses",
  "_lastDailyDungeonRoom",
  "_lastSausageMonsterTurn",
  "_latteBanishUsed",
  "_latteRefillsUsed",
  "_leafMonstersFought",
  "_loveTunnelUsed",
  "_machineTunnelsAdv",
  "_macrometeoriteUses",
  "_mafiaMiddleFingerRingUsed",
  "_mapToACandyRichBlockDrops",
  "_mapToACandyRichBlockUsed",
  "_mayamSymbolsUsed",
  "_maydayDropped",
  "_mcHugeLargeAvalancheUses",
  "_mcHugeLargeSlashUses",
  "_meatifyMatterUsed",
  "_meteorShowerUses",
  "_mimicEggsObtained",
  "_miniKiwiIntoxicatingSpiritsBought",
  "_missileLauncherUsed",
  "_molehillMountainUsed",
  "_monkeyPawWishesUsed",
  "_monsterHabitatsFightsLeft",
  "_monsterHabitatsMonster",
  "_monsterHabitatsRecalled",
  "_monstersMapped",
  "_neverendingPartyFreeTurns",
  "_neverendingPartyToday",
  "_nextColdMedicineConsult",
  "_olfactionsUsed",
  "_photoBoothEffects",
  "_photoBoothEquipment",
  "_photocopyUsed",
  "_pocketProfessorLectures",
  "_poolGames",
  "_pottedPowerPlant",
  "_powderedMadnessUses",
  "_powerfulGloveBatteryPowerUsed",
  "_powerPillDrops",
  "_powerPillUses",
  "_questPartyFair",
  "_reflexHammerUsed",
  "_romanticFightsLeft",
  "_roninStoragePulls",
  "_saberForceUses",
  "_sausageFights",
  "_sausagesEaten",
  "_sausagesMade",
  "_sealsSummoned",
  "_septEmberBalanceChecked",
  "_shadowAffinityToday",
  "_shadowBricksUsed",
  "_shatteringPunchUsed",
  "_sitCourseCompleted",
  "_snojoFreeFights",
  "_snokebombUsed",
  "_sourceTerminalExtrudes",
  "_spaceJellyfishDrops",
  "_speakeasyFreeFights",
  "_spikolodonSpikeUses",
  "_streamsCrossed",
  "_structuralEmberUsed",
  "_surprisinglySweetSlashUsed",
  "_sweatOutSomeBoozeUsed",
  "_takerSpaceSuppliesDelivered",
  "_timeSpinnerMinutesUsed",
  "_trickOrTreatBlock",
  "_turkeyBlastersUsed",
  "_universeCalculated",
  "_usedReplicaBatoomerang",
  "_voidFreeFights",
  "_witchessBuff",
  "_witchessFights",
  "_workshedItemUsed"
];
const locationsTurnsSpent = [
  "The Boss Bat's Lair",
  "The Outskirts of Cobb's Knob",
  "The Dark Neck of the Woods",
  "The Dark Heart of the Woods",
  "The Dark Elbow of the Woods",
  "Mist-Shrouded Peak",
  "The Haunted Gallery",
  "The Haunted Bathroom",
  "The Haunted Bedroom",
  "The Haunted Ballroom",
  "The Penultimate Fantasy Airship",
  "The Castle in the Clouds in the Sky (Ground Floor)",
  "The Black Forest",
  "A Mob of Zeppelin Protesters",
  "The Red Zeppelin",
  "The Copperhead Club",
  "The Hidden Apartment Building",
  "The Hidden Office Building",
  "The Hidden Hospital",
  "The Upper Chamber",
  "The Middle Chamber",
  "The Hole in the Sky"
];
function validityType(override) {
  const propertyMatch = /^override:getProperty\((.*)\)$/.exec(override);
  let propertyName = null;
  if (propertyMatch) {
    try {
      const parsed = JSON.parse(propertyMatch[1]);
      if (typeof parsed === "string") propertyName = parsed;
    } catch (_) {
    }
  }
  if (propertyName && isNumericProperty(propertyName) || /^override:Location.get\(.*\).turnsSpent$/.test(override) || /^override:haveEffect\(.*\)$/.test(override) || /^override:availableAmount\(.*\)$/.test(override)) {
    return "number";
  } else if (propertyName && isBooleanProperty(propertyName)) {
    return "boolean";
  } else if (propertyName && isNumericOrStringProperty(propertyName)) {
    return "string | number";
  } else if (propertyName && propertyName.startsWith("quest")) {
    return "quest";
  } else {
    return "string";
  }
}
function validValue(type, value) {
  switch (type) {
    case "string":
      return true;
    case "number":
      return !!value.match(/^-?\d+$/);
    case "boolean":
      return !!value.match(/^(true|false)$/);
    case "string | number":
      return true;
    case "quest":
      return !!value.match(/^(unstarted|started|finished|step\d+)$/);
  }
}
const InputGroup = reactExports.forwardRef(
  (props, ref2) => {
    const {
      startElement,
      startElementProps,
      endElement,
      endElementProps,
      children,
      startOffset = "6px",
      endOffset = "6px",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Group, { ref: ref2, ...rest, children: [
      startElement && /* @__PURE__ */ jsxRuntimeExports.jsx(InputElement, { pointerEvents: "none", ...startElementProps, children: startElement }),
      reactExports.cloneElement(children, {
        ...startElement && {
          ps: `calc(var(--input-height) - ${startOffset})`
        },
        ...endElement && { pe: `calc(var(--input-height) - ${endOffset})` },
        ...children.props
      }),
      endElement && /* @__PURE__ */ jsxRuntimeExports.jsx(InputElement, { placement: "end", ...endElementProps, children: endElement })
    ] });
  }
);
const ValidatedInput = ({
  value,
  placeholder,
  size: size2,
  onChange,
  valid,
  changeValue,
  refresh: refresh2,
  ...props
}) => {
  const nonEmpty = !!(value && value !== "");
  const colorProps = valid && nonEmpty ? { borderColor: "fg.success" } : !valid && nonEmpty ? { borderColor: "fg.error" } : void 0;
  const handleClear = reactExports.useCallback(() => {
    changeValue("");
    if (refresh2) refresh2();
  }, [changeValue, refresh2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", gap: 0.5, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InputGroup,
      {
        endElement: !nonEmpty ? void 0 : valid ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { asChild: true, color: "fg.success", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, {}) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { asChild: true, color: "fg.error", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, {}) }),
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            value,
            placeholder,
            size: size2,
            onChange,
            ...colorProps,
            _focus: colorProps,
            _hover: colorProps
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButton, { size: size2, onClick: handleClear })
  ] });
};
function refresh() {
  const yorickpane = window.parent.frames.yorickpane;
  yorickpane == null ? void 0 : yorickpane.postMessage("refresh");
}
const OverrideRow = ({
  label,
  override,
  current,
  ...props
}) => {
  const [storedValue, setStoredValue] = useLocalStorage(override, "");
  const [value, setValue] = reactExports.useState(storedValue);
  const changeValue = reactExports.useCallback(
    (value2) => {
      setValue(value2);
      if (value2 === "" || validValue(validityType(override), value2)) {
        setStoredValue(value2);
      }
    },
    [override, setStoredValue]
  );
  const handleChange = reactExports.useCallback(
    (event) => {
      changeValue(event.target.value);
    },
    [changeValue]
  );
  const validity = validityType(override);
  const valid = validValue(validity, value);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { p: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { textAlign: "right", my: "auto", children: label ?? override }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { p: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ValidatedInput,
      {
        value,
        valid,
        onChange: handleChange,
        onBlur: refresh,
        changeValue,
        refresh,
        size: "2xs",
        minW: "6rem",
        placeholder: current,
        "data-lpignore": true
      }
    ) })
  ] });
};
const OverrideTable = ({
  heading,
  filterRegex,
  data,
  getOverride,
  getCurrent
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(H3, { textAlign: "center", children: heading }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, { size: "sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: data.map((item2) => {
    const override = getOverride(item2);
    return !filterRegex || filterRegex.test(override) && /* @__PURE__ */ jsxRuntimeExports.jsx(
      OverrideRow,
      {
        override,
        label: item2,
        current: getCurrent(item2)
      },
      override
    );
  }) }) })
] });
const PreferencesTable = ({ filterRegex }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  OverrideTable,
  {
    heading: "Preferences",
    filterRegex,
    data: preferences,
    getOverride: (property) => overrideName("getProperty", [property]),
    getCurrent: (property) => remoteCall("getProperty", [property], "", true)
  }
);
const TurnsSpentTable = ({ filterRegex }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  OverrideTable,
  {
    heading: "Turns Spent",
    filterRegex,
    data: locationsTurnsSpent,
    getOverride: (location) => `override:Location.get(${JSON.stringify(location)}).turnsSpent`,
    getCurrent: (location) => {
      var _a2, _b2;
      return ((_b2 = (_a2 = remoteCall(
        "toLocation",
        [location],
        {},
        true
      )) == null ? void 0 : _a2.turnsSpent) == null ? void 0 : _b2.toString()) ?? "";
    }
  }
);
const NoncombatQueueTable = ({ filterRegex }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  OverrideTable,
  {
    heading: "Noncombat Queue",
    filterRegex,
    data: locationsNoncombatQueue,
    getOverride: (location) => `override:Location.get(${JSON.stringify(location)}).noncombatQueue`,
    getCurrent: (location) => {
      var _a2, _b2;
      return ((_b2 = (_a2 = remoteCall(
        "toLocation",
        [location],
        {},
        true
      )) == null ? void 0 : _a2.noncombatQueue) == null ? void 0 : _b2.toString()) ?? "";
    }
  }
);
const ItemsTable = ({ filterRegex }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  OverrideTable,
  {
    heading: "Items",
    filterRegex,
    data: items.filter((item2) => Item.get(item2)),
    getOverride: (item2) => `override:availableAmount(Item.get(${JSON.stringify(item2)}))`,
    getCurrent: (item2) => {
      var _a2, _b2;
      return (_b2 = (_a2 = remoteCall(
        "availableAmount",
        [makePlaceholder("Item", item2)],
        0,
        true
      )) == null ? void 0 : _a2.toString) == null ? void 0 : _b2.call(_a2);
    }
  }
);
const EffectsTable = ({ filterRegex }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  OverrideTable,
  {
    heading: "Effects",
    filterRegex,
    data: effects.filter((effect2) => Effect.get(effect2)),
    getOverride: (effect2) => `override:haveEffect(Effect.get(${JSON.stringify(effect2)}))`,
    getCurrent: (effect2) => {
      var _a2, _b2;
      return (_b2 = (_a2 = remoteCall(
        "haveEffect",
        [makePlaceholder("Effect", effect2)],
        0,
        true
      )) == null ? void 0 : _a2.toString) == null ? void 0 : _b2.call(_a2);
    }
  }
);
function resetAll() {
  const overrideKeys = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key == null ? void 0 : key.startsWith("override:")) {
      overrideKeys.push(key);
    }
  }
  for (const key of overrideKeys) {
    localStorage.removeItem(key);
    fireStorageListeners(key, null);
  }
}
const Layout = () => {
  reactExports.useContext(RefreshContext);
  const [filter, setFilter] = useLocalStorage("filterRegex", "");
  const handleChange = reactExports.useCallback(
    (event) => setFilter(event.target.value),
    [setFilter]
  );
  let filterRegex = null, filterValid = true;
  try {
    filterRegex = new RegExp(filter, "i");
  } catch {
    filterValid = false;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { centerContent: true, maxW: 1e3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: 4, w: "full", align: "center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { textAlign: "center", children: "YORICK Development Overrides" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ValidatedInput,
      {
        value: filter,
        changeValue: setFilter,
        valid: filterValid,
        onChange: handleChange,
        placeholder: "Filter (regex)",
        size: "sm",
        minW: "20rem"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "outline", onClick: resetAll, children: "Reset All" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", align: "flex-start", justify: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(PreferencesTable, { filterRegex }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TurnsSpentTable, { filterRegex }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(NoncombatQueueTable, { filterRegex })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ItemsTable, { filterRegex }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(EffectsTable, { filterRegex })
      ] })
    ] })
  ] }) });
};
const App = () => /* @__PURE__ */ jsxRuntimeExports.jsx(ChakraProvider, { value: defaultSystem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, {}) }) });
const content = /* @__PURE__ */ jsxRuntimeExports.jsx(App$1, {});
const app = /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { basename: "/yorick", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: content }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "index.html", element: content }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "prefs", element: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }),
  " "
] }) }) });
const root = document.getElementById("root");
if (root) {
  createRoot(root).render(app);
}
